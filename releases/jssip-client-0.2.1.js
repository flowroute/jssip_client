/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/FlowrouteClient.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n//# sourceURL=webpack:///./node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Config.js":
/*!******************************************!*\
  !*** ./node_modules/jssip/lib/Config.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib/Grammar.js\");\nconst URI = __webpack_require__(/*! ./URI */ \"./node_modules/jssip/lib/URI.js\");\nconst Socket = __webpack_require__(/*! ./Socket */ \"./node_modules/jssip/lib/Socket.js\");\nconst Exceptions = __webpack_require__(/*! ./Exceptions */ \"./node_modules/jssip/lib/Exceptions.js\");\n\n// Default settings.\nexports.settings = {\n  // SIP authentication.\n  authorization_user : null,\n  password           : null,\n  realm              : null,\n  ha1                : null,\n\n  // SIP account.\n  display_name : null,\n  uri          : null,\n  contact_uri  : null,\n\n  // SIP instance id (GRUU).\n  instance_id : null,\n\n  // Preloaded SIP Route header field.\n  use_preloaded_route : false,\n\n  // Session parameters.\n  session_timers                : true,\n  session_timers_refresh_method : JsSIP_C.UPDATE,\n  no_answer_timeout             : 60,\n\n  // Registration parameters.\n  register         : true,\n  register_expires : 600,\n  registrar_server : null,\n\n  // Connection options.\n  sockets                          : null,\n  connection_recovery_max_interval : null,\n  connection_recovery_min_interval : null,\n\n  /*\n   * Host address.\n   * Value to be set in Via sent_by and host part of Contact FQDN.\n  */\n  via_host : `${Utils.createRandomToken(12)}.invalid`\n};\n\n// Configuration checks.\nconst checks = {\n  mandatory : {\n\n    sockets(sockets)\n    {\n      /* Allow defining sockets parameter as:\n       *  Socket: socket\n       *  Array of Socket: [socket1, socket2]\n       *  Array of Objects: [{socket: socket1, weight:1}, {socket: Socket2, weight:0}]\n       *  Array of Objects and Socket: [{socket: socket1}, socket2]\n       */\n      const _sockets = [];\n\n      if (Socket.isSocket(sockets))\n      {\n        _sockets.push({ socket: sockets });\n      }\n      else if (Array.isArray(sockets) && sockets.length)\n      {\n        for (const socket of sockets)\n        {\n          if (Object.prototype.hasOwnProperty.call(socket, 'socket') &&\n              Socket.isSocket(socket.socket))\n          {\n            _sockets.push(socket);\n          }\n          else if (Socket.isSocket(socket))\n          {\n            _sockets.push({ socket: socket });\n          }\n        }\n      }\n      else\n      {\n        return;\n      }\n\n      return _sockets;\n    },\n\n    uri(uri)\n    {\n      if (!/^sip:/i.test(uri))\n      {\n        uri = `${JsSIP_C.SIP}:${uri}`;\n      }\n      const parsed = URI.parse(uri);\n\n      if (!parsed)\n      {\n        return;\n      }\n      else if (!parsed.user)\n      {\n        return;\n      }\n      else\n      {\n        return parsed;\n      }\n    }\n  },\n\n  optional : {\n\n    authorization_user(authorization_user)\n    {\n      if (Grammar.parse(`\"${authorization_user}\"`, 'quoted_string') === -1)\n      {\n        return;\n      }\n      else\n      {\n        return authorization_user;\n      }\n    },\n\n    user_agent(user_agent)\n    {\n      if (typeof user_agent === 'string')\n      {\n        return user_agent;\n      }\n    },\n\n    connection_recovery_max_interval(connection_recovery_max_interval)\n    {\n      if (Utils.isDecimal(connection_recovery_max_interval))\n      {\n        const value = Number(connection_recovery_max_interval);\n\n        if (value > 0)\n        {\n          return value;\n        }\n      }\n    },\n\n    connection_recovery_min_interval(connection_recovery_min_interval)\n    {\n      if (Utils.isDecimal(connection_recovery_min_interval))\n      {\n        const value = Number(connection_recovery_min_interval);\n\n        if (value > 0)\n        {\n          return value;\n        }\n      }\n    },\n\n    contact_uri(contact_uri)\n    {\n      if (typeof contact_uri === 'string')\n      {\n        const uri = Grammar.parse(contact_uri, 'SIP_URI');\n\n        if (uri !== -1)\n        {\n          return uri;\n        }\n      }\n    },\n\n    display_name(display_name)\n    {\n      return display_name;\n    },\n\n    instance_id(instance_id)\n    {\n      if ((/^uuid:/i.test(instance_id)))\n      {\n        instance_id = instance_id.substr(5);\n      }\n\n      if (Grammar.parse(instance_id, 'uuid') === -1)\n      {\n        return;\n      }\n      else\n      {\n        return instance_id;\n      }\n    },\n\n    no_answer_timeout(no_answer_timeout)\n    {\n      if (Utils.isDecimal(no_answer_timeout))\n      {\n        const value = Number(no_answer_timeout);\n\n        if (value > 0)\n        {\n          return value;\n        }\n      }\n    },\n\n    session_timers(session_timers)\n    {\n      if (typeof session_timers === 'boolean')\n      {\n        return session_timers;\n      }\n    },\n\n    session_timers_refresh_method(method)\n    {\n      if (typeof method === 'string')\n      {\n        method = method.toUpperCase();\n\n        if (method === JsSIP_C.INVITE || method === JsSIP_C.UPDATE)\n        {\n          return method;\n        }\n      }\n    },\n\n    password(password)\n    {\n      return String(password);\n    },\n\n    realm(realm)\n    {\n      return String(realm);\n    },\n\n    ha1(ha1)\n    {\n      return String(ha1);\n    },\n\n    register(register)\n    {\n      if (typeof register === 'boolean')\n      {\n        return register;\n      }\n    },\n\n    register_expires(register_expires)\n    {\n      if (Utils.isDecimal(register_expires))\n      {\n        const value = Number(register_expires);\n\n        if (value > 0)\n        {\n          return value;\n        }\n      }\n    },\n\n    registrar_server(registrar_server)\n    {\n      if (!/^sip:/i.test(registrar_server))\n      {\n        registrar_server = `${JsSIP_C.SIP}:${registrar_server}`;\n      }\n\n      const parsed = URI.parse(registrar_server);\n\n      if (!parsed)\n      {\n        return;\n      }\n      else if (parsed.user)\n      {\n        return;\n      }\n      else\n      {\n        return parsed;\n      }\n    },\n\n    use_preloaded_route(use_preloaded_route)\n    {\n      if (typeof use_preloaded_route === 'boolean')\n      {\n        return use_preloaded_route;\n      }\n    }\n  }\n};\n\nexports.load = (dst, src) =>\n{\n  // Check Mandatory parameters.\n  for (const parameter in checks.mandatory)\n  {\n    if (!src.hasOwnProperty(parameter))\n    {\n      throw new Exceptions.ConfigurationError(parameter);\n    }\n    else\n    {\n      const value = src[parameter];\n      const checked_value = checks.mandatory[parameter](value);\n\n      if (checked_value !== undefined)\n      {\n        dst[parameter] = checked_value;\n      }\n      else\n      {\n        throw new Exceptions.ConfigurationError(parameter, value);\n      }\n    }\n  }\n\n  // Check Optional parameters.\n  for (const parameter in checks.optional)\n  {\n    if (src.hasOwnProperty(parameter))\n    {\n      const value = src[parameter];\n\n      /* If the parameter value is null, empty string, undefined, empty array\n       * or it's a number with NaN value, then apply its default value.\n       */\n      if (Utils.isEmpty(value))\n      {\n        continue;\n      }\n\n      const checked_value = checks.optional[parameter](value);\n\n      if (checked_value !== undefined)\n      {\n        dst[parameter] = checked_value;\n      }\n      else\n      {\n        throw new Exceptions.ConfigurationError(parameter, value);\n      }\n    }\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Config.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Constants.js":
/*!*********************************************!*\
  !*** ./node_modules/jssip/lib/Constants.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const pkg = __webpack_require__(/*! ../package.json */ \"./node_modules/jssip/package.json\");\n\nmodule.exports = {\n  USER_AGENT : `${pkg.title} ${pkg.version}`,\n\n  // SIP scheme.\n  SIP  : 'sip',\n  SIPS : 'sips',\n\n  // End and Failure causes.\n  causes : {\n    // Generic error causes.\n    CONNECTION_ERROR : 'Connection Error',\n    REQUEST_TIMEOUT  : 'Request Timeout',\n    SIP_FAILURE_CODE : 'SIP Failure Code',\n    INTERNAL_ERROR   : 'Internal Error',\n\n    // SIP error causes.\n    BUSY                 : 'Busy',\n    REJECTED             : 'Rejected',\n    REDIRECTED           : 'Redirected',\n    UNAVAILABLE          : 'Unavailable',\n    NOT_FOUND            : 'Not Found',\n    ADDRESS_INCOMPLETE   : 'Address Incomplete',\n    INCOMPATIBLE_SDP     : 'Incompatible SDP',\n    MISSING_SDP          : 'Missing SDP',\n    AUTHENTICATION_ERROR : 'Authentication Error',\n\n    // Session error causes.\n    BYE                      : 'Terminated',\n    WEBRTC_ERROR             : 'WebRTC Error',\n    CANCELED                 : 'Canceled',\n    NO_ANSWER                : 'No Answer',\n    EXPIRES                  : 'Expires',\n    NO_ACK                   : 'No ACK',\n    DIALOG_ERROR             : 'Dialog Error',\n    USER_DENIED_MEDIA_ACCESS : 'User Denied Media Access',\n    BAD_MEDIA_DESCRIPTION    : 'Bad Media Description',\n    RTP_TIMEOUT              : 'RTP Timeout'\n  },\n\n  SIP_ERROR_CAUSES : {\n    REDIRECTED           : [ 300, 301, 302, 305, 380 ],\n    BUSY                 : [ 486, 600 ],\n    REJECTED             : [ 403, 603 ],\n    NOT_FOUND            : [ 404, 604 ],\n    UNAVAILABLE          : [ 480, 410, 408, 430 ],\n    ADDRESS_INCOMPLETE   : [ 484, 424 ],\n    INCOMPATIBLE_SDP     : [ 488, 606 ],\n    AUTHENTICATION_ERROR : [ 401, 407 ]\n  },\n\n  // SIP Methods.\n  ACK       : 'ACK',\n  BYE       : 'BYE',\n  CANCEL    : 'CANCEL',\n  INFO      : 'INFO',\n  INVITE    : 'INVITE',\n  MESSAGE   : 'MESSAGE',\n  NOTIFY    : 'NOTIFY',\n  OPTIONS   : 'OPTIONS',\n  REGISTER  : 'REGISTER',\n  REFER     : 'REFER',\n  UPDATE    : 'UPDATE',\n  SUBSCRIBE : 'SUBSCRIBE',\n\n  /* SIP Response Reasons\n   * DOC: https://www.iana.org/assignments/sip-parameters\n   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7\n   */\n  REASON_PHRASE : {\n    100 : 'Trying',\n    180 : 'Ringing',\n    181 : 'Call Is Being Forwarded',\n    182 : 'Queued',\n    183 : 'Session Progress',\n    199 : 'Early Dialog Terminated', // draft-ietf-sipcore-199\n    200 : 'OK',\n    202 : 'Accepted', // RFC 3265\n    204 : 'No Notification', // RFC 5839\n    300 : 'Multiple Choices',\n    301 : 'Moved Permanently',\n    302 : 'Moved Temporarily',\n    305 : 'Use Proxy',\n    380 : 'Alternative Service',\n    400 : 'Bad Request',\n    401 : 'Unauthorized',\n    402 : 'Payment Required',\n    403 : 'Forbidden',\n    404 : 'Not Found',\n    405 : 'Method Not Allowed',\n    406 : 'Not Acceptable',\n    407 : 'Proxy Authentication Required',\n    408 : 'Request Timeout',\n    410 : 'Gone',\n    412 : 'Conditional Request Failed', // RFC 3903\n    413 : 'Request Entity Too Large',\n    414 : 'Request-URI Too Long',\n    415 : 'Unsupported Media Type',\n    416 : 'Unsupported URI Scheme',\n    417 : 'Unknown Resource-Priority', // RFC 4412\n    420 : 'Bad Extension',\n    421 : 'Extension Required',\n    422 : 'Session Interval Too Small', // RFC 4028\n    423 : 'Interval Too Brief',\n    424 : 'Bad Location Information', // RFC 6442\n    428 : 'Use Identity Header', // RFC 4474\n    429 : 'Provide Referrer Identity', // RFC 3892\n    430 : 'Flow Failed', // RFC 5626\n    433 : 'Anonymity Disallowed', // RFC 5079\n    436 : 'Bad Identity-Info', // RFC 4474\n    437 : 'Unsupported Certificate', // RFC 4744\n    438 : 'Invalid Identity Header', // RFC 4744\n    439 : 'First Hop Lacks Outbound Support', // RFC 5626\n    440 : 'Max-Breadth Exceeded', // RFC 5393\n    469 : 'Bad Info Package', // draft-ietf-sipcore-info-events\n    470 : 'Consent Needed', // RFC 5360\n    478 : 'Unresolvable Destination', // Custom code copied from Kamailio.\n    480 : 'Temporarily Unavailable',\n    481 : 'Call/Transaction Does Not Exist',\n    482 : 'Loop Detected',\n    483 : 'Too Many Hops',\n    484 : 'Address Incomplete',\n    485 : 'Ambiguous',\n    486 : 'Busy Here',\n    487 : 'Request Terminated',\n    488 : 'Not Acceptable Here',\n    489 : 'Bad Event', // RFC 3265\n    491 : 'Request Pending',\n    493 : 'Undecipherable',\n    494 : 'Security Agreement Required', // RFC 3329\n    500 : 'JsSIP Internal Error',\n    501 : 'Not Implemented',\n    502 : 'Bad Gateway',\n    503 : 'Service Unavailable',\n    504 : 'Server Time-out',\n    505 : 'Version Not Supported',\n    513 : 'Message Too Large',\n    580 : 'Precondition Failure', // RFC 3312\n    600 : 'Busy Everywhere',\n    603 : 'Decline',\n    604 : 'Does Not Exist Anywhere',\n    606 : 'Not Acceptable'\n  },\n\n  ALLOWED_METHODS     : 'INVITE,ACK,CANCEL,BYE,UPDATE,MESSAGE,OPTIONS,REFER,INFO',\n  ACCEPTED_BODY_TYPES : 'application/sdp, application/dtmf-relay',\n  MAX_FORWARDS        : 69,\n  SESSION_EXPIRES     : 90,\n  MIN_SESSION_EXPIRES : 60\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Constants.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Dialog.js":
/*!******************************************!*\
  !*** ./node_modules/jssip/lib/Dialog.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib/SIPMessage.js\");\nconst JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst Transactions = __webpack_require__(/*! ./Transactions */ \"./node_modules/jssip/lib/Transactions.js\");\nconst Dialog_RequestSender = __webpack_require__(/*! ./Dialog/RequestSender */ \"./node_modules/jssip/lib/Dialog/RequestSender.js\");\nconst Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:Dialog');\n\nconst C = {\n  // Dialog states.\n  STATUS_EARLY     : 1,\n  STATUS_CONFIRMED : 2\n};\n\n// RFC 3261 12.1.\nmodule.exports = class Dialog\n{\n  // Expose C object.\n  static get C()\n  {\n    return C;\n  }\n\n  constructor(owner, message, type, state = C.STATUS_CONFIRMED)\n  {\n    this._owner = owner;\n    this._ua = owner._ua;\n\n    this._uac_pending_reply = false;\n    this._uas_pending_reply = false;\n\n    if (!message.hasHeader('contact'))\n    {\n      return {\n        error : 'unable to create a Dialog without Contact header field'\n      };\n    }\n\n    if (message instanceof SIPMessage.IncomingResponse)\n    {\n      state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;\n    }\n\n    const contact = message.parseHeader('contact');\n\n    // RFC 3261 12.1.1.\n    if (type === 'UAS')\n    {\n      this._id = {\n        call_id    : message.call_id,\n        local_tag  : message.to_tag,\n        remote_tag : message.from_tag,\n        toString()\n        {\n          return this.call_id + this.local_tag + this.remote_tag;\n        }\n      };\n      this._state = state;\n      this._remote_seqnum = message.cseq;\n      this._local_uri = message.parseHeader('to').uri;\n      this._remote_uri = message.parseHeader('from').uri;\n      this._remote_target = contact.uri;\n      this._route_set = message.getHeaders('record-route');\n      this._ack_seqnum = this._remote_seqnum;\n    }\n    // RFC 3261 12.1.2.\n    else if (type === 'UAC')\n    {\n      this._id = {\n        call_id    : message.call_id,\n        local_tag  : message.from_tag,\n        remote_tag : message.to_tag,\n        toString()\n        {\n          return this.call_id + this.local_tag + this.remote_tag;\n        }\n      };\n      this._state = state;\n      this._local_seqnum = message.cseq;\n      this._local_uri = message.parseHeader('from').uri;\n      this._remote_uri = message.parseHeader('to').uri;\n      this._remote_target = contact.uri;\n      this._route_set = message.getHeaders('record-route').reverse();\n      this._ack_seqnum = null;\n\n    }\n\n    this._ua.newDialog(this);\n    debug(`new ${type} dialog created with status ${this._state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'}`);\n  }\n\n  get id()\n  {\n    return this._id;\n  }\n\n  get local_seqnum()\n  {\n    return this._local_seqnum;\n  }\n\n  set local_seqnum(num)\n  {\n    this._local_seqnum = num;\n  }\n\n  get owner()\n  {\n    return this._owner;\n  }\n\n  get uac_pending_reply()\n  {\n    return this._uac_pending_reply;\n  }\n\n  set uac_pending_reply(pending)\n  {\n    this._uac_pending_reply = pending;\n  }\n\n  get uas_pending_reply()\n  {\n    return this._uas_pending_reply;\n  }\n\n  update(message, type)\n  {\n    this._state = C.STATUS_CONFIRMED;\n\n    debug(`dialog ${this._id.toString()}  changed to CONFIRMED state`);\n\n    if (type === 'UAC')\n    {\n      // RFC 3261 13.2.2.4.\n      this._route_set = message.getHeaders('record-route').reverse();\n    }\n  }\n\n  terminate()\n  {\n    debug(`dialog ${this._id.toString()} deleted`);\n    this._ua.destroyDialog(this);\n  }\n\n  sendRequest(method, options = {})\n  {\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const eventHandlers = options.eventHandlers || {};\n    const body = options.body || null;\n    const request = this._createRequest(method, extraHeaders, body);\n\n    // Increase the local CSeq on authentication.\n    eventHandlers.onAuthenticated = () =>\n    {\n      this._local_seqnum += 1;\n    };\n\n    const request_sender = new Dialog_RequestSender(this, request, eventHandlers);\n\n    request_sender.send();\n\n    // Return the instance of OutgoingRequest.\n    return request;\n  }\n\n  receiveRequest(request)\n  {\n    // Check in-dialog request.\n    if (!this._checkInDialogRequest(request))\n    {\n      return;\n    }\n\n    // ACK received. Cleanup this._ack_seqnum.\n    if (request.method === JsSIP_C.ACK && this._ack_seqnum !== null)\n    {\n      this._ack_seqnum = null;\n    }\n    // INVITE received. Set this._ack_seqnum.\n    else if (request.method === JsSIP_C.INVITE)\n    {\n      this._ack_seqnum = request.cseq;\n    }\n\n    this._owner.receiveRequest(request);\n  }\n\n  // RFC 3261 12.2.1.1.\n  _createRequest(method, extraHeaders, body)\n  {\n    extraHeaders = Utils.cloneArray(extraHeaders);\n\n    if (!this._local_seqnum) { this._local_seqnum = Math.floor(Math.random() * 10000); }\n\n    const cseq = (method === JsSIP_C.CANCEL || method === JsSIP_C.ACK) ?\n      this._local_seqnum :\n      this._local_seqnum += 1;\n\n    const request = new SIPMessage.OutgoingRequest(\n      method,\n      this._remote_target,\n      this._ua, {\n        'cseq'      : cseq,\n        'call_id'   : this._id.call_id,\n        'from_uri'  : this._local_uri,\n        'from_tag'  : this._id.local_tag,\n        'to_uri'    : this._remote_uri,\n        'to_tag'    : this._id.remote_tag,\n        'route_set' : this._route_set\n      }, extraHeaders, body);\n\n    return request;\n  }\n\n  // RFC 3261 12.2.2.\n  _checkInDialogRequest(request)\n  {\n\n    if (!this._remote_seqnum)\n    {\n      this._remote_seqnum = request.cseq;\n    }\n    else if (request.cseq < this._remote_seqnum)\n    {\n      if (request.method === JsSIP_C.ACK)\n      {\n        // We are not expecting any ACK with lower seqnum than the current one.\n        // Or this is not the ACK we are waiting for.\n        if (this._ack_seqnum === null || request.cseq !== this._ack_seqnum)\n        {\n          return false;\n        }\n      }\n      else\n      {\n        request.reply(500);\n\n        return false;\n      }\n    }\n    else if (request.cseq > this._remote_seqnum)\n    {\n      this._remote_seqnum = request.cseq;\n    }\n\n    // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-.\n    if (request.method === JsSIP_C.INVITE ||\n        (request.method === JsSIP_C.UPDATE && request.body))\n    {\n      if (this._uac_pending_reply === true)\n      {\n        request.reply(491);\n      }\n      else if (this._uas_pending_reply === true)\n      {\n        const retryAfter = (Math.random() * 10 | 0) + 1;\n\n        request.reply(500, null, [ `Retry-After:${retryAfter}` ]);\n\n        return false;\n      }\n      else\n      {\n        this._uas_pending_reply = true;\n\n        const stateChanged = () =>\n        {\n          if (request.server_transaction.state === Transactions.C.STATUS_ACCEPTED ||\n              request.server_transaction.state === Transactions.C.STATUS_COMPLETED ||\n              request.server_transaction.state === Transactions.C.STATUS_TERMINATED)\n          {\n\n            request.server_transaction.removeListener('stateChanged', stateChanged);\n            this._uas_pending_reply = false;\n          }\n        };\n\n        request.server_transaction.on('stateChanged', stateChanged);\n      }\n\n      // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted.\n      if (request.hasHeader('contact'))\n      {\n        request.server_transaction.on('stateChanged', () =>\n        {\n          if (request.server_transaction.state === Transactions.C.STATUS_ACCEPTED)\n          {\n            this._remote_target = request.parseHeader('contact').uri;\n          }\n        });\n      }\n    }\n    else if (request.method === JsSIP_C.NOTIFY)\n    {\n      // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted.\n      if (request.hasHeader('contact'))\n      {\n        request.server_transaction.on('stateChanged', () =>\n        {\n          if (request.server_transaction.state === Transactions.C.STATUS_COMPLETED)\n          {\n            this._remote_target = request.parseHeader('contact').uri;\n          }\n        });\n      }\n    }\n\n    return true;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Dialog.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Dialog/RequestSender.js":
/*!********************************************************!*\
  !*** ./node_modules/jssip/lib/Dialog/RequestSender.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const JsSIP_C = __webpack_require__(/*! ../Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst Transactions = __webpack_require__(/*! ../Transactions */ \"./node_modules/jssip/lib/Transactions.js\");\nconst RTCSession = __webpack_require__(/*! ../RTCSession */ \"./node_modules/jssip/lib/RTCSession.js\");\nconst RequestSender = __webpack_require__(/*! ../RequestSender */ \"./node_modules/jssip/lib/RequestSender.js\");\n\n// Default event handlers.\nconst EventHandlers = {\n  onRequestTimeout  : () => {},\n  onTransportError  : () => {},\n  onSuccessResponse : () => {},\n  onErrorResponse   : () => {},\n  onAuthenticated   : () => {},\n  onDialogError     : () => {}\n};\n\nmodule.exports = class DialogRequestSender\n{\n  constructor(dialog, request, eventHandlers)\n  {\n    this._dialog = dialog;\n    this._ua = dialog._ua;\n    this._request = request;\n    this._eventHandlers = eventHandlers;\n\n    // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.\n    this._reattempt = false;\n    this._reattemptTimer = null;\n\n    // Define the undefined handlers.\n    for (const handler in EventHandlers)\n    {\n      if (Object.prototype.hasOwnProperty.call(EventHandlers, handler))\n      {\n        if (!this._eventHandlers[handler])\n        {\n          this._eventHandlers[handler] = EventHandlers[handler];\n        }\n      }\n    }\n  }\n\n  get request()\n  {\n    return this._request;\n  }\n\n  send()\n  {\n    const request_sender = new RequestSender(this._ua, this._request, {\n      onRequestTimeout : () =>\n      {\n        this._eventHandlers.onRequestTimeout();\n      },\n      onTransportError : () =>\n      {\n        this._eventHandlers.onTransportError();\n      },\n      onAuthenticated : (request) =>\n      {\n        this._eventHandlers.onAuthenticated(request);\n      },\n      onReceiveResponse : (response) =>\n      {\n        this._receiveResponse(response);\n      }\n    });\n\n    request_sender.send();\n\n    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-.\n    if ((this._request.method === JsSIP_C.INVITE ||\n          (this._request.method === JsSIP_C.UPDATE && this._request.body)) &&\n        request_sender.clientTransaction.state !== Transactions.C.STATUS_TERMINATED)\n    {\n      this._dialog.uac_pending_reply = true;\n\n      const stateChanged = () =>\n      {\n        if (request_sender.clientTransaction.state === Transactions.C.STATUS_ACCEPTED ||\n            request_sender.clientTransaction.state === Transactions.C.STATUS_COMPLETED ||\n            request_sender.clientTransaction.state === Transactions.C.STATUS_TERMINATED)\n        {\n          request_sender.clientTransaction.removeListener('stateChanged', stateChanged);\n          this._dialog.uac_pending_reply = false;\n        }\n      };\n\n      request_sender.clientTransaction.on('stateChanged', stateChanged);\n    }\n  }\n\n  _receiveResponse(response)\n  {\n    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.\n    if (response.status_code === 408 || response.status_code === 481)\n    {\n      this._eventHandlers.onDialogError(response);\n    }\n    else if (response.method === JsSIP_C.INVITE && response.status_code === 491)\n    {\n      if (this._reattempt)\n      {\n        if (response.status_code >= 200 && response.status_code < 300)\n        {\n          this._eventHandlers.onSuccessResponse(response);\n        }\n        else if (response.status_code >= 300)\n        {\n          this._eventHandlers.onErrorResponse(response);\n        }\n      }\n      else\n      {\n        this._request.cseq.value = this._dialog.local_seqnum += 1;\n        this._reattemptTimer = setTimeout(() =>\n        {\n          // TODO: look at dialog state instead.\n          if (this._dialog.owner.status !== RTCSession.C.STATUS_TERMINATED)\n          {\n            this._reattempt = true;\n            this._request_sender.send();\n          }\n        }, 1000);\n      }\n    }\n    else if (response.status_code >= 200 && response.status_code < 300)\n    {\n      this._eventHandlers.onSuccessResponse(response);\n    }\n    else if (response.status_code >= 300)\n    {\n      this._eventHandlers.onErrorResponse(response);\n    }\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Dialog/RequestSender.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/DigestAuthentication.js":
/*!********************************************************!*\
  !*** ./node_modules/jssip/lib/DigestAuthentication.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:DigestAuthentication');\nconst debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:ERROR:DigestAuthentication');\n\ndebugerror.log = console.warn.bind(console);\n\nmodule.exports = class DigestAuthentication\n{\n  constructor(credentials)\n  {\n    this._credentials = credentials;\n    this._cnonce = null;\n    this._nc = 0;\n    this._ncHex = '00000000';\n    this._algorithm = null;\n    this._realm = null;\n    this._nonce = null;\n    this._opaque = null;\n    this._stale = null;\n    this._qop = null;\n    this._method = null;\n    this._uri = null;\n    this._ha1 = null;\n    this._response = null;\n  }\n\n  get(parameter)\n  {\n    switch (parameter)\n    {\n      case 'realm':\n        return this._realm;\n\n      case 'ha1':\n        return this._ha1;\n\n      default:\n        debugerror('get() | cannot get \"%s\" parameter', parameter);\n\n        return undefined;\n    }\n  }\n\n  /**\n  * Performs Digest authentication given a SIP request and the challenge\n  * received in a response to that request.\n  * Returns true if auth was successfully generated, false otherwise.\n  */\n  authenticate({ method, ruri, body }, challenge, cnonce = null /* test interface */)\n  {\n    this._algorithm = challenge.algorithm;\n    this._realm = challenge.realm;\n    this._nonce = challenge.nonce;\n    this._opaque = challenge.opaque;\n    this._stale = challenge.stale;\n\n    if (this._algorithm)\n    {\n      if (this._algorithm !== 'MD5')\n      {\n        debugerror('authenticate() | challenge with Digest algorithm different than \"MD5\", authentication aborted');\n\n        return false;\n      }\n    }\n    else\n    {\n      this._algorithm = 'MD5';\n    }\n\n    if (!this._nonce)\n    {\n      debugerror('authenticate() | challenge without Digest nonce, authentication aborted');\n\n      return false;\n    }\n\n    if (!this._realm)\n    {\n      debugerror('authenticate() | challenge without Digest realm, authentication aborted');\n\n      return false;\n    }\n\n    // If no plain SIP password is provided.\n    if (!this._credentials.password)\n    {\n      // If ha1 is not provided we cannot authenticate.\n      if (!this._credentials.ha1)\n      {\n        debugerror('authenticate() | no plain SIP password nor ha1 provided, authentication aborted');\n\n        return false;\n      }\n\n      // If the realm does not match the stored realm we cannot authenticate.\n      if (this._credentials.realm !== this._realm)\n      {\n        debugerror('authenticate() | no plain SIP password, and stored `realm` does not match the given `realm`, cannot authenticate [stored:\"%s\", given:\"%s\"]', this._credentials.realm, this._realm);\n\n        return false;\n      }\n    }\n\n    // 'qop' can contain a list of values (Array). Let's choose just one.\n    if (challenge.qop)\n    {\n      if (challenge.qop.indexOf('auth-int') > -1)\n      {\n        this._qop = 'auth-int';\n      }\n      else if (challenge.qop.indexOf('auth') > -1)\n      {\n        this._qop = 'auth';\n      }\n      else\n      {\n        // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.\n        debugerror('authenticate() | challenge without Digest qop different than \"auth\" or \"auth-int\", authentication aborted');\n\n        return false;\n      }\n    }\n    else\n    {\n      this._qop = null;\n    }\n\n    // Fill other attributes.\n\n    this._method = method;\n    this._uri = ruri;\n    this._cnonce = cnonce || Utils.createRandomToken(12);\n    this._nc += 1;\n    const hex = Number(this._nc).toString(16);\n\n    this._ncHex = '00000000'.substr(0, 8-hex.length) + hex;\n\n    // Nc-value = 8LHEX. Max value = 'FFFFFFFF'.\n    if (this._nc === 4294967296)\n    {\n      this._nc = 1;\n      this._ncHex = '00000001';\n    }\n\n    // Calculate the Digest \"response\" value.\n\n    // If we have plain SIP password then regenerate ha1.\n    if (this._credentials.password)\n    {\n      // HA1 = MD5(A1) = MD5(username:realm:password).\n      this._ha1 = Utils.calculateMD5(`${this._credentials.username}:${this._realm}:${this._credentials.password}`);\n    }\n    // Otherwise reuse the stored ha1.\n    else\n    {\n      this._ha1 = this._credentials.ha1;\n    }\n\n    let a2;\n    let ha2;\n\n    if (this._qop === 'auth')\n    {\n      // HA2 = MD5(A2) = MD5(method:digestURI).\n      a2 = `${this._method}:${this._uri}`;\n      ha2 = Utils.calculateMD5(a2);\n\n      debug('authenticate() | using qop=auth [a2:\"%s\"]', a2);\n\n      // Response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2).\n      this._response = Utils.calculateMD5(`${this._ha1}:${this._nonce}:${this._ncHex}:${this._cnonce}:auth:${ha2}`);\n\n    }\n    else if (this._qop === 'auth-int')\n    {\n      // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody)).\n      a2 = `${this._method}:${this._uri}:${Utils.calculateMD5(body ? body : '')}`;\n      ha2 = Utils.calculateMD5(a2);\n\n      debug('authenticate() | using qop=auth-int [a2:\"%s\"]', a2);\n\n      // Response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2).\n      this._response = Utils.calculateMD5(`${this._ha1}:${this._nonce}:${this._ncHex}:${this._cnonce}:auth-int:${ha2}`);\n\n    }\n    else if (this._qop === null)\n    {\n      // HA2 = MD5(A2) = MD5(method:digestURI).\n      a2 = `${this._method}:${this._uri}`;\n      ha2 = Utils.calculateMD5(a2);\n\n      debug('authenticate() | using qop=null [a2:\"%s\"]', a2);\n\n      // Response = MD5(HA1:nonce:HA2).\n      this._response = Utils.calculateMD5(`${this._ha1}:${this._nonce}:${ha2}`);\n    }\n\n    debug('authenticate() | response generated');\n\n    return true;\n  }\n\n  /**\n  * Return the Proxy-Authorization or WWW-Authorization header value.\n  */\n  toString()\n  {\n    const auth_params = [];\n\n    if (!this._response)\n    {\n      throw new Error('response field does not exist, cannot generate Authorization header');\n    }\n\n    auth_params.push(`algorithm=${this._algorithm}`);\n    auth_params.push(`username=\"${this._credentials.username}\"`);\n    auth_params.push(`realm=\"${this._realm}\"`);\n    auth_params.push(`nonce=\"${this._nonce}\"`);\n    auth_params.push(`uri=\"${this._uri}\"`);\n    auth_params.push(`response=\"${this._response}\"`);\n    if (this._opaque)\n    {\n      auth_params.push(`opaque=\"${this._opaque}\"`);\n    }\n    if (this._qop)\n    {\n      auth_params.push(`qop=${this._qop}`);\n      auth_params.push(`cnonce=\"${this._cnonce}\"`);\n      auth_params.push(`nc=${this._ncHex}`);\n    }\n\n    return `Digest ${auth_params.join(', ')}`;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/DigestAuthentication.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Exceptions.js":
/*!**********************************************!*\
  !*** ./node_modules/jssip/lib/Exceptions.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class ConfigurationError extends Error\n{\n  constructor(parameter, value)\n  {\n    super();\n\n    this.code = 1;\n    this.name = 'CONFIGURATION_ERROR';\n    this.parameter = parameter;\n    this.value = value;\n    this.message = (!this.value)?\n      `Missing parameter: ${this.parameter}` :\n      `Invalid value ${JSON.stringify(this.value)} for parameter \"${this.parameter}\"`;\n  }\n}\n\nclass InvalidStateError extends Error\n{\n  constructor(status)\n  {\n    super();\n\n    this.code = 2;\n    this.name = 'INVALID_STATE_ERROR';\n    this.status = status;\n    this.message = `Invalid status: ${status}`;\n  }\n}\n\nclass NotSupportedError extends Error\n{\n  constructor(message)\n  {\n    super();\n\n    this.code = 3;\n    this.name = 'NOT_SUPPORTED_ERROR';\n    this.message = message;\n  }\n}\n\nclass NotReadyError extends Error\n{\n  constructor(message)\n  {\n    super();\n\n    this.code = 4;\n    this.name = 'NOT_READY_ERROR';\n    this.message = message;\n  }\n}\n\nmodule.exports = {\n  ConfigurationError,\n  InvalidStateError,\n  NotSupportedError,\n  NotReadyError\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Exceptions.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Grammar.js":
/*!*******************************************!*\
  !*** ./node_modules/jssip/lib/Grammar.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = (function(){\n  /*\n   * Generated by PEG.js 0.7.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n  function quote(s) {\n    /*\n     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a\n     * string literal except for the closing quote character, backslash,\n     * carriage return, line separator, paragraph separator, and line feed.\n     * Any character may appear in the form of an escape sequence.\n     *\n     * For portability, we also escape escape all control and non-ASCII\n     * characters. Note that \"\\0\" and \"\\v\" escape sequences are not used\n     * because JSHint does not like the first and IE the second.\n     */\n     return '\"' + s\n      .replace(/\\\\/g, '\\\\\\\\')  // backslash\n      .replace(/\"/g, '\\\\\"')    // closing quote character\n      .replace(/\\x08/g, '\\\\b') // backspace\n      .replace(/\\t/g, '\\\\t')   // horizontal tab\n      .replace(/\\n/g, '\\\\n')   // line feed\n      .replace(/\\f/g, '\\\\f')   // form feed\n      .replace(/\\r/g, '\\\\r')   // carriage return\n      .replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape)\n      + '\"';\n  }\n  var result = {\n    /*\n     * Parses the input with a generated parser. If the parsing is successfull,\n     * returns a value explicitly or implicitly specified by the grammar from\n     * which the parser was generated (see |PEG.buildParser|). If the parsing is\n     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.\n     */\n    parse: function(input, startRule) {\n      var parseFunctions = {\n        \"CRLF\": parse_CRLF,\n        \"DIGIT\": parse_DIGIT,\n        \"ALPHA\": parse_ALPHA,\n        \"HEXDIG\": parse_HEXDIG,\n        \"WSP\": parse_WSP,\n        \"OCTET\": parse_OCTET,\n        \"DQUOTE\": parse_DQUOTE,\n        \"SP\": parse_SP,\n        \"HTAB\": parse_HTAB,\n        \"alphanum\": parse_alphanum,\n        \"reserved\": parse_reserved,\n        \"unreserved\": parse_unreserved,\n        \"mark\": parse_mark,\n        \"escaped\": parse_escaped,\n        \"LWS\": parse_LWS,\n        \"SWS\": parse_SWS,\n        \"HCOLON\": parse_HCOLON,\n        \"TEXT_UTF8_TRIM\": parse_TEXT_UTF8_TRIM,\n        \"TEXT_UTF8char\": parse_TEXT_UTF8char,\n        \"UTF8_NONASCII\": parse_UTF8_NONASCII,\n        \"UTF8_CONT\": parse_UTF8_CONT,\n        \"LHEX\": parse_LHEX,\n        \"token\": parse_token,\n        \"token_nodot\": parse_token_nodot,\n        \"separators\": parse_separators,\n        \"word\": parse_word,\n        \"STAR\": parse_STAR,\n        \"SLASH\": parse_SLASH,\n        \"EQUAL\": parse_EQUAL,\n        \"LPAREN\": parse_LPAREN,\n        \"RPAREN\": parse_RPAREN,\n        \"RAQUOT\": parse_RAQUOT,\n        \"LAQUOT\": parse_LAQUOT,\n        \"COMMA\": parse_COMMA,\n        \"SEMI\": parse_SEMI,\n        \"COLON\": parse_COLON,\n        \"LDQUOT\": parse_LDQUOT,\n        \"RDQUOT\": parse_RDQUOT,\n        \"comment\": parse_comment,\n        \"ctext\": parse_ctext,\n        \"quoted_string\": parse_quoted_string,\n        \"quoted_string_clean\": parse_quoted_string_clean,\n        \"qdtext\": parse_qdtext,\n        \"quoted_pair\": parse_quoted_pair,\n        \"SIP_URI_noparams\": parse_SIP_URI_noparams,\n        \"SIP_URI\": parse_SIP_URI,\n        \"uri_scheme\": parse_uri_scheme,\n        \"uri_scheme_sips\": parse_uri_scheme_sips,\n        \"uri_scheme_sip\": parse_uri_scheme_sip,\n        \"userinfo\": parse_userinfo,\n        \"user\": parse_user,\n        \"user_unreserved\": parse_user_unreserved,\n        \"password\": parse_password,\n        \"hostport\": parse_hostport,\n        \"host\": parse_host,\n        \"hostname\": parse_hostname,\n        \"domainlabel\": parse_domainlabel,\n        \"toplabel\": parse_toplabel,\n        \"IPv6reference\": parse_IPv6reference,\n        \"IPv6address\": parse_IPv6address,\n        \"h16\": parse_h16,\n        \"ls32\": parse_ls32,\n        \"IPv4address\": parse_IPv4address,\n        \"dec_octet\": parse_dec_octet,\n        \"port\": parse_port,\n        \"uri_parameters\": parse_uri_parameters,\n        \"uri_parameter\": parse_uri_parameter,\n        \"transport_param\": parse_transport_param,\n        \"user_param\": parse_user_param,\n        \"method_param\": parse_method_param,\n        \"ttl_param\": parse_ttl_param,\n        \"maddr_param\": parse_maddr_param,\n        \"lr_param\": parse_lr_param,\n        \"other_param\": parse_other_param,\n        \"pname\": parse_pname,\n        \"pvalue\": parse_pvalue,\n        \"paramchar\": parse_paramchar,\n        \"param_unreserved\": parse_param_unreserved,\n        \"headers\": parse_headers,\n        \"header\": parse_header,\n        \"hname\": parse_hname,\n        \"hvalue\": parse_hvalue,\n        \"hnv_unreserved\": parse_hnv_unreserved,\n        \"Request_Response\": parse_Request_Response,\n        \"Request_Line\": parse_Request_Line,\n        \"Request_URI\": parse_Request_URI,\n        \"absoluteURI\": parse_absoluteURI,\n        \"hier_part\": parse_hier_part,\n        \"net_path\": parse_net_path,\n        \"abs_path\": parse_abs_path,\n        \"opaque_part\": parse_opaque_part,\n        \"uric\": parse_uric,\n        \"uric_no_slash\": parse_uric_no_slash,\n        \"path_segments\": parse_path_segments,\n        \"segment\": parse_segment,\n        \"param\": parse_param,\n        \"pchar\": parse_pchar,\n        \"scheme\": parse_scheme,\n        \"authority\": parse_authority,\n        \"srvr\": parse_srvr,\n        \"reg_name\": parse_reg_name,\n        \"query\": parse_query,\n        \"SIP_Version\": parse_SIP_Version,\n        \"INVITEm\": parse_INVITEm,\n        \"ACKm\": parse_ACKm,\n        \"OPTIONSm\": parse_OPTIONSm,\n        \"BYEm\": parse_BYEm,\n        \"CANCELm\": parse_CANCELm,\n        \"REGISTERm\": parse_REGISTERm,\n        \"SUBSCRIBEm\": parse_SUBSCRIBEm,\n        \"NOTIFYm\": parse_NOTIFYm,\n        \"REFERm\": parse_REFERm,\n        \"Method\": parse_Method,\n        \"Status_Line\": parse_Status_Line,\n        \"Status_Code\": parse_Status_Code,\n        \"extension_code\": parse_extension_code,\n        \"Reason_Phrase\": parse_Reason_Phrase,\n        \"Allow_Events\": parse_Allow_Events,\n        \"Call_ID\": parse_Call_ID,\n        \"Contact\": parse_Contact,\n        \"contact_param\": parse_contact_param,\n        \"name_addr\": parse_name_addr,\n        \"display_name\": parse_display_name,\n        \"contact_params\": parse_contact_params,\n        \"c_p_q\": parse_c_p_q,\n        \"c_p_expires\": parse_c_p_expires,\n        \"delta_seconds\": parse_delta_seconds,\n        \"qvalue\": parse_qvalue,\n        \"generic_param\": parse_generic_param,\n        \"gen_value\": parse_gen_value,\n        \"Content_Disposition\": parse_Content_Disposition,\n        \"disp_type\": parse_disp_type,\n        \"disp_param\": parse_disp_param,\n        \"handling_param\": parse_handling_param,\n        \"Content_Encoding\": parse_Content_Encoding,\n        \"Content_Length\": parse_Content_Length,\n        \"Content_Type\": parse_Content_Type,\n        \"media_type\": parse_media_type,\n        \"m_type\": parse_m_type,\n        \"discrete_type\": parse_discrete_type,\n        \"composite_type\": parse_composite_type,\n        \"extension_token\": parse_extension_token,\n        \"x_token\": parse_x_token,\n        \"m_subtype\": parse_m_subtype,\n        \"m_parameter\": parse_m_parameter,\n        \"m_value\": parse_m_value,\n        \"CSeq\": parse_CSeq,\n        \"CSeq_value\": parse_CSeq_value,\n        \"Expires\": parse_Expires,\n        \"Event\": parse_Event,\n        \"event_type\": parse_event_type,\n        \"From\": parse_From,\n        \"from_param\": parse_from_param,\n        \"tag_param\": parse_tag_param,\n        \"Max_Forwards\": parse_Max_Forwards,\n        \"Min_Expires\": parse_Min_Expires,\n        \"Name_Addr_Header\": parse_Name_Addr_Header,\n        \"Proxy_Authenticate\": parse_Proxy_Authenticate,\n        \"challenge\": parse_challenge,\n        \"other_challenge\": parse_other_challenge,\n        \"auth_param\": parse_auth_param,\n        \"digest_cln\": parse_digest_cln,\n        \"realm\": parse_realm,\n        \"realm_value\": parse_realm_value,\n        \"domain\": parse_domain,\n        \"URI\": parse_URI,\n        \"nonce\": parse_nonce,\n        \"nonce_value\": parse_nonce_value,\n        \"opaque\": parse_opaque,\n        \"stale\": parse_stale,\n        \"algorithm\": parse_algorithm,\n        \"qop_options\": parse_qop_options,\n        \"qop_value\": parse_qop_value,\n        \"Proxy_Require\": parse_Proxy_Require,\n        \"Record_Route\": parse_Record_Route,\n        \"rec_route\": parse_rec_route,\n        \"Reason\": parse_Reason,\n        \"reason_param\": parse_reason_param,\n        \"reason_cause\": parse_reason_cause,\n        \"Require\": parse_Require,\n        \"Route\": parse_Route,\n        \"route_param\": parse_route_param,\n        \"Subscription_State\": parse_Subscription_State,\n        \"substate_value\": parse_substate_value,\n        \"subexp_params\": parse_subexp_params,\n        \"event_reason_value\": parse_event_reason_value,\n        \"Subject\": parse_Subject,\n        \"Supported\": parse_Supported,\n        \"To\": parse_To,\n        \"to_param\": parse_to_param,\n        \"Via\": parse_Via,\n        \"via_param\": parse_via_param,\n        \"via_params\": parse_via_params,\n        \"via_ttl\": parse_via_ttl,\n        \"via_maddr\": parse_via_maddr,\n        \"via_received\": parse_via_received,\n        \"via_branch\": parse_via_branch,\n        \"response_port\": parse_response_port,\n        \"sent_protocol\": parse_sent_protocol,\n        \"protocol_name\": parse_protocol_name,\n        \"transport\": parse_transport,\n        \"sent_by\": parse_sent_by,\n        \"via_host\": parse_via_host,\n        \"via_port\": parse_via_port,\n        \"ttl\": parse_ttl,\n        \"WWW_Authenticate\": parse_WWW_Authenticate,\n        \"Session_Expires\": parse_Session_Expires,\n        \"s_e_expires\": parse_s_e_expires,\n        \"s_e_params\": parse_s_e_params,\n        \"s_e_refresher\": parse_s_e_refresher,\n        \"extension_header\": parse_extension_header,\n        \"header_value\": parse_header_value,\n        \"message_body\": parse_message_body,\n        \"uuid_URI\": parse_uuid_URI,\n        \"uuid\": parse_uuid,\n        \"hex4\": parse_hex4,\n        \"hex8\": parse_hex8,\n        \"hex12\": parse_hex12,\n        \"Refer_To\": parse_Refer_To,\n        \"Replaces\": parse_Replaces,\n        \"call_id\": parse_call_id,\n        \"replaces_param\": parse_replaces_param,\n        \"to_tag\": parse_to_tag,\n        \"from_tag\": parse_from_tag,\n        \"early_flag\": parse_early_flag\n      };\n      if (startRule !== undefined) {\n        if (parseFunctions[startRule] === undefined) {\n          throw new Error(\"Invalid rule name: \" + quote(startRule) + \".\");\n        }\n      } else {\n        startRule = \"CRLF\";\n      }\n      var pos = 0;\n      var reportFailures = 0;\n      var rightmostFailuresPos = 0;\n      var rightmostFailuresExpected = [];\n      function padLeft(input, padding, length) {\n        var result = input;\n        var padLength = length - input.length;\n        for (var i = 0; i < padLength; i++) {\n          result = padding + result;\n        }\n        return result;\n      }\n      function escape(ch) {\n        var charCode = ch.charCodeAt(0);\n        var escapeChar;\n        var length;\n        if (charCode <= 0xFF) {\n          escapeChar = 'x';\n          length = 2;\n        } else {\n          escapeChar = 'u';\n          length = 4;\n        }\n        return '\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);\n      }\n      function matchFailed(failure) {\n        if (pos < rightmostFailuresPos) {\n          return;\n        }\n        if (pos > rightmostFailuresPos) {\n          rightmostFailuresPos = pos;\n          rightmostFailuresExpected = [];\n        }\n        rightmostFailuresExpected.push(failure);\n      }\n      function parse_CRLF() {\n        var result0;\n        if (input.substr(pos, 2) === \"\\r\\n\") {\n          result0 = \"\\r\\n\";\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"\\\\r\\\\n\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_DIGIT() {\n        var result0;\n        if (/^[0-9]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[0-9]\");\n          }\n        }\n        return result0;\n      }\n      function parse_ALPHA() {\n        var result0;\n        if (/^[a-zA-Z]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[a-zA-Z]\");\n          }\n        }\n        return result0;\n      }\n      function parse_HEXDIG() {\n        var result0;\n        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[0-9a-fA-F]\");\n          }\n        }\n        return result0;\n      }\n      function parse_WSP() {\n        var result0;\n        result0 = parse_SP();\n        if (result0 === null) {\n          result0 = parse_HTAB();\n        }\n        return result0;\n      }\n      function parse_OCTET() {\n        var result0;\n        if (/^[\\0-\\xFF]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[\\\\0-\\\\xFF]\");\n          }\n        }\n        return result0;\n      }\n      function parse_DQUOTE() {\n        var result0;\n        if (/^[\"]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[\\\"]\");\n          }\n        }\n        return result0;\n      }\n      function parse_SP() {\n        var result0;\n        if (input.charCodeAt(pos) === 32) {\n          result0 = \" \";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\" \\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_HTAB() {\n        var result0;\n        if (input.charCodeAt(pos) === 9) {\n          result0 = \"\\t\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"\\\\t\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_alphanum() {\n        var result0;\n        if (/^[a-zA-Z0-9]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[a-zA-Z0-9]\");\n          }\n        }\n        return result0;\n      }\n      function parse_reserved() {\n        var result0;\n        if (input.charCodeAt(pos) === 59) {\n          result0 = \";\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\";\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 47) {\n            result0 = \"/\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"/\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 63) {\n              result0 = \"?\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"?\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 58) {\n                result0 = \":\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\":\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 64) {\n                  result0 = \"@\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"@\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 38) {\n                    result0 = \"&\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"&\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 61) {\n                      result0 = \"=\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"=\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 43) {\n                        result0 = \"+\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"+\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 36) {\n                          result0 = \"$\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"$\\\"\");\n                          }\n                        }\n                        if (result0 === null) {\n                          if (input.charCodeAt(pos) === 44) {\n                            result0 = \",\";\n                            pos++;\n                          } else {\n                            result0 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\",\\\"\");\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_unreserved() {\n        var result0;\n        result0 = parse_alphanum();\n        if (result0 === null) {\n          result0 = parse_mark();\n        }\n        return result0;\n      }\n      function parse_mark() {\n        var result0;\n        if (input.charCodeAt(pos) === 45) {\n          result0 = \"-\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"-\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 95) {\n            result0 = \"_\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"_\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 46) {\n              result0 = \".\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 33) {\n                result0 = \"!\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"!\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 126) {\n                  result0 = \"~\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"~\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 42) {\n                    result0 = \"*\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"*\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 39) {\n                      result0 = \"'\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"'\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 40) {\n                        result0 = \"(\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"(\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 41) {\n                          result0 = \")\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\")\\\"\");\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_escaped() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 37) {\n          result0 = \"%\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"%\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_HEXDIG();\n          if (result1 !== null) {\n            result2 = parse_HEXDIG();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, escaped) {return escaped.join(''); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_LWS() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        pos2 = pos;\n        result0 = [];\n        result1 = parse_WSP();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_WSP();\n        }\n        if (result0 !== null) {\n          result1 = parse_CRLF();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos2;\n          }\n        } else {\n          result0 = null;\n          pos = pos2;\n        }\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result2 = parse_WSP();\n          if (result2 !== null) {\n            result1 = [];\n            while (result2 !== null) {\n              result1.push(result2);\n              result2 = parse_WSP();\n            }\n          } else {\n            result1 = null;\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return \" \"; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SWS() {\n        var result0;\n        result0 = parse_LWS();\n        result0 = result0 !== null ? result0 : \"\";\n        return result0;\n      }\n      function parse_HCOLON() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = [];\n        result1 = parse_SP();\n        if (result1 === null) {\n          result1 = parse_HTAB();\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_SP();\n          if (result1 === null) {\n            result1 = parse_HTAB();\n          }\n        }\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return ':'; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_TEXT_UTF8_TRIM() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result1 = parse_TEXT_UTF8char();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_TEXT_UTF8char();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = [];\n          result3 = parse_LWS();\n          while (result3 !== null) {\n            result2.push(result3);\n            result3 = parse_LWS();\n          }\n          if (result2 !== null) {\n            result3 = parse_TEXT_UTF8char();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = [];\n            result3 = parse_LWS();\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_LWS();\n            }\n            if (result2 !== null) {\n              result3 = parse_TEXT_UTF8char();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                            return input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_TEXT_UTF8char() {\n        var result0;\n        if (/^[!-~]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[!-~]\");\n          }\n        }\n        if (result0 === null) {\n          result0 = parse_UTF8_NONASCII();\n        }\n        return result0;\n      }\n      function parse_UTF8_NONASCII() {\n        var result0;\n        if (/^[\\x80-\\uFFFF]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[\\\\x80-\\\\uFFFF]\");\n          }\n        }\n        return result0;\n      }\n      function parse_UTF8_CONT() {\n        var result0;\n        if (/^[\\x80-\\xBF]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[\\\\x80-\\\\xBF]\");\n          }\n        }\n        return result0;\n      }\n      function parse_LHEX() {\n        var result0;\n        result0 = parse_DIGIT();\n        if (result0 === null) {\n          if (/^[a-f]/.test(input.charAt(pos))) {\n            result0 = input.charAt(pos);\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[a-f]\");\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_token() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_alphanum();\n        if (result1 === null) {\n          if (input.charCodeAt(pos) === 45) {\n            result1 = \"-\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"-\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 46) {\n              result1 = \".\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 33) {\n                result1 = \"!\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"!\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 37) {\n                  result1 = \"%\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"%\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 42) {\n                    result1 = \"*\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"*\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 95) {\n                      result1 = \"_\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"_\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 43) {\n                        result1 = \"+\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"+\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 96) {\n                          result1 = \"`\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"`\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 39) {\n                            result1 = \"'\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"'\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 126) {\n                              result1 = \"~\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"~\\\"\");\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_alphanum();\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result1 = \"-\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 46) {\n                  result1 = \".\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\".\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 33) {\n                    result1 = \"!\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"!\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 37) {\n                      result1 = \"%\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"%\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 42) {\n                        result1 = \"*\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"*\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 95) {\n                          result1 = \"_\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"_\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 43) {\n                            result1 = \"+\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"+\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 96) {\n                              result1 = \"`\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"`\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 39) {\n                                result1 = \"'\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"'\\\"\");\n                                }\n                              }\n                              if (result1 === null) {\n                                if (input.charCodeAt(pos) === 126) {\n                                  result1 = \"~\";\n                                  pos++;\n                                } else {\n                                  result1 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\"~\\\"\");\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                          return input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_token_nodot() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_alphanum();\n        if (result1 === null) {\n          if (input.charCodeAt(pos) === 45) {\n            result1 = \"-\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"-\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 33) {\n              result1 = \"!\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"!\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 37) {\n                result1 = \"%\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"%\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 42) {\n                  result1 = \"*\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"*\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 95) {\n                    result1 = \"_\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"_\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 43) {\n                      result1 = \"+\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"+\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 96) {\n                        result1 = \"`\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"`\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 39) {\n                          result1 = \"'\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"'\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 126) {\n                            result1 = \"~\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"~\\\"\");\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_alphanum();\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result1 = \"-\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 33) {\n                  result1 = \"!\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"!\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 37) {\n                    result1 = \"%\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"%\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 42) {\n                      result1 = \"*\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"*\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 95) {\n                        result1 = \"_\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"_\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 43) {\n                          result1 = \"+\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"+\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 96) {\n                            result1 = \"`\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"`\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 39) {\n                              result1 = \"'\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"'\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 126) {\n                                result1 = \"~\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"~\\\"\");\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                          return input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_separators() {\n        var result0;\n        if (input.charCodeAt(pos) === 40) {\n          result0 = \"(\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"(\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 41) {\n            result0 = \")\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\")\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 60) {\n              result0 = \"<\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"<\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 62) {\n                result0 = \">\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\">\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 64) {\n                  result0 = \"@\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"@\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 44) {\n                    result0 = \",\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\",\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 59) {\n                      result0 = \";\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\";\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result0 = \":\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 92) {\n                          result0 = \"\\\\\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"\\\\\\\\\\\"\");\n                          }\n                        }\n                        if (result0 === null) {\n                          result0 = parse_DQUOTE();\n                          if (result0 === null) {\n                            if (input.charCodeAt(pos) === 47) {\n                              result0 = \"/\";\n                              pos++;\n                            } else {\n                              result0 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"/\\\"\");\n                              }\n                            }\n                            if (result0 === null) {\n                              if (input.charCodeAt(pos) === 91) {\n                                result0 = \"[\";\n                                pos++;\n                              } else {\n                                result0 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"[\\\"\");\n                                }\n                              }\n                              if (result0 === null) {\n                                if (input.charCodeAt(pos) === 93) {\n                                  result0 = \"]\";\n                                  pos++;\n                                } else {\n                                  result0 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\"]\\\"\");\n                                  }\n                                }\n                                if (result0 === null) {\n                                  if (input.charCodeAt(pos) === 63) {\n                                    result0 = \"?\";\n                                    pos++;\n                                  } else {\n                                    result0 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\"?\\\"\");\n                                    }\n                                  }\n                                  if (result0 === null) {\n                                    if (input.charCodeAt(pos) === 61) {\n                                      result0 = \"=\";\n                                      pos++;\n                                    } else {\n                                      result0 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\"=\\\"\");\n                                      }\n                                    }\n                                    if (result0 === null) {\n                                      if (input.charCodeAt(pos) === 123) {\n                                        result0 = \"{\";\n                                        pos++;\n                                      } else {\n                                        result0 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\"{\\\"\");\n                                        }\n                                      }\n                                      if (result0 === null) {\n                                        if (input.charCodeAt(pos) === 125) {\n                                          result0 = \"}\";\n                                          pos++;\n                                        } else {\n                                          result0 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\"}\\\"\");\n                                          }\n                                        }\n                                        if (result0 === null) {\n                                          result0 = parse_SP();\n                                          if (result0 === null) {\n                                            result0 = parse_HTAB();\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_word() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_alphanum();\n        if (result1 === null) {\n          if (input.charCodeAt(pos) === 45) {\n            result1 = \"-\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"-\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 46) {\n              result1 = \".\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 33) {\n                result1 = \"!\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"!\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 37) {\n                  result1 = \"%\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"%\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 42) {\n                    result1 = \"*\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"*\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 95) {\n                      result1 = \"_\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"_\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 43) {\n                        result1 = \"+\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"+\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 96) {\n                          result1 = \"`\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"`\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 39) {\n                            result1 = \"'\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"'\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 126) {\n                              result1 = \"~\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"~\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 40) {\n                                result1 = \"(\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"(\\\"\");\n                                }\n                              }\n                              if (result1 === null) {\n                                if (input.charCodeAt(pos) === 41) {\n                                  result1 = \")\";\n                                  pos++;\n                                } else {\n                                  result1 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\")\\\"\");\n                                  }\n                                }\n                                if (result1 === null) {\n                                  if (input.charCodeAt(pos) === 60) {\n                                    result1 = \"<\";\n                                    pos++;\n                                  } else {\n                                    result1 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\"<\\\"\");\n                                    }\n                                  }\n                                  if (result1 === null) {\n                                    if (input.charCodeAt(pos) === 62) {\n                                      result1 = \">\";\n                                      pos++;\n                                    } else {\n                                      result1 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\">\\\"\");\n                                      }\n                                    }\n                                    if (result1 === null) {\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result1 = \":\";\n                                        pos++;\n                                      } else {\n                                        result1 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result1 === null) {\n                                        if (input.charCodeAt(pos) === 92) {\n                                          result1 = \"\\\\\";\n                                          pos++;\n                                        } else {\n                                          result1 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\"\\\\\\\\\\\"\");\n                                          }\n                                        }\n                                        if (result1 === null) {\n                                          result1 = parse_DQUOTE();\n                                          if (result1 === null) {\n                                            if (input.charCodeAt(pos) === 47) {\n                                              result1 = \"/\";\n                                              pos++;\n                                            } else {\n                                              result1 = null;\n                                              if (reportFailures === 0) {\n                                                matchFailed(\"\\\"/\\\"\");\n                                              }\n                                            }\n                                            if (result1 === null) {\n                                              if (input.charCodeAt(pos) === 91) {\n                                                result1 = \"[\";\n                                                pos++;\n                                              } else {\n                                                result1 = null;\n                                                if (reportFailures === 0) {\n                                                  matchFailed(\"\\\"[\\\"\");\n                                                }\n                                              }\n                                              if (result1 === null) {\n                                                if (input.charCodeAt(pos) === 93) {\n                                                  result1 = \"]\";\n                                                  pos++;\n                                                } else {\n                                                  result1 = null;\n                                                  if (reportFailures === 0) {\n                                                    matchFailed(\"\\\"]\\\"\");\n                                                  }\n                                                }\n                                                if (result1 === null) {\n                                                  if (input.charCodeAt(pos) === 63) {\n                                                    result1 = \"?\";\n                                                    pos++;\n                                                  } else {\n                                                    result1 = null;\n                                                    if (reportFailures === 0) {\n                                                      matchFailed(\"\\\"?\\\"\");\n                                                    }\n                                                  }\n                                                  if (result1 === null) {\n                                                    if (input.charCodeAt(pos) === 123) {\n                                                      result1 = \"{\";\n                                                      pos++;\n                                                    } else {\n                                                      result1 = null;\n                                                      if (reportFailures === 0) {\n                                                        matchFailed(\"\\\"{\\\"\");\n                                                      }\n                                                    }\n                                                    if (result1 === null) {\n                                                      if (input.charCodeAt(pos) === 125) {\n                                                        result1 = \"}\";\n                                                        pos++;\n                                                      } else {\n                                                        result1 = null;\n                                                        if (reportFailures === 0) {\n                                                          matchFailed(\"\\\"}\\\"\");\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_alphanum();\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result1 = \"-\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 46) {\n                  result1 = \".\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\".\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 33) {\n                    result1 = \"!\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"!\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 37) {\n                      result1 = \"%\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"%\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 42) {\n                        result1 = \"*\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"*\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 95) {\n                          result1 = \"_\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"_\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 43) {\n                            result1 = \"+\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"+\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 96) {\n                              result1 = \"`\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"`\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 39) {\n                                result1 = \"'\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"'\\\"\");\n                                }\n                              }\n                              if (result1 === null) {\n                                if (input.charCodeAt(pos) === 126) {\n                                  result1 = \"~\";\n                                  pos++;\n                                } else {\n                                  result1 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\"~\\\"\");\n                                  }\n                                }\n                                if (result1 === null) {\n                                  if (input.charCodeAt(pos) === 40) {\n                                    result1 = \"(\";\n                                    pos++;\n                                  } else {\n                                    result1 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\"(\\\"\");\n                                    }\n                                  }\n                                  if (result1 === null) {\n                                    if (input.charCodeAt(pos) === 41) {\n                                      result1 = \")\";\n                                      pos++;\n                                    } else {\n                                      result1 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\")\\\"\");\n                                      }\n                                    }\n                                    if (result1 === null) {\n                                      if (input.charCodeAt(pos) === 60) {\n                                        result1 = \"<\";\n                                        pos++;\n                                      } else {\n                                        result1 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\"<\\\"\");\n                                        }\n                                      }\n                                      if (result1 === null) {\n                                        if (input.charCodeAt(pos) === 62) {\n                                          result1 = \">\";\n                                          pos++;\n                                        } else {\n                                          result1 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\">\\\"\");\n                                          }\n                                        }\n                                        if (result1 === null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result1 = \":\";\n                                            pos++;\n                                          } else {\n                                            result1 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result1 === null) {\n                                            if (input.charCodeAt(pos) === 92) {\n                                              result1 = \"\\\\\";\n                                              pos++;\n                                            } else {\n                                              result1 = null;\n                                              if (reportFailures === 0) {\n                                                matchFailed(\"\\\"\\\\\\\\\\\"\");\n                                              }\n                                            }\n                                            if (result1 === null) {\n                                              result1 = parse_DQUOTE();\n                                              if (result1 === null) {\n                                                if (input.charCodeAt(pos) === 47) {\n                                                  result1 = \"/\";\n                                                  pos++;\n                                                } else {\n                                                  result1 = null;\n                                                  if (reportFailures === 0) {\n                                                    matchFailed(\"\\\"/\\\"\");\n                                                  }\n                                                }\n                                                if (result1 === null) {\n                                                  if (input.charCodeAt(pos) === 91) {\n                                                    result1 = \"[\";\n                                                    pos++;\n                                                  } else {\n                                                    result1 = null;\n                                                    if (reportFailures === 0) {\n                                                      matchFailed(\"\\\"[\\\"\");\n                                                    }\n                                                  }\n                                                  if (result1 === null) {\n                                                    if (input.charCodeAt(pos) === 93) {\n                                                      result1 = \"]\";\n                                                      pos++;\n                                                    } else {\n                                                      result1 = null;\n                                                      if (reportFailures === 0) {\n                                                        matchFailed(\"\\\"]\\\"\");\n                                                      }\n                                                    }\n                                                    if (result1 === null) {\n                                                      if (input.charCodeAt(pos) === 63) {\n                                                        result1 = \"?\";\n                                                        pos++;\n                                                      } else {\n                                                        result1 = null;\n                                                        if (reportFailures === 0) {\n                                                          matchFailed(\"\\\"?\\\"\");\n                                                        }\n                                                      }\n                                                      if (result1 === null) {\n                                                        if (input.charCodeAt(pos) === 123) {\n                                                          result1 = \"{\";\n                                                          pos++;\n                                                        } else {\n                                                          result1 = null;\n                                                          if (reportFailures === 0) {\n                                                            matchFailed(\"\\\"{\\\"\");\n                                                          }\n                                                        }\n                                                        if (result1 === null) {\n                                                          if (input.charCodeAt(pos) === 125) {\n                                                            result1 = \"}\";\n                                                            pos++;\n                                                          } else {\n                                                            result1 = null;\n                                                            if (reportFailures === 0) {\n                                                              matchFailed(\"\\\"}\\\"\");\n                                                            }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                          return input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_STAR() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 42) {\n            result1 = \"*\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"*\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return \"*\"; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SLASH() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 47) {\n            result1 = \"/\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"/\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return \"/\"; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_EQUAL() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 61) {\n            result1 = \"=\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return \"=\"; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_LPAREN() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 40) {\n            result1 = \"(\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"(\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return \"(\"; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_RPAREN() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 41) {\n            result1 = \")\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\")\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return \")\"; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_RAQUOT() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 62) {\n          result0 = \">\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\">\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_SWS();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return \">\"; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_LAQUOT() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 60) {\n            result1 = \"<\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"<\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return \"<\"; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_COMMA() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 44) {\n            result1 = \",\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\",\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return \",\"; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SEMI() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 59) {\n            result1 = \";\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\";\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return \";\"; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_COLON() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return \":\"; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_LDQUOT() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          result1 = parse_DQUOTE();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return \"\\\"\"; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_RDQUOT() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_DQUOTE();\n        if (result0 !== null) {\n          result1 = parse_SWS();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {return \"\\\"\"; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_comment() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_LPAREN();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_ctext();\n          if (result2 === null) {\n            result2 = parse_quoted_pair();\n            if (result2 === null) {\n              result2 = parse_comment();\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_ctext();\n            if (result2 === null) {\n              result2 = parse_quoted_pair();\n              if (result2 === null) {\n                result2 = parse_comment();\n              }\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_RPAREN();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_ctext() {\n        var result0;\n        if (/^[!-']/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[!-']\");\n          }\n        }\n        if (result0 === null) {\n          if (/^[*-[]/.test(input.charAt(pos))) {\n            result0 = input.charAt(pos);\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[*-[]\");\n            }\n          }\n          if (result0 === null) {\n            if (/^[\\]-~]/.test(input.charAt(pos))) {\n              result0 = input.charAt(pos);\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[\\\\]-~]\");\n              }\n            }\n            if (result0 === null) {\n              result0 = parse_UTF8_NONASCII();\n              if (result0 === null) {\n                result0 = parse_LWS();\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_quoted_string() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          result1 = parse_DQUOTE();\n          if (result1 !== null) {\n            result2 = [];\n            result3 = parse_qdtext();\n            if (result3 === null) {\n              result3 = parse_quoted_pair();\n            }\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_qdtext();\n              if (result3 === null) {\n                result3 = parse_quoted_pair();\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_DQUOTE();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                          return input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_quoted_string_clean() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          result1 = parse_DQUOTE();\n          if (result1 !== null) {\n            result2 = [];\n            result3 = parse_qdtext();\n            if (result3 === null) {\n              result3 = parse_quoted_pair();\n            }\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_qdtext();\n              if (result3 === null) {\n                result3 = parse_quoted_pair();\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_DQUOTE();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                          var trimmed = input\n                              .substring(pos, offset)\n                              .trim();\n                          return trimmed\n                              .substring(1, trimmed.length - 1) // remove outer quotes\n                              .replace(/\\\\([\\x00-\\x09\\x0b-\\x0c\\x0e-\\x7f])/g, '$1'); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_qdtext() {\n        var result0;\n        result0 = parse_LWS();\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 33) {\n            result0 = \"!\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"!\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (/^[#-[]/.test(input.charAt(pos))) {\n              result0 = input.charAt(pos);\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[#-[]\");\n              }\n            }\n            if (result0 === null) {\n              if (/^[\\]-~]/.test(input.charAt(pos))) {\n                result0 = input.charAt(pos);\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"[\\\\]-~]\");\n                }\n              }\n              if (result0 === null) {\n                result0 = parse_UTF8_NONASCII();\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_quoted_pair() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        if (input.charCodeAt(pos) === 92) {\n          result0 = \"\\\\\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"\\\\\\\\\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (/^[\\0-\\t]/.test(input.charAt(pos))) {\n            result1 = input.charAt(pos);\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[\\\\0-\\\\t]\");\n            }\n          }\n          if (result1 === null) {\n            if (/^[\\x0B-\\f]/.test(input.charAt(pos))) {\n              result1 = input.charAt(pos);\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[\\\\x0B-\\\\f]\");\n              }\n            }\n            if (result1 === null) {\n              if (/^[\\x0E-]/.test(input.charAt(pos))) {\n                result1 = input.charAt(pos);\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"[\\\\x0E-]\");\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SIP_URI_noparams() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_uri_scheme();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_userinfo();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_hostport();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                            try {\n                                data.uri = new URI(data.scheme, data.user, data.host, data.port);\n                                delete data.scheme;\n                                delete data.user;\n                                delete data.host;\n                                delete data.host_type;\n                                delete data.port;\n                              } catch(e) {\n                                data = -1;\n                              }})(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SIP_URI() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_uri_scheme();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_userinfo();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_hostport();\n              if (result3 !== null) {\n                result4 = parse_uri_parameters();\n                if (result4 !== null) {\n                  result5 = parse_headers();\n                  result5 = result5 !== null ? result5 : \"\";\n                  if (result5 !== null) {\n                    result0 = [result0, result1, result2, result3, result4, result5];\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                            var header;\n                            try {\n                                data.uri = new URI(data.scheme, data.user, data.host, data.port, data.uri_params, data.uri_headers);\n                                delete data.scheme;\n                                delete data.user;\n                                delete data.host;\n                                delete data.host_type;\n                                delete data.port;\n                                delete data.uri_params;\n                                if (startRule === 'SIP_URI') { data = data.uri;}\n                              } catch(e) {\n                                data = -1;\n                              }})(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uri_scheme() {\n        var result0;\n        result0 = parse_uri_scheme_sips();\n        if (result0 === null) {\n          result0 = parse_uri_scheme_sip();\n        }\n        return result0;\n      }\n      function parse_uri_scheme_sips() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 4).toLowerCase() === \"sips\") {\n          result0 = input.substr(pos, 4);\n          pos += 4;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"sips\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, scheme) {\n                            data.scheme = scheme.toLowerCase(); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uri_scheme_sip() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"sip\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"sip\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, scheme) {\n                            data.scheme = scheme.toLowerCase(); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_userinfo() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_user();\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_password();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            if (input.charCodeAt(pos) === 64) {\n              result2 = \"@\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"@\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                            data.user = decodeURIComponent(input.substring(pos-1, offset));})(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_user() {\n        var result0, result1;\n        result1 = parse_unreserved();\n        if (result1 === null) {\n          result1 = parse_escaped();\n          if (result1 === null) {\n            result1 = parse_user_unreserved();\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_unreserved();\n            if (result1 === null) {\n              result1 = parse_escaped();\n              if (result1 === null) {\n                result1 = parse_user_unreserved();\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        return result0;\n      }\n      function parse_user_unreserved() {\n        var result0;\n        if (input.charCodeAt(pos) === 38) {\n          result0 = \"&\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"&\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 61) {\n            result0 = \"=\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 43) {\n              result0 = \"+\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"+\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 36) {\n                result0 = \"$\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"$\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 44) {\n                  result0 = \",\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\",\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 59) {\n                    result0 = \";\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\";\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 63) {\n                      result0 = \"?\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"?\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 47) {\n                        result0 = \"/\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"/\\\"\");\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_password() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result0 = [];\n        result1 = parse_unreserved();\n        if (result1 === null) {\n          result1 = parse_escaped();\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 38) {\n              result1 = \"&\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"&\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 61) {\n                result1 = \"=\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"=\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 43) {\n                  result1 = \"+\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"+\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 36) {\n                    result1 = \"$\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"$\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 44) {\n                      result1 = \",\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\",\\\"\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_unreserved();\n          if (result1 === null) {\n            result1 = parse_escaped();\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 38) {\n                result1 = \"&\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"&\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 61) {\n                  result1 = \"=\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"=\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 43) {\n                    result1 = \"+\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"+\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 36) {\n                      result1 = \"$\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"$\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 44) {\n                        result1 = \",\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\",\\\"\");\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                            data.password = input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hostport() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_host();\n        if (result0 !== null) {\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_port();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos1;\n            }\n          } else {\n            result1 = null;\n            pos = pos1;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_host() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_hostname();\n        if (result0 === null) {\n          result0 = parse_IPv4address();\n          if (result0 === null) {\n            result0 = parse_IPv6reference();\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                            data.host = input.substring(pos, offset).toLowerCase();\n                            return data.host; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hostname() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = [];\n        pos2 = pos;\n        result1 = parse_domainlabel();\n        if (result1 !== null) {\n          if (input.charCodeAt(pos) === 46) {\n            result2 = \".\";\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          if (result2 !== null) {\n            result1 = [result1, result2];\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n        } else {\n          result1 = null;\n          pos = pos2;\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          pos2 = pos;\n          result1 = parse_domainlabel();\n          if (result1 !== null) {\n            if (input.charCodeAt(pos) === 46) {\n              result2 = \".\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_toplabel();\n          if (result1 !== null) {\n            if (input.charCodeAt(pos) === 46) {\n              result2 = \".\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                          data.host_type = 'domain';\n                          return input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_domainlabel() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_alphanum();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_alphanum();\n          if (result2 === null) {\n            if (input.charCodeAt(pos) === 45) {\n              result2 = \"-\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"-\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 95) {\n                result2 = \"_\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"_\\\"\");\n                }\n              }\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_alphanum();\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result2 = \"-\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result2 === null) {\n                if (input.charCodeAt(pos) === 95) {\n                  result2 = \"_\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"_\\\"\");\n                  }\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_toplabel() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_ALPHA();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_alphanum();\n          if (result2 === null) {\n            if (input.charCodeAt(pos) === 45) {\n              result2 = \"-\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"-\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 95) {\n                result2 = \"_\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"_\\\"\");\n                }\n              }\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_alphanum();\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result2 = \"-\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result2 === null) {\n                if (input.charCodeAt(pos) === 95) {\n                  result2 = \"_\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"_\\\"\");\n                  }\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_IPv6reference() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 91) {\n          result0 = \"[\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"[\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_IPv6address();\n          if (result1 !== null) {\n            if (input.charCodeAt(pos) === 93) {\n              result2 = \"]\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"]\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                            data.host_type = 'IPv6';\n                            return input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_IPv6address() {\n        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_h16();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_h16();\n            if (result2 !== null) {\n              if (input.charCodeAt(pos) === 58) {\n                result3 = \":\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\":\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result4 = parse_h16();\n                if (result4 !== null) {\n                  if (input.charCodeAt(pos) === 58) {\n                    result5 = \":\";\n                    pos++;\n                  } else {\n                    result5 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\":\\\"\");\n                    }\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_h16();\n                    if (result6 !== null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result7 = \":\";\n                        pos++;\n                      } else {\n                        result7 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result7 !== null) {\n                        result8 = parse_h16();\n                        if (result8 !== null) {\n                          if (input.charCodeAt(pos) === 58) {\n                            result9 = \":\";\n                            pos++;\n                          } else {\n                            result9 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\":\\\"\");\n                            }\n                          }\n                          if (result9 !== null) {\n                            result10 = parse_h16();\n                            if (result10 !== null) {\n                              if (input.charCodeAt(pos) === 58) {\n                                result11 = \":\";\n                                pos++;\n                              } else {\n                                result11 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\":\\\"\");\n                                }\n                              }\n                              if (result11 !== null) {\n                                result12 = parse_ls32();\n                                if (result12 !== null) {\n                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12];\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 === null) {\n          pos1 = pos;\n          if (input.substr(pos, 2) === \"::\") {\n            result0 = \"::\";\n            pos += 2;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"::\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            result1 = parse_h16();\n            if (result1 !== null) {\n              if (input.charCodeAt(pos) === 58) {\n                result2 = \":\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\":\\\"\");\n                }\n              }\n              if (result2 !== null) {\n                result3 = parse_h16();\n                if (result3 !== null) {\n                  if (input.charCodeAt(pos) === 58) {\n                    result4 = \":\";\n                    pos++;\n                  } else {\n                    result4 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\":\\\"\");\n                    }\n                  }\n                  if (result4 !== null) {\n                    result5 = parse_h16();\n                    if (result5 !== null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result6 = \":\";\n                        pos++;\n                      } else {\n                        result6 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result6 !== null) {\n                        result7 = parse_h16();\n                        if (result7 !== null) {\n                          if (input.charCodeAt(pos) === 58) {\n                            result8 = \":\";\n                            pos++;\n                          } else {\n                            result8 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\":\\\"\");\n                            }\n                          }\n                          if (result8 !== null) {\n                            result9 = parse_h16();\n                            if (result9 !== null) {\n                              if (input.charCodeAt(pos) === 58) {\n                                result10 = \":\";\n                                pos++;\n                              } else {\n                                result10 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\":\\\"\");\n                                }\n                              }\n                              if (result10 !== null) {\n                                result11 = parse_ls32();\n                                if (result11 !== null) {\n                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11];\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 === null) {\n            pos1 = pos;\n            if (input.substr(pos, 2) === \"::\") {\n              result0 = \"::\";\n              pos += 2;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"::\\\"\");\n              }\n            }\n            if (result0 !== null) {\n              result1 = parse_h16();\n              if (result1 !== null) {\n                if (input.charCodeAt(pos) === 58) {\n                  result2 = \":\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\":\\\"\");\n                  }\n                }\n                if (result2 !== null) {\n                  result3 = parse_h16();\n                  if (result3 !== null) {\n                    if (input.charCodeAt(pos) === 58) {\n                      result4 = \":\";\n                      pos++;\n                    } else {\n                      result4 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\":\\\"\");\n                      }\n                    }\n                    if (result4 !== null) {\n                      result5 = parse_h16();\n                      if (result5 !== null) {\n                        if (input.charCodeAt(pos) === 58) {\n                          result6 = \":\";\n                          pos++;\n                        } else {\n                          result6 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\":\\\"\");\n                          }\n                        }\n                        if (result6 !== null) {\n                          result7 = parse_h16();\n                          if (result7 !== null) {\n                            if (input.charCodeAt(pos) === 58) {\n                              result8 = \":\";\n                              pos++;\n                            } else {\n                              result8 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\":\\\"\");\n                              }\n                            }\n                            if (result8 !== null) {\n                              result9 = parse_ls32();\n                              if (result9 !== null) {\n                                result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n            if (result0 === null) {\n              pos1 = pos;\n              if (input.substr(pos, 2) === \"::\") {\n                result0 = \"::\";\n                pos += 2;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"::\\\"\");\n                }\n              }\n              if (result0 !== null) {\n                result1 = parse_h16();\n                if (result1 !== null) {\n                  if (input.charCodeAt(pos) === 58) {\n                    result2 = \":\";\n                    pos++;\n                  } else {\n                    result2 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\":\\\"\");\n                    }\n                  }\n                  if (result2 !== null) {\n                    result3 = parse_h16();\n                    if (result3 !== null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result4 = \":\";\n                        pos++;\n                      } else {\n                        result4 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result4 !== null) {\n                        result5 = parse_h16();\n                        if (result5 !== null) {\n                          if (input.charCodeAt(pos) === 58) {\n                            result6 = \":\";\n                            pos++;\n                          } else {\n                            result6 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\":\\\"\");\n                            }\n                          }\n                          if (result6 !== null) {\n                            result7 = parse_ls32();\n                            if (result7 !== null) {\n                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n              if (result0 === null) {\n                pos1 = pos;\n                if (input.substr(pos, 2) === \"::\") {\n                  result0 = \"::\";\n                  pos += 2;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"::\\\"\");\n                  }\n                }\n                if (result0 !== null) {\n                  result1 = parse_h16();\n                  if (result1 !== null) {\n                    if (input.charCodeAt(pos) === 58) {\n                      result2 = \":\";\n                      pos++;\n                    } else {\n                      result2 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\":\\\"\");\n                      }\n                    }\n                    if (result2 !== null) {\n                      result3 = parse_h16();\n                      if (result3 !== null) {\n                        if (input.charCodeAt(pos) === 58) {\n                          result4 = \":\";\n                          pos++;\n                        } else {\n                          result4 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\":\\\"\");\n                          }\n                        }\n                        if (result4 !== null) {\n                          result5 = parse_ls32();\n                          if (result5 !== null) {\n                            result0 = [result0, result1, result2, result3, result4, result5];\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n                if (result0 === null) {\n                  pos1 = pos;\n                  if (input.substr(pos, 2) === \"::\") {\n                    result0 = \"::\";\n                    pos += 2;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"::\\\"\");\n                    }\n                  }\n                  if (result0 !== null) {\n                    result1 = parse_h16();\n                    if (result1 !== null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result2 = \":\";\n                        pos++;\n                      } else {\n                        result2 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result2 !== null) {\n                        result3 = parse_ls32();\n                        if (result3 !== null) {\n                          result0 = [result0, result1, result2, result3];\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                  if (result0 === null) {\n                    pos1 = pos;\n                    if (input.substr(pos, 2) === \"::\") {\n                      result0 = \"::\";\n                      pos += 2;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"::\\\"\");\n                      }\n                    }\n                    if (result0 !== null) {\n                      result1 = parse_ls32();\n                      if (result1 !== null) {\n                        result0 = [result0, result1];\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                    if (result0 === null) {\n                      pos1 = pos;\n                      if (input.substr(pos, 2) === \"::\") {\n                        result0 = \"::\";\n                        pos += 2;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"::\\\"\");\n                        }\n                      }\n                      if (result0 !== null) {\n                        result1 = parse_h16();\n                        if (result1 !== null) {\n                          result0 = [result0, result1];\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                      if (result0 === null) {\n                        pos1 = pos;\n                        result0 = parse_h16();\n                        if (result0 !== null) {\n                          if (input.substr(pos, 2) === \"::\") {\n                            result1 = \"::\";\n                            pos += 2;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"::\\\"\");\n                            }\n                          }\n                          if (result1 !== null) {\n                            result2 = parse_h16();\n                            if (result2 !== null) {\n                              if (input.charCodeAt(pos) === 58) {\n                                result3 = \":\";\n                                pos++;\n                              } else {\n                                result3 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\":\\\"\");\n                                }\n                              }\n                              if (result3 !== null) {\n                                result4 = parse_h16();\n                                if (result4 !== null) {\n                                  if (input.charCodeAt(pos) === 58) {\n                                    result5 = \":\";\n                                    pos++;\n                                  } else {\n                                    result5 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\":\\\"\");\n                                    }\n                                  }\n                                  if (result5 !== null) {\n                                    result6 = parse_h16();\n                                    if (result6 !== null) {\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result7 = \":\";\n                                        pos++;\n                                      } else {\n                                        result7 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result7 !== null) {\n                                        result8 = parse_h16();\n                                        if (result8 !== null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result9 = \":\";\n                                            pos++;\n                                          } else {\n                                            result9 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result9 !== null) {\n                                            result10 = parse_ls32();\n                                            if (result10 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                        if (result0 === null) {\n                          pos1 = pos;\n                          result0 = parse_h16();\n                          if (result0 !== null) {\n                            pos2 = pos;\n                            if (input.charCodeAt(pos) === 58) {\n                              result1 = \":\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\":\\\"\");\n                              }\n                            }\n                            if (result1 !== null) {\n                              result2 = parse_h16();\n                              if (result2 !== null) {\n                                result1 = [result1, result2];\n                              } else {\n                                result1 = null;\n                                pos = pos2;\n                              }\n                            } else {\n                              result1 = null;\n                              pos = pos2;\n                            }\n                            result1 = result1 !== null ? result1 : \"\";\n                            if (result1 !== null) {\n                              if (input.substr(pos, 2) === \"::\") {\n                                result2 = \"::\";\n                                pos += 2;\n                              } else {\n                                result2 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"::\\\"\");\n                                }\n                              }\n                              if (result2 !== null) {\n                                result3 = parse_h16();\n                                if (result3 !== null) {\n                                  if (input.charCodeAt(pos) === 58) {\n                                    result4 = \":\";\n                                    pos++;\n                                  } else {\n                                    result4 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\":\\\"\");\n                                    }\n                                  }\n                                  if (result4 !== null) {\n                                    result5 = parse_h16();\n                                    if (result5 !== null) {\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result6 = \":\";\n                                        pos++;\n                                      } else {\n                                        result6 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result6 !== null) {\n                                        result7 = parse_h16();\n                                        if (result7 !== null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result8 = \":\";\n                                            pos++;\n                                          } else {\n                                            result8 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result8 !== null) {\n                                            result9 = parse_ls32();\n                                            if (result9 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                          if (result0 === null) {\n                            pos1 = pos;\n                            result0 = parse_h16();\n                            if (result0 !== null) {\n                              pos2 = pos;\n                              if (input.charCodeAt(pos) === 58) {\n                                result1 = \":\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\":\\\"\");\n                                }\n                              }\n                              if (result1 !== null) {\n                                result2 = parse_h16();\n                                if (result2 !== null) {\n                                  result1 = [result1, result2];\n                                } else {\n                                  result1 = null;\n                                  pos = pos2;\n                                }\n                              } else {\n                                result1 = null;\n                                pos = pos2;\n                              }\n                              result1 = result1 !== null ? result1 : \"\";\n                              if (result1 !== null) {\n                                pos2 = pos;\n                                if (input.charCodeAt(pos) === 58) {\n                                  result2 = \":\";\n                                  pos++;\n                                } else {\n                                  result2 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\":\\\"\");\n                                  }\n                                }\n                                if (result2 !== null) {\n                                  result3 = parse_h16();\n                                  if (result3 !== null) {\n                                    result2 = [result2, result3];\n                                  } else {\n                                    result2 = null;\n                                    pos = pos2;\n                                  }\n                                } else {\n                                  result2 = null;\n                                  pos = pos2;\n                                }\n                                result2 = result2 !== null ? result2 : \"\";\n                                if (result2 !== null) {\n                                  if (input.substr(pos, 2) === \"::\") {\n                                    result3 = \"::\";\n                                    pos += 2;\n                                  } else {\n                                    result3 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\"::\\\"\");\n                                    }\n                                  }\n                                  if (result3 !== null) {\n                                    result4 = parse_h16();\n                                    if (result4 !== null) {\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result5 = \":\";\n                                        pos++;\n                                      } else {\n                                        result5 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result5 !== null) {\n                                        result6 = parse_h16();\n                                        if (result6 !== null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result7 = \":\";\n                                            pos++;\n                                          } else {\n                                            result7 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result7 !== null) {\n                                            result8 = parse_ls32();\n                                            if (result8 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                            if (result0 === null) {\n                              pos1 = pos;\n                              result0 = parse_h16();\n                              if (result0 !== null) {\n                                pos2 = pos;\n                                if (input.charCodeAt(pos) === 58) {\n                                  result1 = \":\";\n                                  pos++;\n                                } else {\n                                  result1 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\":\\\"\");\n                                  }\n                                }\n                                if (result1 !== null) {\n                                  result2 = parse_h16();\n                                  if (result2 !== null) {\n                                    result1 = [result1, result2];\n                                  } else {\n                                    result1 = null;\n                                    pos = pos2;\n                                  }\n                                } else {\n                                  result1 = null;\n                                  pos = pos2;\n                                }\n                                result1 = result1 !== null ? result1 : \"\";\n                                if (result1 !== null) {\n                                  pos2 = pos;\n                                  if (input.charCodeAt(pos) === 58) {\n                                    result2 = \":\";\n                                    pos++;\n                                  } else {\n                                    result2 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\":\\\"\");\n                                    }\n                                  }\n                                  if (result2 !== null) {\n                                    result3 = parse_h16();\n                                    if (result3 !== null) {\n                                      result2 = [result2, result3];\n                                    } else {\n                                      result2 = null;\n                                      pos = pos2;\n                                    }\n                                  } else {\n                                    result2 = null;\n                                    pos = pos2;\n                                  }\n                                  result2 = result2 !== null ? result2 : \"\";\n                                  if (result2 !== null) {\n                                    pos2 = pos;\n                                    if (input.charCodeAt(pos) === 58) {\n                                      result3 = \":\";\n                                      pos++;\n                                    } else {\n                                      result3 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\":\\\"\");\n                                      }\n                                    }\n                                    if (result3 !== null) {\n                                      result4 = parse_h16();\n                                      if (result4 !== null) {\n                                        result3 = [result3, result4];\n                                      } else {\n                                        result3 = null;\n                                        pos = pos2;\n                                      }\n                                    } else {\n                                      result3 = null;\n                                      pos = pos2;\n                                    }\n                                    result3 = result3 !== null ? result3 : \"\";\n                                    if (result3 !== null) {\n                                      if (input.substr(pos, 2) === \"::\") {\n                                        result4 = \"::\";\n                                        pos += 2;\n                                      } else {\n                                        result4 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\"::\\\"\");\n                                        }\n                                      }\n                                      if (result4 !== null) {\n                                        result5 = parse_h16();\n                                        if (result5 !== null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result6 = \":\";\n                                            pos++;\n                                          } else {\n                                            result6 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result6 !== null) {\n                                            result7 = parse_ls32();\n                                            if (result7 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                              if (result0 === null) {\n                                pos1 = pos;\n                                result0 = parse_h16();\n                                if (result0 !== null) {\n                                  pos2 = pos;\n                                  if (input.charCodeAt(pos) === 58) {\n                                    result1 = \":\";\n                                    pos++;\n                                  } else {\n                                    result1 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\":\\\"\");\n                                    }\n                                  }\n                                  if (result1 !== null) {\n                                    result2 = parse_h16();\n                                    if (result2 !== null) {\n                                      result1 = [result1, result2];\n                                    } else {\n                                      result1 = null;\n                                      pos = pos2;\n                                    }\n                                  } else {\n                                    result1 = null;\n                                    pos = pos2;\n                                  }\n                                  result1 = result1 !== null ? result1 : \"\";\n                                  if (result1 !== null) {\n                                    pos2 = pos;\n                                    if (input.charCodeAt(pos) === 58) {\n                                      result2 = \":\";\n                                      pos++;\n                                    } else {\n                                      result2 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\":\\\"\");\n                                      }\n                                    }\n                                    if (result2 !== null) {\n                                      result3 = parse_h16();\n                                      if (result3 !== null) {\n                                        result2 = [result2, result3];\n                                      } else {\n                                        result2 = null;\n                                        pos = pos2;\n                                      }\n                                    } else {\n                                      result2 = null;\n                                      pos = pos2;\n                                    }\n                                    result2 = result2 !== null ? result2 : \"\";\n                                    if (result2 !== null) {\n                                      pos2 = pos;\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result3 = \":\";\n                                        pos++;\n                                      } else {\n                                        result3 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result3 !== null) {\n                                        result4 = parse_h16();\n                                        if (result4 !== null) {\n                                          result3 = [result3, result4];\n                                        } else {\n                                          result3 = null;\n                                          pos = pos2;\n                                        }\n                                      } else {\n                                        result3 = null;\n                                        pos = pos2;\n                                      }\n                                      result3 = result3 !== null ? result3 : \"\";\n                                      if (result3 !== null) {\n                                        pos2 = pos;\n                                        if (input.charCodeAt(pos) === 58) {\n                                          result4 = \":\";\n                                          pos++;\n                                        } else {\n                                          result4 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\":\\\"\");\n                                          }\n                                        }\n                                        if (result4 !== null) {\n                                          result5 = parse_h16();\n                                          if (result5 !== null) {\n                                            result4 = [result4, result5];\n                                          } else {\n                                            result4 = null;\n                                            pos = pos2;\n                                          }\n                                        } else {\n                                          result4 = null;\n                                          pos = pos2;\n                                        }\n                                        result4 = result4 !== null ? result4 : \"\";\n                                        if (result4 !== null) {\n                                          if (input.substr(pos, 2) === \"::\") {\n                                            result5 = \"::\";\n                                            pos += 2;\n                                          } else {\n                                            result5 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\"::\\\"\");\n                                            }\n                                          }\n                                          if (result5 !== null) {\n                                            result6 = parse_ls32();\n                                            if (result6 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                                if (result0 === null) {\n                                  pos1 = pos;\n                                  result0 = parse_h16();\n                                  if (result0 !== null) {\n                                    pos2 = pos;\n                                    if (input.charCodeAt(pos) === 58) {\n                                      result1 = \":\";\n                                      pos++;\n                                    } else {\n                                      result1 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\":\\\"\");\n                                      }\n                                    }\n                                    if (result1 !== null) {\n                                      result2 = parse_h16();\n                                      if (result2 !== null) {\n                                        result1 = [result1, result2];\n                                      } else {\n                                        result1 = null;\n                                        pos = pos2;\n                                      }\n                                    } else {\n                                      result1 = null;\n                                      pos = pos2;\n                                    }\n                                    result1 = result1 !== null ? result1 : \"\";\n                                    if (result1 !== null) {\n                                      pos2 = pos;\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result2 = \":\";\n                                        pos++;\n                                      } else {\n                                        result2 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result2 !== null) {\n                                        result3 = parse_h16();\n                                        if (result3 !== null) {\n                                          result2 = [result2, result3];\n                                        } else {\n                                          result2 = null;\n                                          pos = pos2;\n                                        }\n                                      } else {\n                                        result2 = null;\n                                        pos = pos2;\n                                      }\n                                      result2 = result2 !== null ? result2 : \"\";\n                                      if (result2 !== null) {\n                                        pos2 = pos;\n                                        if (input.charCodeAt(pos) === 58) {\n                                          result3 = \":\";\n                                          pos++;\n                                        } else {\n                                          result3 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\":\\\"\");\n                                          }\n                                        }\n                                        if (result3 !== null) {\n                                          result4 = parse_h16();\n                                          if (result4 !== null) {\n                                            result3 = [result3, result4];\n                                          } else {\n                                            result3 = null;\n                                            pos = pos2;\n                                          }\n                                        } else {\n                                          result3 = null;\n                                          pos = pos2;\n                                        }\n                                        result3 = result3 !== null ? result3 : \"\";\n                                        if (result3 !== null) {\n                                          pos2 = pos;\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result4 = \":\";\n                                            pos++;\n                                          } else {\n                                            result4 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result4 !== null) {\n                                            result5 = parse_h16();\n                                            if (result5 !== null) {\n                                              result4 = [result4, result5];\n                                            } else {\n                                              result4 = null;\n                                              pos = pos2;\n                                            }\n                                          } else {\n                                            result4 = null;\n                                            pos = pos2;\n                                          }\n                                          result4 = result4 !== null ? result4 : \"\";\n                                          if (result4 !== null) {\n                                            pos2 = pos;\n                                            if (input.charCodeAt(pos) === 58) {\n                                              result5 = \":\";\n                                              pos++;\n                                            } else {\n                                              result5 = null;\n                                              if (reportFailures === 0) {\n                                                matchFailed(\"\\\":\\\"\");\n                                              }\n                                            }\n                                            if (result5 !== null) {\n                                              result6 = parse_h16();\n                                              if (result6 !== null) {\n                                                result5 = [result5, result6];\n                                              } else {\n                                                result5 = null;\n                                                pos = pos2;\n                                              }\n                                            } else {\n                                              result5 = null;\n                                              pos = pos2;\n                                            }\n                                            result5 = result5 !== null ? result5 : \"\";\n                                            if (result5 !== null) {\n                                              if (input.substr(pos, 2) === \"::\") {\n                                                result6 = \"::\";\n                                                pos += 2;\n                                              } else {\n                                                result6 = null;\n                                                if (reportFailures === 0) {\n                                                  matchFailed(\"\\\"::\\\"\");\n                                                }\n                                              }\n                                              if (result6 !== null) {\n                                                result7 = parse_h16();\n                                                if (result7 !== null) {\n                                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7];\n                                                } else {\n                                                  result0 = null;\n                                                  pos = pos1;\n                                                }\n                                              } else {\n                                                result0 = null;\n                                                pos = pos1;\n                                              }\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                  if (result0 === null) {\n                                    pos1 = pos;\n                                    result0 = parse_h16();\n                                    if (result0 !== null) {\n                                      pos2 = pos;\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result1 = \":\";\n                                        pos++;\n                                      } else {\n                                        result1 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result1 !== null) {\n                                        result2 = parse_h16();\n                                        if (result2 !== null) {\n                                          result1 = [result1, result2];\n                                        } else {\n                                          result1 = null;\n                                          pos = pos2;\n                                        }\n                                      } else {\n                                        result1 = null;\n                                        pos = pos2;\n                                      }\n                                      result1 = result1 !== null ? result1 : \"\";\n                                      if (result1 !== null) {\n                                        pos2 = pos;\n                                        if (input.charCodeAt(pos) === 58) {\n                                          result2 = \":\";\n                                          pos++;\n                                        } else {\n                                          result2 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\":\\\"\");\n                                          }\n                                        }\n                                        if (result2 !== null) {\n                                          result3 = parse_h16();\n                                          if (result3 !== null) {\n                                            result2 = [result2, result3];\n                                          } else {\n                                            result2 = null;\n                                            pos = pos2;\n                                          }\n                                        } else {\n                                          result2 = null;\n                                          pos = pos2;\n                                        }\n                                        result2 = result2 !== null ? result2 : \"\";\n                                        if (result2 !== null) {\n                                          pos2 = pos;\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result3 = \":\";\n                                            pos++;\n                                          } else {\n                                            result3 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result3 !== null) {\n                                            result4 = parse_h16();\n                                            if (result4 !== null) {\n                                              result3 = [result3, result4];\n                                            } else {\n                                              result3 = null;\n                                              pos = pos2;\n                                            }\n                                          } else {\n                                            result3 = null;\n                                            pos = pos2;\n                                          }\n                                          result3 = result3 !== null ? result3 : \"\";\n                                          if (result3 !== null) {\n                                            pos2 = pos;\n                                            if (input.charCodeAt(pos) === 58) {\n                                              result4 = \":\";\n                                              pos++;\n                                            } else {\n                                              result4 = null;\n                                              if (reportFailures === 0) {\n                                                matchFailed(\"\\\":\\\"\");\n                                              }\n                                            }\n                                            if (result4 !== null) {\n                                              result5 = parse_h16();\n                                              if (result5 !== null) {\n                                                result4 = [result4, result5];\n                                              } else {\n                                                result4 = null;\n                                                pos = pos2;\n                                              }\n                                            } else {\n                                              result4 = null;\n                                              pos = pos2;\n                                            }\n                                            result4 = result4 !== null ? result4 : \"\";\n                                            if (result4 !== null) {\n                                              pos2 = pos;\n                                              if (input.charCodeAt(pos) === 58) {\n                                                result5 = \":\";\n                                                pos++;\n                                              } else {\n                                                result5 = null;\n                                                if (reportFailures === 0) {\n                                                  matchFailed(\"\\\":\\\"\");\n                                                }\n                                              }\n                                              if (result5 !== null) {\n                                                result6 = parse_h16();\n                                                if (result6 !== null) {\n                                                  result5 = [result5, result6];\n                                                } else {\n                                                  result5 = null;\n                                                  pos = pos2;\n                                                }\n                                              } else {\n                                                result5 = null;\n                                                pos = pos2;\n                                              }\n                                              result5 = result5 !== null ? result5 : \"\";\n                                              if (result5 !== null) {\n                                                pos2 = pos;\n                                                if (input.charCodeAt(pos) === 58) {\n                                                  result6 = \":\";\n                                                  pos++;\n                                                } else {\n                                                  result6 = null;\n                                                  if (reportFailures === 0) {\n                                                    matchFailed(\"\\\":\\\"\");\n                                                  }\n                                                }\n                                                if (result6 !== null) {\n                                                  result7 = parse_h16();\n                                                  if (result7 !== null) {\n                                                    result6 = [result6, result7];\n                                                  } else {\n                                                    result6 = null;\n                                                    pos = pos2;\n                                                  }\n                                                } else {\n                                                  result6 = null;\n                                                  pos = pos2;\n                                                }\n                                                result6 = result6 !== null ? result6 : \"\";\n                                                if (result6 !== null) {\n                                                  if (input.substr(pos, 2) === \"::\") {\n                                                    result7 = \"::\";\n                                                    pos += 2;\n                                                  } else {\n                                                    result7 = null;\n                                                    if (reportFailures === 0) {\n                                                      matchFailed(\"\\\"::\\\"\");\n                                                    }\n                                                  }\n                                                  if (result7 !== null) {\n                                                    result0 = [result0, result1, result2, result3, result4, result5, result6, result7];\n                                                  } else {\n                                                    result0 = null;\n                                                    pos = pos1;\n                                                  }\n                                                } else {\n                                                  result0 = null;\n                                                  pos = pos1;\n                                                }\n                                              } else {\n                                                result0 = null;\n                                                pos = pos1;\n                                              }\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                          data.host_type = 'IPv6';\n                          return input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_h16() {\n        var result0, result1, result2, result3;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_HEXDIG();\n        if (result0 !== null) {\n          result1 = parse_HEXDIG();\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result2 = parse_HEXDIG();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_HEXDIG();\n              result3 = result3 !== null ? result3 : \"\";\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_ls32() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_h16();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_h16();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        if (result0 === null) {\n          result0 = parse_IPv4address();\n        }\n        return result0;\n      }\n      function parse_IPv4address() {\n        var result0, result1, result2, result3, result4, result5, result6;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_dec_octet();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 46) {\n            result1 = \".\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_dec_octet();\n            if (result2 !== null) {\n              if (input.charCodeAt(pos) === 46) {\n                result3 = \".\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\".\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result4 = parse_dec_octet();\n                if (result4 !== null) {\n                  if (input.charCodeAt(pos) === 46) {\n                    result5 = \".\";\n                    pos++;\n                  } else {\n                    result5 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\".\\\"\");\n                    }\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_dec_octet();\n                    if (result6 !== null) {\n                      result0 = [result0, result1, result2, result3, result4, result5, result6];\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                            data.host_type = 'IPv4';\n                            return input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_dec_octet() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 2) === \"25\") {\n          result0 = \"25\";\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"25\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (/^[0-5]/.test(input.charAt(pos))) {\n            result1 = input.charAt(pos);\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[0-5]\");\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          if (input.charCodeAt(pos) === 50) {\n            result0 = \"2\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"2\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            if (/^[0-4]/.test(input.charAt(pos))) {\n              result1 = input.charAt(pos);\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[0-4]\");\n              }\n            }\n            if (result1 !== null) {\n              result2 = parse_DIGIT();\n              if (result2 !== null) {\n                result0 = [result0, result1, result2];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n          if (result0 === null) {\n            pos0 = pos;\n            if (input.charCodeAt(pos) === 49) {\n              result0 = \"1\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"1\\\"\");\n              }\n            }\n            if (result0 !== null) {\n              result1 = parse_DIGIT();\n              if (result1 !== null) {\n                result2 = parse_DIGIT();\n                if (result2 !== null) {\n                  result0 = [result0, result1, result2];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n            if (result0 === null) {\n              pos0 = pos;\n              if (/^[1-9]/.test(input.charAt(pos))) {\n                result0 = input.charAt(pos);\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"[1-9]\");\n                }\n              }\n              if (result0 !== null) {\n                result1 = parse_DIGIT();\n                if (result1 !== null) {\n                  result0 = [result0, result1];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n              if (result0 === null) {\n                result0 = parse_DIGIT();\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_port() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_DIGIT();\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result1 = parse_DIGIT();\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_DIGIT();\n              result3 = result3 !== null ? result3 : \"\";\n              if (result3 !== null) {\n                result4 = parse_DIGIT();\n                result4 = result4 !== null ? result4 : \"\";\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, port) {\n                            port = parseInt(port.join(''));\n                            data.port = port;\n                            return port; })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uri_parameters() {\n        var result0, result1, result2;\n        var pos0;\n        result0 = [];\n        pos0 = pos;\n        if (input.charCodeAt(pos) === 59) {\n          result1 = \";\";\n          pos++;\n        } else {\n          result1 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\";\\\"\");\n          }\n        }\n        if (result1 !== null) {\n          result2 = parse_uri_parameter();\n          if (result2 !== null) {\n            result1 = [result1, result2];\n          } else {\n            result1 = null;\n            pos = pos0;\n          }\n        } else {\n          result1 = null;\n          pos = pos0;\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          pos0 = pos;\n          if (input.charCodeAt(pos) === 59) {\n            result1 = \";\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\";\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_uri_parameter();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos0;\n            }\n          } else {\n            result1 = null;\n            pos = pos0;\n          }\n        }\n        return result0;\n      }\n      function parse_uri_parameter() {\n        var result0;\n        result0 = parse_transport_param();\n        if (result0 === null) {\n          result0 = parse_user_param();\n          if (result0 === null) {\n            result0 = parse_method_param();\n            if (result0 === null) {\n              result0 = parse_ttl_param();\n              if (result0 === null) {\n                result0 = parse_maddr_param();\n                if (result0 === null) {\n                  result0 = parse_lr_param();\n                  if (result0 === null) {\n                    result0 = parse_other_param();\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_transport_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 10).toLowerCase() === \"transport=\") {\n          result0 = input.substr(pos, 10);\n          pos += 10;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"transport=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (input.substr(pos, 3).toLowerCase() === \"udp\") {\n            result1 = input.substr(pos, 3);\n            pos += 3;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"udp\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.substr(pos, 3).toLowerCase() === \"tcp\") {\n              result1 = input.substr(pos, 3);\n              pos += 3;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"tcp\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.substr(pos, 4).toLowerCase() === \"sctp\") {\n                result1 = input.substr(pos, 4);\n                pos += 4;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"sctp\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.substr(pos, 3).toLowerCase() === \"tls\") {\n                  result1 = input.substr(pos, 3);\n                  pos += 3;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"tls\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  result1 = parse_token();\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, transport) {\n                              if(!data.uri_params) data.uri_params={};\n                              data.uri_params['transport'] = transport.toLowerCase(); })(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_user_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"user=\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"user=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (input.substr(pos, 5).toLowerCase() === \"phone\") {\n            result1 = input.substr(pos, 5);\n            pos += 5;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"phone\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.substr(pos, 2).toLowerCase() === \"ip\") {\n              result1 = input.substr(pos, 2);\n              pos += 2;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"ip\\\"\");\n              }\n            }\n            if (result1 === null) {\n              result1 = parse_token();\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, user) {\n                              if(!data.uri_params) data.uri_params={};\n                              data.uri_params['user'] = user.toLowerCase(); })(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_method_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 7).toLowerCase() === \"method=\") {\n          result0 = input.substr(pos, 7);\n          pos += 7;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"method=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_Method();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, method) {\n                              if(!data.uri_params) data.uri_params={};\n                              data.uri_params['method'] = method; })(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_ttl_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 4).toLowerCase() === \"ttl=\") {\n          result0 = input.substr(pos, 4);\n          pos += 4;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"ttl=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_ttl();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, ttl) {\n                              if(!data.params) data.params={};\n                              data.params['ttl'] = ttl; })(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_maddr_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"maddr=\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"maddr=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_host();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, maddr) {\n                              if(!data.uri_params) data.uri_params={};\n                              data.uri_params['maddr'] = maddr; })(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_lr_param() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 2).toLowerCase() === \"lr\") {\n          result0 = input.substr(pos, 2);\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"lr\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 61) {\n            result1 = \"=\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                              if(!data.uri_params) data.uri_params={};\n                              data.uri_params['lr'] = undefined; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_other_param() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_pname();\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 61) {\n            result1 = \"=\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_pvalue();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, param, value) {\n                              if(!data.uri_params) data.uri_params = {};\n                              if (typeof value === 'undefined'){\n                                value = undefined;\n                              }\n                              else {\n                                value = value[1];\n                              }\n                              data.uri_params[param.toLowerCase()] = value;})(pos0, result0[0], result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_pname() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_paramchar();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_paramchar();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, pname) {return pname.join(''); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_pvalue() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_paramchar();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_paramchar();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, pvalue) {return pvalue.join(''); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_paramchar() {\n        var result0;\n        result0 = parse_param_unreserved();\n        if (result0 === null) {\n          result0 = parse_unreserved();\n          if (result0 === null) {\n            result0 = parse_escaped();\n          }\n        }\n        return result0;\n      }\n      function parse_param_unreserved() {\n        var result0;\n        if (input.charCodeAt(pos) === 91) {\n          result0 = \"[\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"[\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 93) {\n            result0 = \"]\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"]\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 47) {\n              result0 = \"/\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"/\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 58) {\n                result0 = \":\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\":\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 38) {\n                  result0 = \"&\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"&\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 43) {\n                    result0 = \"+\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"+\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 36) {\n                      result0 = \"$\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"$\\\"\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_headers() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1;\n        pos0 = pos;\n        if (input.charCodeAt(pos) === 63) {\n          result0 = \"?\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"?\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_header();\n          if (result1 !== null) {\n            result2 = [];\n            pos1 = pos;\n            if (input.charCodeAt(pos) === 38) {\n              result3 = \"&\";\n              pos++;\n            } else {\n              result3 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"&\\\"\");\n              }\n            }\n            if (result3 !== null) {\n              result4 = parse_header();\n              if (result4 !== null) {\n                result3 = [result3, result4];\n              } else {\n                result3 = null;\n                pos = pos1;\n              }\n            } else {\n              result3 = null;\n              pos = pos1;\n            }\n            while (result3 !== null) {\n              result2.push(result3);\n              pos1 = pos;\n              if (input.charCodeAt(pos) === 38) {\n                result3 = \"&\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"&\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result4 = parse_header();\n                if (result4 !== null) {\n                  result3 = [result3, result4];\n                } else {\n                  result3 = null;\n                  pos = pos1;\n                }\n              } else {\n                result3 = null;\n                pos = pos1;\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_header() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_hname();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 61) {\n            result1 = \"=\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_hvalue();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, hname, hvalue) {\n                              hname = hname.join('').toLowerCase();\n                              hvalue = hvalue.join('');\n                              if(!data.uri_headers) data.uri_headers = {};\n                              if (!data.uri_headers[hname]) {\n                                data.uri_headers[hname] = [hvalue];\n                              } else {\n                                data.uri_headers[hname].push(hvalue);\n                              }})(pos0, result0[0], result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hname() {\n        var result0, result1;\n        result1 = parse_hnv_unreserved();\n        if (result1 === null) {\n          result1 = parse_unreserved();\n          if (result1 === null) {\n            result1 = parse_escaped();\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_hnv_unreserved();\n            if (result1 === null) {\n              result1 = parse_unreserved();\n              if (result1 === null) {\n                result1 = parse_escaped();\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        return result0;\n      }\n      function parse_hvalue() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_hnv_unreserved();\n        if (result1 === null) {\n          result1 = parse_unreserved();\n          if (result1 === null) {\n            result1 = parse_escaped();\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_hnv_unreserved();\n          if (result1 === null) {\n            result1 = parse_unreserved();\n            if (result1 === null) {\n              result1 = parse_escaped();\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_hnv_unreserved() {\n        var result0;\n        if (input.charCodeAt(pos) === 91) {\n          result0 = \"[\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"[\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 93) {\n            result0 = \"]\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"]\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 47) {\n              result0 = \"/\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"/\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 63) {\n                result0 = \"?\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"?\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 58) {\n                  result0 = \":\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\":\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 43) {\n                    result0 = \"+\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"+\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 36) {\n                      result0 = \"$\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"$\\\"\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_Request_Response() {\n        var result0;\n        result0 = parse_Status_Line();\n        if (result0 === null) {\n          result0 = parse_Request_Line();\n        }\n        return result0;\n      }\n      function parse_Request_Line() {\n        var result0, result1, result2, result3, result4;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_Method();\n        if (result0 !== null) {\n          result1 = parse_SP();\n          if (result1 !== null) {\n            result2 = parse_Request_URI();\n            if (result2 !== null) {\n              result3 = parse_SP();\n              if (result3 !== null) {\n                result4 = parse_SIP_Version();\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Request_URI() {\n        var result0;\n        result0 = parse_SIP_URI();\n        if (result0 === null) {\n          result0 = parse_absoluteURI();\n        }\n        return result0;\n      }\n      function parse_absoluteURI() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_scheme();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_hier_part();\n            if (result2 === null) {\n              result2 = parse_opaque_part();\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hier_part() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_net_path();\n        if (result0 === null) {\n          result0 = parse_abs_path();\n        }\n        if (result0 !== null) {\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 63) {\n            result1 = \"?\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"?\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_query();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos1;\n            }\n          } else {\n            result1 = null;\n            pos = pos1;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_net_path() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 2) === \"//\") {\n          result0 = \"//\";\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"//\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_authority();\n          if (result1 !== null) {\n            result2 = parse_abs_path();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_abs_path() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        if (input.charCodeAt(pos) === 47) {\n          result0 = \"/\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"/\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_path_segments();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_opaque_part() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_uric_no_slash();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_uric();\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_uric();\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uric() {\n        var result0;\n        result0 = parse_reserved();\n        if (result0 === null) {\n          result0 = parse_unreserved();\n          if (result0 === null) {\n            result0 = parse_escaped();\n          }\n        }\n        return result0;\n      }\n      function parse_uric_no_slash() {\n        var result0;\n        result0 = parse_unreserved();\n        if (result0 === null) {\n          result0 = parse_escaped();\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 59) {\n              result0 = \";\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\";\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 63) {\n                result0 = \"?\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"?\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 58) {\n                  result0 = \":\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\":\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 64) {\n                    result0 = \"@\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"@\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 38) {\n                      result0 = \"&\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"&\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 61) {\n                        result0 = \"=\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"=\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 43) {\n                          result0 = \"+\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"+\\\"\");\n                          }\n                        }\n                        if (result0 === null) {\n                          if (input.charCodeAt(pos) === 36) {\n                            result0 = \"$\";\n                            pos++;\n                          } else {\n                            result0 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"$\\\"\");\n                            }\n                          }\n                          if (result0 === null) {\n                            if (input.charCodeAt(pos) === 44) {\n                              result0 = \",\";\n                              pos++;\n                            } else {\n                              result0 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\",\\\"\");\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_path_segments() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_segment();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 47) {\n            result2 = \"/\";\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"/\\\"\");\n            }\n          }\n          if (result2 !== null) {\n            result3 = parse_segment();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            if (input.charCodeAt(pos) === 47) {\n              result2 = \"/\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"/\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_segment();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_segment() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = [];\n        result1 = parse_pchar();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_pchar();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 59) {\n            result2 = \";\";\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\";\\\"\");\n            }\n          }\n          if (result2 !== null) {\n            result3 = parse_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            if (input.charCodeAt(pos) === 59) {\n              result2 = \";\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\";\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_param() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_pchar();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_pchar();\n        }\n        return result0;\n      }\n      function parse_pchar() {\n        var result0;\n        result0 = parse_unreserved();\n        if (result0 === null) {\n          result0 = parse_escaped();\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 58) {\n              result0 = \":\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\":\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 64) {\n                result0 = \"@\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"@\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 38) {\n                  result0 = \"&\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"&\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 61) {\n                    result0 = \"=\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"=\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 43) {\n                      result0 = \"+\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"+\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 36) {\n                        result0 = \"$\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"$\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 44) {\n                          result0 = \",\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\",\\\"\");\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_scheme() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_ALPHA();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_ALPHA();\n          if (result2 === null) {\n            result2 = parse_DIGIT();\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 43) {\n                result2 = \"+\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"+\\\"\");\n                }\n              }\n              if (result2 === null) {\n                if (input.charCodeAt(pos) === 45) {\n                  result2 = \"-\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"-\\\"\");\n                  }\n                }\n                if (result2 === null) {\n                  if (input.charCodeAt(pos) === 46) {\n                    result2 = \".\";\n                    pos++;\n                  } else {\n                    result2 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\".\\\"\");\n                    }\n                  }\n                }\n              }\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_ALPHA();\n            if (result2 === null) {\n              result2 = parse_DIGIT();\n              if (result2 === null) {\n                if (input.charCodeAt(pos) === 43) {\n                  result2 = \"+\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"+\\\"\");\n                  }\n                }\n                if (result2 === null) {\n                  if (input.charCodeAt(pos) === 45) {\n                    result2 = \"-\";\n                    pos++;\n                  } else {\n                    result2 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"-\\\"\");\n                    }\n                  }\n                  if (result2 === null) {\n                    if (input.charCodeAt(pos) === 46) {\n                      result2 = \".\";\n                      pos++;\n                    } else {\n                      result2 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\".\\\"\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                            data.scheme= input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_authority() {\n        var result0;\n        result0 = parse_srvr();\n        if (result0 === null) {\n          result0 = parse_reg_name();\n        }\n        return result0;\n      }\n      function parse_srvr() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_userinfo();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 64) {\n            result1 = \"@\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"@\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result1 = parse_hostport();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        result0 = result0 !== null ? result0 : \"\";\n        return result0;\n      }\n      function parse_reg_name() {\n        var result0, result1;\n        result1 = parse_unreserved();\n        if (result1 === null) {\n          result1 = parse_escaped();\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 36) {\n              result1 = \"$\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"$\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 44) {\n                result1 = \",\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\",\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 59) {\n                  result1 = \";\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\";\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 58) {\n                    result1 = \":\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\":\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 64) {\n                      result1 = \"@\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"@\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 38) {\n                        result1 = \"&\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"&\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 61) {\n                          result1 = \"=\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"=\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 43) {\n                            result1 = \"+\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"+\\\"\");\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_unreserved();\n            if (result1 === null) {\n              result1 = parse_escaped();\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 36) {\n                  result1 = \"$\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"$\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 44) {\n                    result1 = \",\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\",\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 59) {\n                      result1 = \";\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\";\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result1 = \":\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 64) {\n                          result1 = \"@\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"@\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 38) {\n                            result1 = \"&\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"&\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 61) {\n                              result1 = \"=\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"=\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 43) {\n                                result1 = \"+\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"+\\\"\");\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        return result0;\n      }\n      function parse_query() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_uric();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_uric();\n        }\n        return result0;\n      }\n      function parse_SIP_Version() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"sip\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"SIP\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 47) {\n            result1 = \"/\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"/\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result3 = parse_DIGIT();\n            if (result3 !== null) {\n              result2 = [];\n              while (result3 !== null) {\n                result2.push(result3);\n                result3 = parse_DIGIT();\n              }\n            } else {\n              result2 = null;\n            }\n            if (result2 !== null) {\n              if (input.charCodeAt(pos) === 46) {\n                result3 = \".\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\".\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result5 = parse_DIGIT();\n                if (result5 !== null) {\n                  result4 = [];\n                  while (result5 !== null) {\n                    result4.push(result5);\n                    result5 = parse_DIGIT();\n                  }\n                } else {\n                  result4 = null;\n                }\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                            data.sip_version = input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_INVITEm() {\n        var result0;\n        if (input.substr(pos, 6) === \"INVITE\") {\n          result0 = \"INVITE\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"INVITE\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_ACKm() {\n        var result0;\n        if (input.substr(pos, 3) === \"ACK\") {\n          result0 = \"ACK\";\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"ACK\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_OPTIONSm() {\n        var result0;\n        if (input.substr(pos, 7) === \"OPTIONS\") {\n          result0 = \"OPTIONS\";\n          pos += 7;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"OPTIONS\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_BYEm() {\n        var result0;\n        if (input.substr(pos, 3) === \"BYE\") {\n          result0 = \"BYE\";\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"BYE\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_CANCELm() {\n        var result0;\n        if (input.substr(pos, 6) === \"CANCEL\") {\n          result0 = \"CANCEL\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"CANCEL\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_REGISTERm() {\n        var result0;\n        if (input.substr(pos, 8) === \"REGISTER\") {\n          result0 = \"REGISTER\";\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"REGISTER\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_SUBSCRIBEm() {\n        var result0;\n        if (input.substr(pos, 9) === \"SUBSCRIBE\") {\n          result0 = \"SUBSCRIBE\";\n          pos += 9;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"SUBSCRIBE\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_NOTIFYm() {\n        var result0;\n        if (input.substr(pos, 6) === \"NOTIFY\") {\n          result0 = \"NOTIFY\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"NOTIFY\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_REFERm() {\n        var result0;\n        if (input.substr(pos, 5) === \"REFER\") {\n          result0 = \"REFER\";\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"REFER\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_Method() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_INVITEm();\n        if (result0 === null) {\n          result0 = parse_ACKm();\n          if (result0 === null) {\n            result0 = parse_OPTIONSm();\n            if (result0 === null) {\n              result0 = parse_BYEm();\n              if (result0 === null) {\n                result0 = parse_CANCELm();\n                if (result0 === null) {\n                  result0 = parse_REGISTERm();\n                  if (result0 === null) {\n                    result0 = parse_SUBSCRIBEm();\n                    if (result0 === null) {\n                      result0 = parse_NOTIFYm();\n                      if (result0 === null) {\n                        result0 = parse_REFERm();\n                        if (result0 === null) {\n                          result0 = parse_token();\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                            data.method = input.substring(pos, offset);\n                            return data.method; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Status_Line() {\n        var result0, result1, result2, result3, result4;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_SIP_Version();\n        if (result0 !== null) {\n          result1 = parse_SP();\n          if (result1 !== null) {\n            result2 = parse_Status_Code();\n            if (result2 !== null) {\n              result3 = parse_SP();\n              if (result3 !== null) {\n                result4 = parse_Reason_Phrase();\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Status_Code() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_extension_code();\n        if (result0 !== null) {\n          result0 = (function(offset, status_code) {\n                          data.status_code = parseInt(status_code.join('')); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_extension_code() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_DIGIT();\n        if (result0 !== null) {\n          result1 = parse_DIGIT();\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Reason_Phrase() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result0 = [];\n        result1 = parse_reserved();\n        if (result1 === null) {\n          result1 = parse_unreserved();\n          if (result1 === null) {\n            result1 = parse_escaped();\n            if (result1 === null) {\n              result1 = parse_UTF8_NONASCII();\n              if (result1 === null) {\n                result1 = parse_UTF8_CONT();\n                if (result1 === null) {\n                  result1 = parse_SP();\n                  if (result1 === null) {\n                    result1 = parse_HTAB();\n                  }\n                }\n              }\n            }\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_reserved();\n          if (result1 === null) {\n            result1 = parse_unreserved();\n            if (result1 === null) {\n              result1 = parse_escaped();\n              if (result1 === null) {\n                result1 = parse_UTF8_NONASCII();\n                if (result1 === null) {\n                  result1 = parse_UTF8_CONT();\n                  if (result1 === null) {\n                    result1 = parse_SP();\n                    if (result1 === null) {\n                      result1 = parse_HTAB();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                          data.reason_phrase = input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Allow_Events() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_event_type();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_event_type();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_event_type();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Call_ID() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_word();\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 64) {\n            result1 = \"@\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"@\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_word();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                      data = input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Contact() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        result0 = parse_STAR();\n        if (result0 === null) {\n          pos1 = pos;\n          result0 = parse_contact_param();\n          if (result0 !== null) {\n            result1 = [];\n            pos2 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_contact_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n            while (result2 !== null) {\n              result1.push(result2);\n              pos2 = pos;\n              result2 = parse_COMMA();\n              if (result2 !== null) {\n                result3 = parse_contact_param();\n                if (result3 !== null) {\n                  result2 = [result2, result3];\n                } else {\n                  result2 = null;\n                  pos = pos2;\n                }\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            }\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                                var idx, length;\n                                length = data.multi_header.length;\n                                for (idx = 0; idx < length; idx++) {\n                                  if (data.multi_header[idx].parsed === null) {\n                                    data = null;\n                                    break;\n                                  }\n                                }\n                                if (data !== null) {\n                                  data = data.multi_header;\n                                } else {\n                                  data = -1;\n                                }})(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_contact_param() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SIP_URI_noparams();\n        if (result0 === null) {\n          result0 = parse_name_addr();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_contact_params();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_contact_params();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                                var header;\n                                if(!data.multi_header) data.multi_header = [];\n                                try {\n                                  header = new NameAddrHeader(data.uri, data.display_name, data.params);\n                                  delete data.uri;\n                                  delete data.display_name;\n                                  delete data.params;\n                                } catch(e) {\n                                  header = null;\n                                }\n                                data.multi_header.push( { 'possition': pos,\n                                                          'offset': offset,\n                                                          'parsed': header\n                                                        });})(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_name_addr() {\n        var result0, result1, result2, result3;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_display_name();\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result1 = parse_LAQUOT();\n          if (result1 !== null) {\n            result2 = parse_SIP_URI();\n            if (result2 !== null) {\n              result3 = parse_RAQUOT();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_display_name() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_LWS();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_LWS();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 === null) {\n          result0 = parse_quoted_string_clean();\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, display_name) {\n                                if (typeof display_name === 'string') { // quoted_string_clean\n                                    data.display_name = display_name;\n                                } else { // token ( LWS token )*\n                                    data.display_name = display_name[1].reduce(function(acc, cur) {\n                                        return acc + cur[0] + cur[1];\n                                    }, display_name[0]);\n                                }})(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_contact_params() {\n        var result0;\n        result0 = parse_c_p_q();\n        if (result0 === null) {\n          result0 = parse_c_p_expires();\n          if (result0 === null) {\n            result0 = parse_generic_param();\n          }\n        }\n        return result0;\n      }\n      function parse_c_p_q() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 1).toLowerCase() === \"q\") {\n          result0 = input.substr(pos, 1);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"q\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_qvalue();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, q) {\n                                if(!data.params) data.params = {};\n                                data.params['q'] = q; })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_c_p_expires() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 7).toLowerCase() === \"expires\") {\n          result0 = input.substr(pos, 7);\n          pos += 7;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"expires\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_delta_seconds();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, expires) {\n                                if(!data.params) data.params = {};\n                                data.params['expires'] = expires; })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_delta_seconds() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_DIGIT();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_DIGIT();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, delta_seconds) {\n                                return parseInt(delta_seconds.join('')); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_qvalue() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 48) {\n          result0 = \"0\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"0\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 46) {\n            result1 = \".\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_DIGIT();\n              result3 = result3 !== null ? result3 : \"\";\n              if (result3 !== null) {\n                result4 = parse_DIGIT();\n                result4 = result4 !== null ? result4 : \"\";\n                if (result4 !== null) {\n                  result1 = [result1, result2, result3, result4];\n                } else {\n                  result1 = null;\n                  pos = pos2;\n                }\n              } else {\n                result1 = null;\n                pos = pos2;\n              }\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                                return parseFloat(input.substring(pos, offset)); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_generic_param() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          pos2 = pos;\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_gen_value();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, param, value) {\n                                if(!data.params) data.params = {};\n                                if (typeof value === 'undefined'){\n                                  value = undefined;\n                                }\n                                else {\n                                  value = value[1];\n                                }\n                                data.params[param.toLowerCase()] = value;})(pos0, result0[0], result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_gen_value() {\n        var result0;\n        result0 = parse_token();\n        if (result0 === null) {\n          result0 = parse_host();\n          if (result0 === null) {\n            result0 = parse_quoted_string();\n          }\n        }\n        return result0;\n      }\n      function parse_Content_Disposition() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_disp_type();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_disp_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_disp_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_disp_type() {\n        var result0;\n        if (input.substr(pos, 6).toLowerCase() === \"render\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"render\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 7).toLowerCase() === \"session\") {\n            result0 = input.substr(pos, 7);\n            pos += 7;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"session\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 4).toLowerCase() === \"icon\") {\n              result0 = input.substr(pos, 4);\n              pos += 4;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"icon\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 5).toLowerCase() === \"alert\") {\n                result0 = input.substr(pos, 5);\n                pos += 5;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"alert\\\"\");\n                }\n              }\n              if (result0 === null) {\n                result0 = parse_token();\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_disp_param() {\n        var result0;\n        result0 = parse_handling_param();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_handling_param() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 8).toLowerCase() === \"handling\") {\n          result0 = input.substr(pos, 8);\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"handling\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            if (input.substr(pos, 8).toLowerCase() === \"optional\") {\n              result2 = input.substr(pos, 8);\n              pos += 8;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"optional\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.substr(pos, 8).toLowerCase() === \"required\") {\n                result2 = input.substr(pos, 8);\n                pos += 8;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"required\\\"\");\n                }\n              }\n              if (result2 === null) {\n                result2 = parse_token();\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Content_Encoding() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Content_Length() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_DIGIT();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_DIGIT();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, length) {\n                                data = parseInt(length.join('')); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Content_Type() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_media_type();\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                                data = input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_media_type() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_m_type();\n        if (result0 !== null) {\n          result1 = parse_SLASH();\n          if (result1 !== null) {\n            result2 = parse_m_subtype();\n            if (result2 !== null) {\n              result3 = [];\n              pos1 = pos;\n              result4 = parse_SEMI();\n              if (result4 !== null) {\n                result5 = parse_m_parameter();\n                if (result5 !== null) {\n                  result4 = [result4, result5];\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              } else {\n                result4 = null;\n                pos = pos1;\n              }\n              while (result4 !== null) {\n                result3.push(result4);\n                pos1 = pos;\n                result4 = parse_SEMI();\n                if (result4 !== null) {\n                  result5 = parse_m_parameter();\n                  if (result5 !== null) {\n                    result4 = [result4, result5];\n                  } else {\n                    result4 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              }\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_m_type() {\n        var result0;\n        result0 = parse_discrete_type();\n        if (result0 === null) {\n          result0 = parse_composite_type();\n        }\n        return result0;\n      }\n      function parse_discrete_type() {\n        var result0;\n        if (input.substr(pos, 4).toLowerCase() === \"text\") {\n          result0 = input.substr(pos, 4);\n          pos += 4;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"text\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 5).toLowerCase() === \"image\") {\n            result0 = input.substr(pos, 5);\n            pos += 5;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"image\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 5).toLowerCase() === \"audio\") {\n              result0 = input.substr(pos, 5);\n              pos += 5;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"audio\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 5).toLowerCase() === \"video\") {\n                result0 = input.substr(pos, 5);\n                pos += 5;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"video\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.substr(pos, 11).toLowerCase() === \"application\") {\n                  result0 = input.substr(pos, 11);\n                  pos += 11;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"application\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  result0 = parse_extension_token();\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_composite_type() {\n        var result0;\n        if (input.substr(pos, 7).toLowerCase() === \"message\") {\n          result0 = input.substr(pos, 7);\n          pos += 7;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"message\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 9).toLowerCase() === \"multipart\") {\n            result0 = input.substr(pos, 9);\n            pos += 9;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"multipart\\\"\");\n            }\n          }\n          if (result0 === null) {\n            result0 = parse_extension_token();\n          }\n        }\n        return result0;\n      }\n      function parse_extension_token() {\n        var result0;\n        result0 = parse_token();\n        if (result0 === null) {\n          result0 = parse_x_token();\n        }\n        return result0;\n      }\n      function parse_x_token() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 2).toLowerCase() === \"x-\") {\n          result0 = input.substr(pos, 2);\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"x-\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_token();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_m_subtype() {\n        var result0;\n        result0 = parse_extension_token();\n        if (result0 === null) {\n          result0 = parse_token();\n        }\n        return result0;\n      }\n      function parse_m_parameter() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_m_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_m_value() {\n        var result0;\n        result0 = parse_token();\n        if (result0 === null) {\n          result0 = parse_quoted_string();\n        }\n        return result0;\n      }\n      function parse_CSeq() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_CSeq_value();\n        if (result0 !== null) {\n          result1 = parse_LWS();\n          if (result1 !== null) {\n            result2 = parse_Method();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_CSeq_value() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_DIGIT();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_DIGIT();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, cseq_value) {\n                          data.value=parseInt(cseq_value.join('')); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Expires() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_delta_seconds();\n        if (result0 !== null) {\n          result0 = (function(offset, expires) {data = expires; })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Event() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_event_type();\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_generic_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_generic_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, event_type) {\n                               data.event = event_type.join('').toLowerCase(); })(pos0, result0[0]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_event_type() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token_nodot();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 46) {\n            result2 = \".\";\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          if (result2 !== null) {\n            result3 = parse_token_nodot();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            if (input.charCodeAt(pos) === 46) {\n              result2 = \".\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_token_nodot();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_From() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SIP_URI_noparams();\n        if (result0 === null) {\n          result0 = parse_name_addr();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_from_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_from_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                        var tag = data.tag;\n                        try {\n                          data = new NameAddrHeader(data.uri, data.display_name, data.params);\n                          if (tag) {data.setParam('tag',tag)}\n                        } catch(e) {\n                          data = -1;\n                        }})(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_from_param() {\n        var result0;\n        result0 = parse_tag_param();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_tag_param() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"tag\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"tag\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, tag) {data.tag = tag; })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Max_Forwards() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_DIGIT();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_DIGIT();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, forwards) {\n                          data = parseInt(forwards.join('')); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Min_Expires() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_delta_seconds();\n        if (result0 !== null) {\n          result0 = (function(offset, min_expires) {data = min_expires; })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Name_Addr_Header() {\n        var result0, result1, result2, result3, result4, result5, result6;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = [];\n        result1 = parse_display_name();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_display_name();\n        }\n        if (result0 !== null) {\n          result1 = parse_LAQUOT();\n          if (result1 !== null) {\n            result2 = parse_SIP_URI();\n            if (result2 !== null) {\n              result3 = parse_RAQUOT();\n              if (result3 !== null) {\n                result4 = [];\n                pos2 = pos;\n                result5 = parse_SEMI();\n                if (result5 !== null) {\n                  result6 = parse_generic_param();\n                  if (result6 !== null) {\n                    result5 = [result5, result6];\n                  } else {\n                    result5 = null;\n                    pos = pos2;\n                  }\n                } else {\n                  result5 = null;\n                  pos = pos2;\n                }\n                while (result5 !== null) {\n                  result4.push(result5);\n                  pos2 = pos;\n                  result5 = parse_SEMI();\n                  if (result5 !== null) {\n                    result6 = parse_generic_param();\n                    if (result6 !== null) {\n                      result5 = [result5, result6];\n                    } else {\n                      result5 = null;\n                      pos = pos2;\n                    }\n                  } else {\n                    result5 = null;\n                    pos = pos2;\n                  }\n                }\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                              try {\n                                data = new NameAddrHeader(data.uri, data.display_name, data.params);\n                              } catch(e) {\n                                data = -1;\n                              }})(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Proxy_Authenticate() {\n        var result0;\n        result0 = parse_challenge();\n        return result0;\n      }\n      function parse_challenge() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"digest\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"Digest\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_LWS();\n          if (result1 !== null) {\n            result2 = parse_digest_cln();\n            if (result2 !== null) {\n              result3 = [];\n              pos1 = pos;\n              result4 = parse_COMMA();\n              if (result4 !== null) {\n                result5 = parse_digest_cln();\n                if (result5 !== null) {\n                  result4 = [result4, result5];\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              } else {\n                result4 = null;\n                pos = pos1;\n              }\n              while (result4 !== null) {\n                result3.push(result4);\n                pos1 = pos;\n                result4 = parse_COMMA();\n                if (result4 !== null) {\n                  result5 = parse_digest_cln();\n                  if (result5 !== null) {\n                    result4 = [result4, result5];\n                  } else {\n                    result4 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              }\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        if (result0 === null) {\n          result0 = parse_other_challenge();\n        }\n        return result0;\n      }\n      function parse_other_challenge() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = parse_LWS();\n          if (result1 !== null) {\n            result2 = parse_auth_param();\n            if (result2 !== null) {\n              result3 = [];\n              pos1 = pos;\n              result4 = parse_COMMA();\n              if (result4 !== null) {\n                result5 = parse_auth_param();\n                if (result5 !== null) {\n                  result4 = [result4, result5];\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              } else {\n                result4 = null;\n                pos = pos1;\n              }\n              while (result4 !== null) {\n                result3.push(result4);\n                pos1 = pos;\n                result4 = parse_COMMA();\n                if (result4 !== null) {\n                  result5 = parse_auth_param();\n                  if (result5 !== null) {\n                    result4 = [result4, result5];\n                  } else {\n                    result4 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              }\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_auth_param() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 === null) {\n              result2 = parse_quoted_string();\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_digest_cln() {\n        var result0;\n        result0 = parse_realm();\n        if (result0 === null) {\n          result0 = parse_domain();\n          if (result0 === null) {\n            result0 = parse_nonce();\n            if (result0 === null) {\n              result0 = parse_opaque();\n              if (result0 === null) {\n                result0 = parse_stale();\n                if (result0 === null) {\n                  result0 = parse_algorithm();\n                  if (result0 === null) {\n                    result0 = parse_qop_options();\n                    if (result0 === null) {\n                      result0 = parse_auth_param();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_realm() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"realm\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"realm\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_realm_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_realm_value() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_quoted_string_clean();\n        if (result0 !== null) {\n          result0 = (function(offset, realm) { data.realm = realm; })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_domain() {\n        var result0, result1, result2, result3, result4, result5, result6;\n        var pos0, pos1;\n        pos0 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"domain\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"domain\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_LDQUOT();\n            if (result2 !== null) {\n              result3 = parse_URI();\n              if (result3 !== null) {\n                result4 = [];\n                pos1 = pos;\n                result6 = parse_SP();\n                if (result6 !== null) {\n                  result5 = [];\n                  while (result6 !== null) {\n                    result5.push(result6);\n                    result6 = parse_SP();\n                  }\n                } else {\n                  result5 = null;\n                }\n                if (result5 !== null) {\n                  result6 = parse_URI();\n                  if (result6 !== null) {\n                    result5 = [result5, result6];\n                  } else {\n                    result5 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result5 = null;\n                  pos = pos1;\n                }\n                while (result5 !== null) {\n                  result4.push(result5);\n                  pos1 = pos;\n                  result6 = parse_SP();\n                  if (result6 !== null) {\n                    result5 = [];\n                    while (result6 !== null) {\n                      result5.push(result6);\n                      result6 = parse_SP();\n                    }\n                  } else {\n                    result5 = null;\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_URI();\n                    if (result6 !== null) {\n                      result5 = [result5, result6];\n                    } else {\n                      result5 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result5 = null;\n                    pos = pos1;\n                  }\n                }\n                if (result4 !== null) {\n                  result5 = parse_RDQUOT();\n                  if (result5 !== null) {\n                    result0 = [result0, result1, result2, result3, result4, result5];\n                  } else {\n                    result0 = null;\n                    pos = pos0;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_URI() {\n        var result0;\n        result0 = parse_absoluteURI();\n        if (result0 === null) {\n          result0 = parse_abs_path();\n        }\n        return result0;\n      }\n      function parse_nonce() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"nonce\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"nonce\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_nonce_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_nonce_value() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_quoted_string_clean();\n        if (result0 !== null) {\n          result0 = (function(offset, nonce) { data.nonce=nonce; })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_opaque() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"opaque\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"opaque\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_quoted_string_clean();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, opaque) { data.opaque=opaque; })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_stale() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"stale\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"stale\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            pos1 = pos;\n            if (input.substr(pos, 4).toLowerCase() === \"true\") {\n              result2 = input.substr(pos, 4);\n              pos += 4;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"true\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result2 = (function(offset) { data.stale=true; })(pos1);\n            }\n            if (result2 === null) {\n              pos = pos1;\n            }\n            if (result2 === null) {\n              pos1 = pos;\n              if (input.substr(pos, 5).toLowerCase() === \"false\") {\n                result2 = input.substr(pos, 5);\n                pos += 5;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"false\\\"\");\n                }\n              }\n              if (result2 !== null) {\n                result2 = (function(offset) { data.stale=false; })(pos1);\n              }\n              if (result2 === null) {\n                pos = pos1;\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_algorithm() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 9).toLowerCase() === \"algorithm\") {\n          result0 = input.substr(pos, 9);\n          pos += 9;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"algorithm\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            if (input.substr(pos, 3).toLowerCase() === \"md5\") {\n              result2 = input.substr(pos, 3);\n              pos += 3;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"MD5\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.substr(pos, 8).toLowerCase() === \"md5-sess\") {\n                result2 = input.substr(pos, 8);\n                pos += 8;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"MD5-sess\\\"\");\n                }\n              }\n              if (result2 === null) {\n                result2 = parse_token();\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, algorithm) {\n                              data.algorithm=algorithm.toUpperCase(); })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_qop_options() {\n        var result0, result1, result2, result3, result4, result5, result6;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"qop\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"qop\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_LDQUOT();\n            if (result2 !== null) {\n              pos1 = pos;\n              result3 = parse_qop_value();\n              if (result3 !== null) {\n                result4 = [];\n                pos2 = pos;\n                if (input.charCodeAt(pos) === 44) {\n                  result5 = \",\";\n                  pos++;\n                } else {\n                  result5 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\",\\\"\");\n                  }\n                }\n                if (result5 !== null) {\n                  result6 = parse_qop_value();\n                  if (result6 !== null) {\n                    result5 = [result5, result6];\n                  } else {\n                    result5 = null;\n                    pos = pos2;\n                  }\n                } else {\n                  result5 = null;\n                  pos = pos2;\n                }\n                while (result5 !== null) {\n                  result4.push(result5);\n                  pos2 = pos;\n                  if (input.charCodeAt(pos) === 44) {\n                    result5 = \",\";\n                    pos++;\n                  } else {\n                    result5 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\",\\\"\");\n                    }\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_qop_value();\n                    if (result6 !== null) {\n                      result5 = [result5, result6];\n                    } else {\n                      result5 = null;\n                      pos = pos2;\n                    }\n                  } else {\n                    result5 = null;\n                    pos = pos2;\n                  }\n                }\n                if (result4 !== null) {\n                  result3 = [result3, result4];\n                } else {\n                  result3 = null;\n                  pos = pos1;\n                }\n              } else {\n                result3 = null;\n                pos = pos1;\n              }\n              if (result3 !== null) {\n                result4 = parse_RDQUOT();\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_qop_value() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 8).toLowerCase() === \"auth-int\") {\n          result0 = input.substr(pos, 8);\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"auth-int\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 4).toLowerCase() === \"auth\") {\n            result0 = input.substr(pos, 4);\n            pos += 4;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"auth\\\"\");\n            }\n          }\n          if (result0 === null) {\n            result0 = parse_token();\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, qop_value) {\n                                data.qop || (data.qop=[]);\n                                data.qop.push(qop_value.toLowerCase()); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Proxy_Require() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Record_Route() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_rec_route();\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_rec_route();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_rec_route();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                          var idx, length;\n                          length = data.multi_header.length;\n                          for (idx = 0; idx < length; idx++) {\n                            if (data.multi_header[idx].parsed === null) {\n                              data = null;\n                              break;\n                            }\n                          }\n                          if (data !== null) {\n                            data = data.multi_header;\n                          } else {\n                            data = -1;\n                          }})(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_rec_route() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_name_addr();\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_generic_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_generic_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                          var header;\n                          if(!data.multi_header) data.multi_header = [];\n                          try {\n                            header = new NameAddrHeader(data.uri, data.display_name, data.params);\n                            delete data.uri;\n                            delete data.display_name;\n                            delete data.params;\n                          } catch(e) {\n                            header = null;\n                          }\n                          data.multi_header.push( { 'possition': pos,\n                                                    'offset': offset,\n                                                    'parsed': header\n                                                  });})(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Reason() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"sip\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"SIP\\\"\");\n          }\n        }\n        if (result0 === null) {\n          result0 = parse_token();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_reason_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_reason_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, protocol) {\n                          data.protocol = protocol.toLowerCase();\n                          if (!data.params) data.params = {};\n                          if (data.params.text && data.params.text[0] === '\"') {\n                            var text = data.params.text;\n                            data.text = text.substring(1, text.length-1);\n                            delete data.params.text;\n                          }\n                        })(pos0, result0[0]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_reason_param() {\n        var result0;\n        result0 = parse_reason_cause();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_reason_cause() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"cause\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"cause\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result3 = parse_DIGIT();\n            if (result3 !== null) {\n              result2 = [];\n              while (result3 !== null) {\n                result2.push(result3);\n                result3 = parse_DIGIT();\n              }\n            } else {\n              result2 = null;\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, cause) {\n                          data.cause = parseInt(cause.join(''));\n                        })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Require() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Route() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_route_param();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_route_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_route_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_route_param() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_name_addr();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_generic_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_generic_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Subscription_State() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_substate_value();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_subexp_params();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_subexp_params();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_substate_value() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"active\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"active\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 7).toLowerCase() === \"pending\") {\n            result0 = input.substr(pos, 7);\n            pos += 7;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"pending\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 10).toLowerCase() === \"terminated\") {\n              result0 = input.substr(pos, 10);\n              pos += 10;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"terminated\\\"\");\n              }\n            }\n            if (result0 === null) {\n              result0 = parse_token();\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                                data.state = input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_subexp_params() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"reason\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"reason\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_event_reason_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, reason) {\n                                if (typeof reason !== 'undefined') data.reason = reason; })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          pos1 = pos;\n          if (input.substr(pos, 7).toLowerCase() === \"expires\") {\n            result0 = input.substr(pos, 7);\n            pos += 7;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"expires\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            result1 = parse_EQUAL();\n            if (result1 !== null) {\n              result2 = parse_delta_seconds();\n              if (result2 !== null) {\n                result0 = [result0, result1, result2];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, expires) {\n                                  if (typeof expires !== 'undefined') data.expires = expires; })(pos0, result0[2]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          if (result0 === null) {\n            pos0 = pos;\n            pos1 = pos;\n            if (input.substr(pos, 11).toLowerCase() === \"retry_after\") {\n              result0 = input.substr(pos, 11);\n              pos += 11;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"retry_after\\\"\");\n              }\n            }\n            if (result0 !== null) {\n              result1 = parse_EQUAL();\n              if (result1 !== null) {\n                result2 = parse_delta_seconds();\n                if (result2 !== null) {\n                  result0 = [result0, result1, result2];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n            if (result0 !== null) {\n              result0 = (function(offset, retry_after) {\n                                    if (typeof retry_after !== 'undefined') data.retry_after = retry_after; })(pos0, result0[2]);\n            }\n            if (result0 === null) {\n              pos = pos0;\n            }\n            if (result0 === null) {\n              result0 = parse_generic_param();\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_event_reason_value() {\n        var result0;\n        if (input.substr(pos, 11).toLowerCase() === \"deactivated\") {\n          result0 = input.substr(pos, 11);\n          pos += 11;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"deactivated\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 9).toLowerCase() === \"probation\") {\n            result0 = input.substr(pos, 9);\n            pos += 9;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"probation\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 8).toLowerCase() === \"rejected\") {\n              result0 = input.substr(pos, 8);\n              pos += 8;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"rejected\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 7).toLowerCase() === \"timeout\") {\n                result0 = input.substr(pos, 7);\n                pos += 7;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"timeout\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.substr(pos, 6).toLowerCase() === \"giveup\") {\n                  result0 = input.substr(pos, 6);\n                  pos += 6;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"giveup\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.substr(pos, 10).toLowerCase() === \"noresource\") {\n                    result0 = input.substr(pos, 10);\n                    pos += 10;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"noresource\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.substr(pos, 9).toLowerCase() === \"invariant\") {\n                      result0 = input.substr(pos, 9);\n                      pos += 9;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"invariant\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      result0 = parse_token();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_Subject() {\n        var result0;\n        result0 = parse_TEXT_UTF8_TRIM();\n        result0 = result0 !== null ? result0 : \"\";\n        return result0;\n      }\n      function parse_Supported() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        result0 = result0 !== null ? result0 : \"\";\n        return result0;\n      }\n      function parse_To() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SIP_URI_noparams();\n        if (result0 === null) {\n          result0 = parse_name_addr();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_to_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_to_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                      var tag = data.tag;\n                      try {\n                        data = new NameAddrHeader(data.uri, data.display_name, data.params);\n                        if (tag) {data.setParam('tag',tag)}\n                      } catch(e) {\n                        data = -1;\n                      }})(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_to_param() {\n        var result0;\n        result0 = parse_tag_param();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_Via() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_via_param();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_via_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_via_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_param() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_sent_protocol();\n        if (result0 !== null) {\n          result1 = parse_LWS();\n          if (result1 !== null) {\n            result2 = parse_sent_by();\n            if (result2 !== null) {\n              result3 = [];\n              pos1 = pos;\n              result4 = parse_SEMI();\n              if (result4 !== null) {\n                result5 = parse_via_params();\n                if (result5 !== null) {\n                  result4 = [result4, result5];\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              } else {\n                result4 = null;\n                pos = pos1;\n              }\n              while (result4 !== null) {\n                result3.push(result4);\n                pos1 = pos;\n                result4 = parse_SEMI();\n                if (result4 !== null) {\n                  result5 = parse_via_params();\n                  if (result5 !== null) {\n                    result4 = [result4, result5];\n                  } else {\n                    result4 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              }\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_params() {\n        var result0;\n        result0 = parse_via_ttl();\n        if (result0 === null) {\n          result0 = parse_via_maddr();\n          if (result0 === null) {\n            result0 = parse_via_received();\n            if (result0 === null) {\n              result0 = parse_via_branch();\n              if (result0 === null) {\n                result0 = parse_response_port();\n                if (result0 === null) {\n                  result0 = parse_generic_param();\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_via_ttl() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"ttl\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"ttl\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_ttl();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, via_ttl_value) {\n                              data.ttl = via_ttl_value; })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_maddr() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"maddr\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"maddr\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_host();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, via_maddr) {\n                              data.maddr = via_maddr; })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_received() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 8).toLowerCase() === \"received\") {\n          result0 = input.substr(pos, 8);\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"received\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_IPv4address();\n            if (result2 === null) {\n              result2 = parse_IPv6address();\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, via_received) {\n                              data.received = via_received; })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_branch() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"branch\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"branch\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, via_branch) {\n                              data.branch = via_branch; })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_response_port() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"rport\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"rport\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          pos2 = pos;\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = [];\n            result3 = parse_DIGIT();\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_DIGIT();\n            }\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                              if(typeof response_port !== 'undefined')\n                                data.rport = response_port.join(''); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_sent_protocol() {\n        var result0, result1, result2, result3, result4;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_protocol_name();\n        if (result0 !== null) {\n          result1 = parse_SLASH();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result3 = parse_SLASH();\n              if (result3 !== null) {\n                result4 = parse_transport();\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_protocol_name() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"sip\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"SIP\\\"\");\n          }\n        }\n        if (result0 === null) {\n          result0 = parse_token();\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, via_protocol) {\n                              data.protocol = via_protocol; })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_transport() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"udp\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"UDP\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 3).toLowerCase() === \"tcp\") {\n            result0 = input.substr(pos, 3);\n            pos += 3;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"TCP\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 3).toLowerCase() === \"tls\") {\n              result0 = input.substr(pos, 3);\n              pos += 3;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"TLS\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 4).toLowerCase() === \"sctp\") {\n                result0 = input.substr(pos, 4);\n                pos += 4;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"SCTP\\\"\");\n                }\n              }\n              if (result0 === null) {\n                result0 = parse_token();\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, via_transport) {\n                              data.transport = via_transport; })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_sent_by() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_via_host();\n        if (result0 !== null) {\n          pos1 = pos;\n          result1 = parse_COLON();\n          if (result1 !== null) {\n            result2 = parse_via_port();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos1;\n            }\n          } else {\n            result1 = null;\n            pos = pos1;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_host() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_IPv4address();\n        if (result0 === null) {\n          result0 = parse_IPv6reference();\n          if (result0 === null) {\n            result0 = parse_hostname();\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                              data.host = input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_port() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_DIGIT();\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result1 = parse_DIGIT();\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_DIGIT();\n              result3 = result3 !== null ? result3 : \"\";\n              if (result3 !== null) {\n                result4 = parse_DIGIT();\n                result4 = result4 !== null ? result4 : \"\";\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, via_sent_by_port) {\n                              data.port = parseInt(via_sent_by_port.join('')); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_ttl() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_DIGIT();\n        if (result0 !== null) {\n          result1 = parse_DIGIT();\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, ttl) {\n                              return parseInt(ttl.join('')); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_WWW_Authenticate() {\n        var result0;\n        result0 = parse_challenge();\n        return result0;\n      }\n      function parse_Session_Expires() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_s_e_expires();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_s_e_params();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_s_e_params();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_s_e_expires() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_delta_seconds();\n        if (result0 !== null) {\n          result0 = (function(offset, expires) { data.expires = expires; })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_s_e_params() {\n        var result0;\n        result0 = parse_s_e_refresher();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_s_e_refresher() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 9).toLowerCase() === \"refresher\") {\n          result0 = input.substr(pos, 9);\n          pos += 9;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"refresher\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            if (input.substr(pos, 3).toLowerCase() === \"uac\") {\n              result2 = input.substr(pos, 3);\n              pos += 3;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"uac\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.substr(pos, 3).toLowerCase() === \"uas\") {\n                result2 = input.substr(pos, 3);\n                pos += 3;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"uas\\\"\");\n                }\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, s_e_refresher_value) { data.refresher = s_e_refresher_value.toLowerCase(); })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_extension_header() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = parse_HCOLON();\n          if (result1 !== null) {\n            result2 = parse_header_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_header_value() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_TEXT_UTF8char();\n        if (result1 === null) {\n          result1 = parse_UTF8_CONT();\n          if (result1 === null) {\n            result1 = parse_LWS();\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_TEXT_UTF8char();\n          if (result1 === null) {\n            result1 = parse_UTF8_CONT();\n            if (result1 === null) {\n              result1 = parse_LWS();\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_message_body() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_OCTET();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_OCTET();\n        }\n        return result0;\n      }\n      function parse_uuid_URI() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 5) === \"uuid:\") {\n          result0 = \"uuid:\";\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"uuid:\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_uuid();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uuid() {\n        var result0, result1, result2, result3, result4, result5, result6, result7, result8;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_hex8();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 45) {\n            result1 = \"-\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"-\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_hex4();\n            if (result2 !== null) {\n              if (input.charCodeAt(pos) === 45) {\n                result3 = \"-\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result4 = parse_hex4();\n                if (result4 !== null) {\n                  if (input.charCodeAt(pos) === 45) {\n                    result5 = \"-\";\n                    pos++;\n                  } else {\n                    result5 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"-\\\"\");\n                    }\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_hex4();\n                    if (result6 !== null) {\n                      if (input.charCodeAt(pos) === 45) {\n                        result7 = \"-\";\n                        pos++;\n                      } else {\n                        result7 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"-\\\"\");\n                        }\n                      }\n                      if (result7 !== null) {\n                        result8 = parse_hex12();\n                        if (result8 !== null) {\n                          result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, uuid) {\n                          data = input.substring(pos+5, offset); })(pos0, result0[0]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hex4() {\n        var result0, result1, result2, result3;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_HEXDIG();\n        if (result0 !== null) {\n          result1 = parse_HEXDIG();\n          if (result1 !== null) {\n            result2 = parse_HEXDIG();\n            if (result2 !== null) {\n              result3 = parse_HEXDIG();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hex8() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_hex4();\n        if (result0 !== null) {\n          result1 = parse_hex4();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hex12() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_hex4();\n        if (result0 !== null) {\n          result1 = parse_hex4();\n          if (result1 !== null) {\n            result2 = parse_hex4();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Refer_To() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SIP_URI_noparams();\n        if (result0 === null) {\n          result0 = parse_name_addr();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_generic_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_generic_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                        try {\n                          data = new NameAddrHeader(data.uri, data.display_name, data.params);\n                        } catch(e) {\n                          data = -1;\n                        }})(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Replaces() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_call_id();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_replaces_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_replaces_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_call_id() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_word();\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 64) {\n            result1 = \"@\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"@\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_word();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                          data.call_id = input.substring(pos, offset); })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_replaces_param() {\n        var result0;\n        result0 = parse_to_tag();\n        if (result0 === null) {\n          result0 = parse_from_tag();\n          if (result0 === null) {\n            result0 = parse_early_flag();\n            if (result0 === null) {\n              result0 = parse_generic_param();\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_to_tag() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6) === \"to-tag\") {\n          result0 = \"to-tag\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"to-tag\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, to_tag) {\n                            data.to_tag = to_tag; })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_from_tag() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 8) === \"from-tag\") {\n          result0 = \"from-tag\";\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"from-tag\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, from_tag) {\n                            data.from_tag = from_tag; })(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_early_flag() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 10) === \"early-only\") {\n          result0 = \"early-only\";\n          pos += 10;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"early-only\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) {\n                            data.early_only = true; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function cleanupExpected(expected) {\n        expected.sort();\n        var lastExpected = null;\n        var cleanExpected = [];\n        for (var i = 0; i < expected.length; i++) {\n          if (expected[i] !== lastExpected) {\n            cleanExpected.push(expected[i]);\n            lastExpected = expected[i];\n          }\n        }\n        return cleanExpected;\n      }\n      function computeErrorPosition() {\n        /*\n         * The first idea was to use |String.split| to break the input up to the\n         * error position along newlines and derive the line and column from\n         * there. However IE's |split| implementation is so broken that it was\n         * enough to prevent it.\n         */\n        var line = 1;\n        var column = 1;\n        var seenCR = false;\n        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {\n          var ch = input.charAt(i);\n          if (ch === \"\\n\") {\n            if (!seenCR) { line++; }\n            column = 1;\n            seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            line++;\n            column = 1;\n            seenCR = true;\n          } else {\n            column++;\n            seenCR = false;\n          }\n        }\n        return { line: line, column: column };\n      }\n        var URI = __webpack_require__(/*! ./URI */ \"./node_modules/jssip/lib/URI.js\");\n        var NameAddrHeader = __webpack_require__(/*! ./NameAddrHeader */ \"./node_modules/jssip/lib/NameAddrHeader.js\");\n        var data = {};\n      var result = parseFunctions[startRule]();\n      /*\n       * The parser is now in one of the following three states:\n       *\n       * 1. The parser successfully parsed the whole input.\n       *\n       *    - |result !== null|\n       *    - |pos === input.length|\n       *    - |rightmostFailuresExpected| may or may not contain something\n       *\n       * 2. The parser successfully parsed only a part of the input.\n       *\n       *    - |result !== null|\n       *    - |pos < input.length|\n       *    - |rightmostFailuresExpected| may or may not contain something\n       *\n       * 3. The parser did not successfully parse any part of the input.\n       *\n       *   - |result === null|\n       *   - |pos === 0|\n       *   - |rightmostFailuresExpected| contains at least one failure\n       *\n       * All code following this comment (including called functions) must\n       * handle these states.\n       */\n      if (result === null || pos !== input.length) {\n        var offset = Math.max(pos, rightmostFailuresPos);\n        var found = offset < input.length ? input.charAt(offset) : null;\n        var errorPosition = computeErrorPosition();\n        new this.SyntaxError(\n          cleanupExpected(rightmostFailuresExpected),\n          found,\n          offset,\n          errorPosition.line,\n          errorPosition.column\n        );\n        return -1;\n      }\n      return data;\n    },\n    /* Returns the parser source code. */\n    toSource: function() { return this._source; }\n  };\n  /* Thrown when a parser encounters a syntax error. */\n  result.SyntaxError = function(expected, found, offset, line, column) {\n    function buildMessage(expected, found) {\n      var expectedHumanized, foundHumanized;\n      switch (expected.length) {\n        case 0:\n          expectedHumanized = \"end of input\";\n          break;\n        case 1:\n          expectedHumanized = expected[0];\n          break;\n        default:\n          expectedHumanized = expected.slice(0, expected.length - 1).join(\", \")\n            + \" or \"\n            + expected[expected.length - 1];\n      }\n      foundHumanized = found ? quote(found) : \"end of input\";\n      return \"Expected \" + expectedHumanized + \" but \" + foundHumanized + \" found.\";\n    }\n    this.name = \"SyntaxError\";\n    this.expected = expected;\n    this.found = found;\n    this.message = buildMessage(expected, found);\n    this.offset = offset;\n    this.line = line;\n    this.column = column;\n  };\n  result.SyntaxError.prototype = Error.prototype;\n  return result;\n})();\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Grammar.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/JsSIP.js":
/*!*****************************************!*\
  !*** ./node_modules/jssip/lib/JsSIP.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const pkg = __webpack_require__(/*! ../package.json */ \"./node_modules/jssip/package.json\");\nconst C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst Exceptions = __webpack_require__(/*! ./Exceptions */ \"./node_modules/jssip/lib/Exceptions.js\");\nconst Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst UA = __webpack_require__(/*! ./UA */ \"./node_modules/jssip/lib/UA.js\");\nconst URI = __webpack_require__(/*! ./URI */ \"./node_modules/jssip/lib/URI.js\");\nconst NameAddrHeader = __webpack_require__(/*! ./NameAddrHeader */ \"./node_modules/jssip/lib/NameAddrHeader.js\");\nconst Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib/Grammar.js\");\nconst WebSocketInterface = __webpack_require__(/*! ./WebSocketInterface */ \"./node_modules/jssip/lib/WebSocketInterface.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP');\n\ndebug('version %s', pkg.version);\n\n/**\n * Expose the JsSIP module.\n */\nmodule.exports = {\n  C,\n  Exceptions,\n  Utils,\n  UA,\n  URI,\n  NameAddrHeader,\n  WebSocketInterface,\n  Grammar,\n  // Expose the debug module.\n  debug : __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\"),\n  get name() { return pkg.title; },\n  get version() { return pkg.version; }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/JsSIP.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Message.js":
/*!*******************************************!*\
  !*** ./node_modules/jssip/lib/Message.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nconst JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib/SIPMessage.js\");\nconst Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst RequestSender = __webpack_require__(/*! ./RequestSender */ \"./node_modules/jssip/lib/RequestSender.js\");\nconst Exceptions = __webpack_require__(/*! ./Exceptions */ \"./node_modules/jssip/lib/Exceptions.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:Message');\n\nmodule.exports = class Message extends EventEmitter\n{\n  constructor(ua)\n  {\n    super();\n\n    this._ua = ua;\n    this._request = null;\n    this._closed = false;\n\n    this._direction = null;\n    this._local_identity = null;\n    this._remote_identity = null;\n\n    // Whether an incoming message has been replied.\n    this._is_replied = false;\n\n    // Custom message empty object for high level use.\n    this._data = {};\n  }\n\n  get direction()\n  {\n    return this._direction;\n  }\n\n  get local_identity()\n  {\n    return this._local_identity;\n  }\n\n  get remote_identity()\n  {\n    return this._remote_identity;\n  }\n\n  send(target, body, options = {})\n  {\n    const originalTarget = target;\n\n    if (target === undefined || body === undefined)\n    {\n      throw new TypeError('Not enough arguments');\n    }\n\n    // Check target validity.\n    target = this._ua.normalizeTarget(target);\n    if (!target)\n    {\n      throw new TypeError(`Invalid target: ${originalTarget}`);\n    }\n\n    // Get call options.\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const eventHandlers = options.eventHandlers || {};\n    const contentType = options.contentType || 'text/plain';\n\n    // Set event handlers.\n    for (const event in eventHandlers)\n    {\n      if (Object.prototype.hasOwnProperty.call(eventHandlers, event))\n      {\n        this.on(event, eventHandlers[event]);\n      }\n    }\n\n    extraHeaders.push(`Content-Type: ${contentType}`);\n\n    this._request = new SIPMessage.OutgoingRequest(\n      JsSIP_C.MESSAGE, target, this._ua, null, extraHeaders);\n\n    if (body)\n    {\n      this._request.body = body;\n    }\n\n    const request_sender = new RequestSender(this._ua, this._request, {\n      onRequestTimeout : () =>\n      {\n        this._onRequestTimeout();\n      },\n      onTransportError : () =>\n      {\n        this._onTransportError();\n      },\n      onReceiveResponse : (response) =>\n      {\n        this._receiveResponse(response);\n      }\n    });\n\n    this._newMessage('local', this._request);\n\n    request_sender.send();\n  }\n\n  init_incoming(request)\n  {\n    this._request = request;\n\n    this._newMessage('remote', request);\n\n    // Reply with a 200 OK if the user didn't reply.\n    if (!this._is_replied)\n    {\n      this._is_replied = true;\n      request.reply(200);\n    }\n\n    this._close();\n  }\n\n  /**\n   * Accept the incoming Message\n   * Only valid for incoming Messages\n   */\n  accept(options = {})\n  {\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const body = options.body;\n\n    if (this._direction !== 'incoming')\n    {\n      throw new Exceptions.NotSupportedError('\"accept\" not supported for outgoing Message');\n    }\n\n    if (this._is_replied)\n    {\n      throw new Error('incoming Message already replied');\n    }\n\n    this._is_replied = true;\n    this._request.reply(200, null, extraHeaders, body);\n  }\n\n  /**\n   * Reject the incoming Message\n   * Only valid for incoming Messages\n   */\n  reject(options = {})\n  {\n    const status_code = options.status_code || 480;\n    const reason_phrase = options.reason_phrase;\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const body = options.body;\n\n    if (this._direction !== 'incoming')\n    {\n      throw new Exceptions.NotSupportedError('\"reject\" not supported for outgoing Message');\n    }\n\n    if (this._is_replied)\n    {\n      throw new Error('incoming Message already replied');\n    }\n\n    if (status_code < 300 || status_code >= 700)\n    {\n      throw new TypeError(`Invalid status_code: ${status_code}`);\n    }\n\n    this._is_replied = true;\n    this._request.reply(status_code, reason_phrase, extraHeaders, body);\n  }\n\n  _receiveResponse(response)\n  {\n    if (this._closed)\n    {\n      return;\n    }\n    switch (true)\n    {\n      case /^1[0-9]{2}$/.test(response.status_code):\n        // Ignore provisional responses.\n        break;\n\n      case /^2[0-9]{2}$/.test(response.status_code):\n        this._succeeded('remote', response);\n        break;\n\n      default:\n      {\n        const cause = Utils.sipErrorCause(response.status_code);\n\n        this._failed('remote', response, cause);\n        break;\n      }\n    }\n  }\n\n  _onRequestTimeout()\n  {\n    if (this._closed)\n    {\n      return;\n    }\n    this._failed('system', null, JsSIP_C.causes.REQUEST_TIMEOUT);\n  }\n\n  _onTransportError()\n  {\n    if (this._closed)\n    {\n      return;\n    }\n    this._failed('system', null, JsSIP_C.causes.CONNECTION_ERROR);\n  }\n\n  _close()\n  {\n    this._closed = true;\n    this._ua.destroyMessage(this);\n  }\n\n  /**\n   * Internal Callbacks\n   */\n\n  _newMessage(originator, request)\n  {\n    if (originator === 'remote')\n    {\n      this._direction = 'incoming';\n      this._local_identity = request.to;\n      this._remote_identity = request.from;\n    }\n    else if (originator === 'local')\n    {\n      this._direction = 'outgoing';\n      this._local_identity = request.from;\n      this._remote_identity = request.to;\n    }\n\n    this._ua.newMessage(this, {\n      originator,\n      message : this,\n      request\n    });\n  }\n\n  _failed(originator, response, cause)\n  {\n    debug('MESSAGE failed');\n\n    this._close();\n\n    debug('emit \"failed\"');\n\n    this.emit('failed', {\n      originator,\n      response : response || null,\n      cause\n    });\n  }\n\n  _succeeded(originator, response)\n  {\n    debug('MESSAGE succeeded');\n\n    this._close();\n\n    debug('emit \"succeeded\"');\n\n    this.emit('succeeded', {\n      originator,\n      response\n    });\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Message.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/NameAddrHeader.js":
/*!**************************************************!*\
  !*** ./node_modules/jssip/lib/NameAddrHeader.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const URI = __webpack_require__(/*! ./URI */ \"./node_modules/jssip/lib/URI.js\");\nconst Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib/Grammar.js\");\n\nmodule.exports = class NameAddrHeader\n{\n  /**\n   * Parse the given string and returns a NameAddrHeader instance or undefined if\n   * it is an invalid NameAddrHeader.\n   */\n  static parse(name_addr_header)\n  {\n    name_addr_header = Grammar.parse(name_addr_header, 'Name_Addr_Header');\n\n    if (name_addr_header !== -1)\n    {\n      return name_addr_header;\n    }\n    else\n    {\n      return undefined;\n    }\n  }\n\n  constructor(uri, display_name, parameters)\n  {\n    // Checks.\n    if (!uri || !(uri instanceof URI))\n    {\n      throw new TypeError('missing or invalid \"uri\" parameter');\n    }\n\n    // Initialize parameters.\n    this._uri = uri;\n    this._parameters = {};\n    this.display_name = display_name;\n\n    for (const param in parameters)\n    {\n      if (Object.prototype.hasOwnProperty.call(parameters, param))\n      {\n        this.setParam(param, parameters[param]);\n      }\n    }\n  }\n\n  get uri()\n  {\n    return this._uri;\n  }\n\n  get display_name()\n  {\n    return this._display_name;\n  }\n\n  set display_name(value)\n  {\n    this._display_name = (value === 0) ? '0' : value;\n  }\n\n  setParam(key, value)\n  {\n    if (key)\n    {\n      this._parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();\n    }\n  }\n\n  getParam(key)\n  {\n    if (key)\n    {\n      return this._parameters[key.toLowerCase()];\n    }\n  }\n\n  hasParam(key)\n  {\n    if (key)\n    {\n      return (this._parameters.hasOwnProperty(key.toLowerCase()) && true) || false;\n    }\n  }\n\n  deleteParam(parameter)\n  {\n    parameter = parameter.toLowerCase();\n    if (this._parameters.hasOwnProperty(parameter))\n    {\n      const value = this._parameters[parameter];\n\n      delete this._parameters[parameter];\n\n      return value;\n    }\n  }\n\n  clearParams()\n  {\n    this._parameters = {};\n  }\n\n  clone()\n  {\n    return new NameAddrHeader(\n      this._uri.clone(),\n      this._display_name,\n      JSON.parse(JSON.stringify(this._parameters)));\n  }\n\n  _quote(str)\n  {\n    return str\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g, '\\\\\"');\n  }\n\n  toString()\n  {\n    let body = this._display_name ? `\"${this._quote(this._display_name)}\" ` : '';\n\n    body += `<${this._uri.toString()}>`;\n\n    for (const parameter in this._parameters)\n    {\n      if (Object.prototype.hasOwnProperty.call(this._parameters, parameter))\n      {\n        body += `;${parameter}`;\n\n        if (this._parameters[parameter] !== null)\n        {\n          body += `=${this._parameters[parameter]}`;\n        }\n      }\n    }\n\n    return body;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/NameAddrHeader.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Parser.js":
/*!******************************************!*\
  !*** ./node_modules/jssip/lib/Parser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib/Grammar.js\");\nconst SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib/SIPMessage.js\");\nconst debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:ERROR:Parser');\n\ndebugerror.log = console.warn.bind(console);\n\n/**\n * Parse SIP Message\n */\nexports.parseMessage = (data, ua) =>\n{\n  let message;\n  let bodyStart;\n  let headerEnd = data.indexOf('\\r\\n');\n\n  if (headerEnd === -1)\n  {\n    debugerror('parseMessage() | no CRLF found, not a SIP message');\n\n    return;\n  }\n\n  // Parse first line. Check if it is a Request or a Reply.\n  const firstLine = data.substring(0, headerEnd);\n  let parsed = Grammar.parse(firstLine, 'Request_Response');\n\n  if (parsed === -1)\n  {\n    debugerror(`parseMessage() | error parsing first line of SIP message: \"${firstLine}\"`);\n\n    return;\n  }\n  else if (!parsed.status_code)\n  {\n    message = new SIPMessage.IncomingRequest(ua);\n    message.method = parsed.method;\n    message.ruri = parsed.uri;\n  }\n  else\n  {\n    message = new SIPMessage.IncomingResponse();\n    message.status_code = parsed.status_code;\n    message.reason_phrase = parsed.reason_phrase;\n  }\n\n  message.data = data;\n  let headerStart = headerEnd + 2;\n\n  /* Loop over every line in data. Detect the end of each header and parse\n  * it or simply add to the headers collection.\n  */\n  while (true)\n  {\n    headerEnd = getHeader(data, headerStart);\n\n    // The SIP message has normally finished.\n    if (headerEnd === -2)\n    {\n      bodyStart = headerStart + 2;\n      break;\n    }\n    // Data.indexOf returned -1 due to a malformed message.\n    else if (headerEnd === -1)\n    {\n      debugerror('parseMessage() | malformed message');\n\n      return;\n    }\n\n    parsed = parseHeader(message, data, headerStart, headerEnd);\n\n    if (parsed !== true)\n    {\n      debugerror('parseMessage() |', parsed.error);\n\n      return;\n    }\n\n    headerStart = headerEnd + 2;\n  }\n\n  /* RFC3261 18.3.\n   * If there are additional bytes in the transport packet\n   * beyond the end of the body, they MUST be discarded.\n   */\n  if (message.hasHeader('content-length'))\n  {\n    const contentLength = message.getHeader('content-length');\n\n    message.body = data.substr(bodyStart, contentLength);\n  }\n  else\n  {\n    message.body = data.substring(bodyStart);\n  }\n\n  return message;\n};\n\n/**\n * Extract and parse every header of a SIP message.\n */\nfunction getHeader(data, headerStart)\n{\n  // 'start' position of the header.\n  let start = headerStart;\n  // 'end' position of the header.\n  let end = 0;\n  // 'partial end' position of the header.\n  let partialEnd = 0;\n\n  // End of message.\n  if (data.substring(start, start + 2).match(/(^\\r\\n)/))\n  {\n    return -2;\n  }\n\n  while (end === 0)\n  {\n    // Partial End of Header.\n    partialEnd = data.indexOf('\\r\\n', start);\n\n    // 'indexOf' returns -1 if the value to be found never occurs.\n    if (partialEnd === -1)\n    {\n      return partialEnd;\n    }\n\n    if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/))\n    {\n      // Not the end of the message. Continue from the next position.\n      start = partialEnd + 2;\n    }\n    else\n    {\n      end = partialEnd;\n    }\n  }\n\n  return end;\n}\n\nfunction parseHeader(message, data, headerStart, headerEnd)\n{\n  let parsed;\n  const hcolonIndex = data.indexOf(':', headerStart);\n  const headerName = data.substring(headerStart, hcolonIndex).trim();\n  const headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();\n\n  // If header-field is well-known, parse it.\n  switch (headerName.toLowerCase())\n  {\n    case 'via':\n    case 'v':\n      message.addHeader('via', headerValue);\n      if (message.getHeaders('via').length === 1)\n      {\n        parsed = message.parseHeader('Via');\n        if (parsed)\n        {\n          message.via = parsed;\n          message.via_branch = parsed.branch;\n        }\n      }\n      else\n      {\n        parsed = 0;\n      }\n      break;\n    case 'from':\n    case 'f':\n      message.setHeader('from', headerValue);\n      parsed = message.parseHeader('from');\n      if (parsed)\n      {\n        message.from = parsed;\n        message.from_tag = parsed.getParam('tag');\n      }\n      break;\n    case 'to':\n    case 't':\n      message.setHeader('to', headerValue);\n      parsed = message.parseHeader('to');\n      if (parsed)\n      {\n        message.to = parsed;\n        message.to_tag = parsed.getParam('tag');\n      }\n      break;\n    case 'record-route':\n      parsed = Grammar.parse(headerValue, 'Record_Route');\n\n      if (parsed === -1)\n      {\n        parsed = undefined;\n      }\n      else\n      {\n        for (const header of parsed)\n        {\n          message.addHeader('record-route', headerValue.substring(header.possition, header.offset));\n          message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n        }\n      }\n      break;\n    case 'call-id':\n    case 'i':\n      message.setHeader('call-id', headerValue);\n      parsed = message.parseHeader('call-id');\n      if (parsed)\n      {\n        message.call_id = headerValue;\n      }\n      break;\n    case 'contact':\n    case 'm':\n      parsed = Grammar.parse(headerValue, 'Contact');\n\n      if (parsed === -1)\n      {\n        parsed = undefined;\n      }\n      else\n      {\n        for (const header of parsed)\n        {\n          message.addHeader('contact', headerValue.substring(header.possition, header.offset));\n          message.headers.Contact[message.getHeaders('contact').length - 1].parsed = header.parsed;\n        }\n      }\n      break;\n    case 'content-length':\n    case 'l':\n      message.setHeader('content-length', headerValue);\n      parsed = message.parseHeader('content-length');\n      break;\n    case 'content-type':\n    case 'c':\n      message.setHeader('content-type', headerValue);\n      parsed = message.parseHeader('content-type');\n      break;\n    case 'cseq':\n      message.setHeader('cseq', headerValue);\n      parsed = message.parseHeader('cseq');\n      if (parsed)\n      {\n        message.cseq = parsed.value;\n      }\n      if (message instanceof SIPMessage.IncomingResponse)\n      {\n        message.method = parsed.method;\n      }\n      break;\n    case 'max-forwards':\n      message.setHeader('max-forwards', headerValue);\n      parsed = message.parseHeader('max-forwards');\n      break;\n    case 'www-authenticate':\n      message.setHeader('www-authenticate', headerValue);\n      parsed = message.parseHeader('www-authenticate');\n      break;\n    case 'proxy-authenticate':\n      message.setHeader('proxy-authenticate', headerValue);\n      parsed = message.parseHeader('proxy-authenticate');\n      break;\n    case 'session-expires':\n    case 'x':\n      message.setHeader('session-expires', headerValue);\n      parsed = message.parseHeader('session-expires');\n      if (parsed)\n      {\n        message.session_expires = parsed.expires;\n        message.session_expires_refresher = parsed.refresher;\n      }\n      break;\n    case 'refer-to':\n    case 'r':\n      message.setHeader('refer-to', headerValue);\n      parsed = message.parseHeader('refer-to');\n      if (parsed)\n      {\n        message.refer_to = parsed;\n      }\n      break;\n    case 'replaces':\n      message.setHeader('replaces', headerValue);\n      parsed = message.parseHeader('replaces');\n      if (parsed)\n      {\n        message.replaces = parsed;\n      }\n      break;\n    case 'event':\n    case 'o':\n      message.setHeader('event', headerValue);\n      parsed = message.parseHeader('event');\n      if (parsed)\n      {\n        message.event = parsed;\n      }\n      break;\n    default:\n      // Do not parse this header.\n      message.addHeader(headerName, headerValue);\n      parsed = 0;\n  }\n\n  if (parsed === undefined)\n  {\n    return {\n      error : `error parsing header \"${headerName}\"`\n    };\n  }\n  else\n  {\n    return true;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Parser.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/RTCSession.js":
/*!**********************************************!*\
  !*** ./node_modules/jssip/lib/RTCSession.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* globals RTCPeerConnection: false, RTCSessionDescription: false */\n\nconst EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nconst sdp_transform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nconst JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst Exceptions = __webpack_require__(/*! ./Exceptions */ \"./node_modules/jssip/lib/Exceptions.js\");\nconst Transactions = __webpack_require__(/*! ./Transactions */ \"./node_modules/jssip/lib/Transactions.js\");\nconst Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst Timers = __webpack_require__(/*! ./Timers */ \"./node_modules/jssip/lib/Timers.js\");\nconst SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib/SIPMessage.js\");\nconst Dialog = __webpack_require__(/*! ./Dialog */ \"./node_modules/jssip/lib/Dialog.js\");\nconst RequestSender = __webpack_require__(/*! ./RequestSender */ \"./node_modules/jssip/lib/RequestSender.js\");\nconst RTCSession_DTMF = __webpack_require__(/*! ./RTCSession/DTMF */ \"./node_modules/jssip/lib/RTCSession/DTMF.js\");\nconst RTCSession_Info = __webpack_require__(/*! ./RTCSession/Info */ \"./node_modules/jssip/lib/RTCSession/Info.js\");\nconst RTCSession_ReferNotifier = __webpack_require__(/*! ./RTCSession/ReferNotifier */ \"./node_modules/jssip/lib/RTCSession/ReferNotifier.js\");\nconst RTCSession_ReferSubscriber = __webpack_require__(/*! ./RTCSession/ReferSubscriber */ \"./node_modules/jssip/lib/RTCSession/ReferSubscriber.js\");\nconst URI = __webpack_require__(/*! ./URI */ \"./node_modules/jssip/lib/URI.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:RTCSession');\nconst debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:ERROR:RTCSession');\n\ndebugerror.log = console.warn.bind(console);\n\nconst C = {\n  // RTCSession states.\n  STATUS_NULL               : 0,\n  STATUS_INVITE_SENT        : 1,\n  STATUS_1XX_RECEIVED       : 2,\n  STATUS_INVITE_RECEIVED    : 3,\n  STATUS_WAITING_FOR_ANSWER : 4,\n  STATUS_ANSWERED           : 5,\n  STATUS_WAITING_FOR_ACK    : 6,\n  STATUS_CANCELED           : 7,\n  STATUS_TERMINATED         : 8,\n  STATUS_CONFIRMED          : 9\n};\n\n/**\n * Local variables.\n */\nconst holdMediaTypes = [ 'audio', 'video' ];\n\nmodule.exports = class RTCSession extends EventEmitter\n{\n  /**\n   * Expose C object.\n   */\n  static get C()\n  {\n    return C;\n  }\n\n  constructor(ua)\n  {\n    debug('new');\n\n    super();\n\n    this._id = null;\n    this._ua = ua;\n    this._status = C.STATUS_NULL;\n    this._dialog = null;\n    this._earlyDialogs = {};\n    this._contact = null;\n    this._from_tag = null;\n    this._to_tag = null;\n\n    // The RTCPeerConnection instance (public attribute).\n    this._connection = null;\n\n    // Prevent races on serial PeerConnction operations.\n    this._connectionPromiseQueue = Promise.resolve();\n\n    // Incoming/Outgoing request being currently processed.\n    this._request = null;\n\n    // Cancel state for initial outgoing request.\n    this._is_canceled = false;\n    this._cancel_reason = '';\n\n    // RTCSession confirmation flag.\n    this._is_confirmed = false;\n\n    // Is late SDP being negotiated.\n    this._late_sdp = false;\n\n    // Default rtcOfferConstraints and rtcAnswerConstrainsts (passed in connect() or answer()).\n    this._rtcOfferConstraints = null;\n    this._rtcAnswerConstraints = null;\n\n    // Local MediaStream.\n    this._localMediaStream = null;\n    this._localMediaStreamLocallyGenerated = false;\n\n    // Flag to indicate PeerConnection ready for new actions.\n    this._rtcReady = true;\n\n    // SIP Timers.\n    this._timers = {\n      ackTimer          : null,\n      expiresTimer      : null,\n      invite2xxTimer    : null,\n      userNoAnswerTimer : null\n    };\n\n    // Session info.\n    this._direction = null;\n    this._local_identity = null;\n    this._remote_identity = null;\n    this._start_time = null;\n    this._end_time = null;\n    this._tones = null;\n\n    // Mute/Hold state.\n    this._audioMuted = false;\n    this._videoMuted = false;\n    this._localHold = false;\n    this._remoteHold = false;\n\n    // Session Timers (RFC 4028).\n    this._sessionTimers = {\n      enabled        : this._ua.configuration.session_timers,\n      refreshMethod  : this._ua.configuration.session_timers_refresh_method,\n      defaultExpires : JsSIP_C.SESSION_EXPIRES,\n      currentExpires : null,\n      running        : false,\n      refresher      : false,\n      timer          : null // A setTimeout.\n    };\n\n    // Map of ReferSubscriber instances indexed by the REFER's CSeq number.\n    this._referSubscribers = {};\n\n    // Custom session empty object for high level use.\n    this._data = {};\n  }\n\n  /**\n   * User API\n   */\n\n  // Expose RTCSession constants as a property of the RTCSession instance.\n  get C()\n  {\n    return C;\n  }\n\n  // Expose session failed/ended causes as a property of the RTCSession instance.\n  get causes()\n  {\n    return JsSIP_C.causes;\n  }\n\n  get id()\n  {\n    return this._id;\n  }\n\n  get connection()\n  {\n    return this._connection;\n  }\n\n  get contact()\n  {\n    return this._contact;\n  }\n\n  get direction()\n  {\n    return this._direction;\n  }\n\n  get local_identity()\n  {\n    return this._local_identity;\n  }\n\n  get remote_identity()\n  {\n    return this._remote_identity;\n  }\n\n  get start_time()\n  {\n    return this._start_time;\n  }\n\n  get end_time()\n  {\n    return this._end_time;\n  }\n\n  get data()\n  {\n    return this._data;\n  }\n\n  set data(_data)\n  {\n    this._data = _data;\n  }\n\n  get status()\n  {\n    return this._status;\n  }\n\n  isInProgress()\n  {\n    switch (this._status)\n    {\n      case C.STATUS_NULL:\n      case C.STATUS_INVITE_SENT:\n      case C.STATUS_1XX_RECEIVED:\n      case C.STATUS_INVITE_RECEIVED:\n      case C.STATUS_WAITING_FOR_ANSWER:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  isEstablished()\n  {\n    switch (this._status)\n    {\n      case C.STATUS_ANSWERED:\n      case C.STATUS_WAITING_FOR_ACK:\n      case C.STATUS_CONFIRMED:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  isEnded()\n  {\n    switch (this._status)\n    {\n      case C.STATUS_CANCELED:\n      case C.STATUS_TERMINATED:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  isMuted()\n  {\n    return {\n      audio : this._audioMuted,\n      video : this._videoMuted\n    };\n  }\n\n  isOnHold()\n  {\n    return {\n      local  : this._localHold,\n      remote : this._remoteHold\n    };\n  }\n\n  connect(target, options = {}, initCallback)\n  {\n    debug('connect()');\n\n    const originalTarget = target;\n    const eventHandlers = options.eventHandlers || {};\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const mediaConstraints = options.mediaConstraints || { audio: true, video: true };\n    const mediaStream = options.mediaStream || null;\n    const pcConfig = options.pcConfig || { iceServers: [] };\n    const rtcConstraints = options.rtcConstraints || null;\n    const rtcOfferConstraints = options.rtcOfferConstraints || null;\n\n    this._rtcOfferConstraints = rtcOfferConstraints;\n    this._rtcAnswerConstraints = options.rtcAnswerConstraints || null;\n\n    this._data = options.data || this._data;\n\n    // Check target.\n    if (target === undefined)\n    {\n      throw new TypeError('Not enough arguments');\n    }\n\n    // Check Session Status.\n    if (this._status !== C.STATUS_NULL)\n    {\n      throw new Exceptions.InvalidStateError(this._status);\n    }\n\n    // Check WebRTC support.\n    if (!window.RTCPeerConnection)\n    {\n      throw new Exceptions.NotSupportedError('WebRTC not supported');\n    }\n\n    // Check target validity.\n    target = this._ua.normalizeTarget(target);\n    if (!target)\n    {\n      throw new TypeError(`Invalid target: ${originalTarget}`);\n    }\n\n    // Session Timers.\n    if (this._sessionTimers.enabled)\n    {\n      if (Utils.isDecimal(options.sessionTimersExpires))\n      {\n        if (options.sessionTimersExpires >= JsSIP_C.MIN_SESSION_EXPIRES)\n        {\n          this._sessionTimers.defaultExpires = options.sessionTimersExpires;\n        }\n        else\n        {\n          this._sessionTimers.defaultExpires = JsSIP_C.SESSION_EXPIRES;\n        }\n      }\n    }\n\n    // Set event handlers.\n    for (const event in eventHandlers)\n    {\n      if (Object.prototype.hasOwnProperty.call(eventHandlers, event))\n      {\n        this.on(event, eventHandlers[event]);\n      }\n    }\n\n    // Session parameter initialization.\n    this._from_tag = Utils.newTag();\n\n    // Set anonymous property.\n    const anonymous = options.anonymous || false;\n\n    const requestParams = { from_tag: this._from_tag };\n\n    this._contact = this._ua.contact.toString({\n      anonymous,\n      outbound : true\n    });\n\n    if (anonymous)\n    {\n      requestParams.from_display_name = 'Anonymous';\n      requestParams.from_uri = new URI('sip', 'anonymous', 'anonymous.invalid');\n\n      extraHeaders.push(`P-Preferred-Identity: ${this._ua.configuration.uri.toString()}`);\n      extraHeaders.push('Privacy: id');\n    }\n\n    extraHeaders.push(`Contact: ${this._contact}`);\n    extraHeaders.push('Content-Type: application/sdp');\n    if (this._sessionTimers.enabled)\n    {\n      extraHeaders.push(`Session-Expires: ${this._sessionTimers.defaultExpires}`);\n    }\n\n    this._request = new SIPMessage.InitialOutgoingInviteRequest(\n      target, this._ua, requestParams, extraHeaders);\n\n    this._id = this._request.call_id + this._from_tag;\n\n    // Create a new RTCPeerConnection instance.\n    this._createRTCConnection(pcConfig, rtcConstraints);\n\n    // Set internal properties.\n    this._direction = 'outgoing';\n    this._local_identity = this._request.from;\n    this._remote_identity = this._request.to;\n\n    // User explicitly provided a newRTCSession callback for this session.\n    if (initCallback)\n    {\n      initCallback(this);\n    }\n\n    this._newRTCSession('local', this._request);\n\n    this._sendInitialRequest(mediaConstraints, rtcOfferConstraints, mediaStream);\n  }\n\n  init_incoming(request, initCallback)\n  {\n    debug('init_incoming()');\n\n    let expires;\n    const contentType = request.getHeader('Content-Type');\n\n    // Check body and content type.\n    if (request.body && (contentType !== 'application/sdp'))\n    {\n      request.reply(415);\n\n      return;\n    }\n\n    // Session parameter initialization.\n    this._status = C.STATUS_INVITE_RECEIVED;\n    this._from_tag = request.from_tag;\n    this._id = request.call_id + this._from_tag;\n    this._request = request;\n    this._contact = this._ua.contact.toString();\n\n    // Get the Expires header value if exists.\n    if (request.hasHeader('expires'))\n    {\n      expires = request.getHeader('expires') * 1000;\n    }\n\n    /* Set the to_tag before\n     * replying a response code that will create a dialog.\n     */\n    request.to_tag = Utils.newTag();\n\n    // An error on dialog creation will fire 'failed' event.\n    if (! this._createDialog(request, 'UAS', true))\n    {\n      request.reply(500, 'Missing Contact header field');\n\n      return;\n    }\n\n    if (request.body)\n    {\n      this._late_sdp = false;\n    }\n    else\n    {\n      this._late_sdp = true;\n    }\n\n    this._status = C.STATUS_WAITING_FOR_ANSWER;\n\n    // Set userNoAnswerTimer.\n    this._timers.userNoAnswerTimer = setTimeout(() =>\n    {\n      request.reply(408);\n      this._failed('local', null, JsSIP_C.causes.NO_ANSWER);\n    }, this._ua.configuration.no_answer_timeout\n    );\n\n    /* Set expiresTimer\n     * RFC3261 13.3.1\n     */\n    if (expires)\n    {\n      this._timers.expiresTimer = setTimeout(() =>\n      {\n        if (this._status === C.STATUS_WAITING_FOR_ANSWER)\n        {\n          request.reply(487);\n          this._failed('system', null, JsSIP_C.causes.EXPIRES);\n        }\n      }, expires\n      );\n    }\n\n    // Set internal properties.\n    this._direction = 'incoming';\n    this._local_identity = request.to;\n    this._remote_identity = request.from;\n\n    // A init callback was specifically defined.\n    if (initCallback)\n    {\n      initCallback(this);\n    }\n\n    // Fire 'newRTCSession' event.\n    this._newRTCSession('remote', request);\n\n    // The user may have rejected the call in the 'newRTCSession' event.\n    if (this._status === C.STATUS_TERMINATED)\n    {\n      return;\n    }\n\n    // Reply 180.\n    request.reply(180, null, [ `Contact: ${this._contact}` ]);\n\n    // Fire 'progress' event.\n    // TODO: Document that 'response' field in 'progress' event is null for incoming calls.\n    this._progress('local', null);\n  }\n\n  /**\n   * Answer the call.\n   */\n  answer(options = {})\n  {\n    debug('answer()');\n\n    const request = this._request;\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const mediaConstraints = options.mediaConstraints || {};\n    const mediaStream = options.mediaStream || null;\n    const pcConfig = options.pcConfig || { iceServers: [] };\n    const rtcConstraints = options.rtcConstraints || null;\n    const rtcAnswerConstraints = options.rtcAnswerConstraints || null;\n\n    let tracks;\n    let peerHasAudioLine = false;\n    let peerHasVideoLine = false;\n    let peerOffersFullAudio = false;\n    let peerOffersFullVideo = false;\n\n    this._rtcAnswerConstraints = rtcAnswerConstraints;\n    this._rtcOfferConstraints = options.rtcOfferConstraints || null;\n\n    this._data = options.data || this._data;\n\n    // Check Session Direction and Status.\n    if (this._direction !== 'incoming')\n    {\n      throw new Exceptions.NotSupportedError('\"answer\" not supported for outgoing RTCSession');\n    }\n\n    // Check Session status.\n    if (this._status !== C.STATUS_WAITING_FOR_ANSWER)\n    {\n      throw new Exceptions.InvalidStateError(this._status);\n    }\n\n    // Session Timers.\n    if (this._sessionTimers.enabled)\n    {\n      if (Utils.isDecimal(options.sessionTimersExpires))\n      {\n        if (options.sessionTimersExpires >= JsSIP_C.MIN_SESSION_EXPIRES)\n        {\n          this._sessionTimers.defaultExpires = options.sessionTimersExpires;\n        }\n        else\n        {\n          this._sessionTimers.defaultExpires = JsSIP_C.SESSION_EXPIRES;\n        }\n      }\n    }\n\n    this._status = C.STATUS_ANSWERED;\n\n    // An error on dialog creation will fire 'failed' event.\n    if (! this._createDialog(request, 'UAS'))\n    {\n      request.reply(500, 'Error creating dialog');\n\n      return;\n    }\n\n    clearTimeout(this._timers.userNoAnswerTimer);\n\n    extraHeaders.unshift(`Contact: ${this._contact}`);\n\n    // Determine incoming media from incoming SDP offer (if any).\n    const sdp = request.parseSDP();\n\n    // Make sure sdp.media is an array, not the case if there is only one media.\n    if (! Array.isArray(sdp.media))\n    {\n      sdp.media = [ sdp.media ];\n    }\n\n    // Go through all medias in SDP to find offered capabilities to answer with.\n    for (const m of sdp.media)\n    {\n      if (m.type === 'audio')\n      {\n        peerHasAudioLine = true;\n        if (!m.direction || m.direction === 'sendrecv')\n        {\n          peerOffersFullAudio = true;\n        }\n      }\n      if (m.type === 'video')\n      {\n        peerHasVideoLine = true;\n        if (!m.direction || m.direction === 'sendrecv')\n        {\n          peerOffersFullVideo = true;\n        }\n      }\n    }\n\n    // Remove audio from mediaStream if suggested by mediaConstraints.\n    if (mediaStream && mediaConstraints.audio === false)\n    {\n      tracks = mediaStream.getAudioTracks();\n      for (const track of tracks)\n      {\n        mediaStream.removeTrack(track);\n      }\n    }\n\n    // Remove video from mediaStream if suggested by mediaConstraints.\n    if (mediaStream && mediaConstraints.video === false)\n    {\n      tracks = mediaStream.getVideoTracks();\n      for (const track of tracks)\n      {\n        mediaStream.removeTrack(track);\n      }\n    }\n\n    // Set audio constraints based on incoming stream if not supplied.\n    if (!mediaStream && mediaConstraints.audio === undefined)\n    {\n      mediaConstraints.audio = peerOffersFullAudio;\n    }\n\n    // Set video constraints based on incoming stream if not supplied.\n    if (!mediaStream && mediaConstraints.video === undefined)\n    {\n      mediaConstraints.video = peerOffersFullVideo;\n    }\n\n    // Don't ask for audio if the incoming offer has no audio section.\n    if (!mediaStream && !peerHasAudioLine)\n    {\n      mediaConstraints.audio = false;\n    }\n\n    // Don't ask for video if the incoming offer has no video section.\n    if (!mediaStream && !peerHasVideoLine)\n    {\n      mediaConstraints.video = false;\n    }\n\n    // Create a new RTCPeerConnection instance.\n    // TODO: This may throw an error, should react.\n    this._createRTCConnection(pcConfig, rtcConstraints);\n\n    Promise.resolve()\n      // Handle local MediaStream.\n      .then(() =>\n      {\n        // A local MediaStream is given, use it.\n        if (mediaStream)\n        {\n          return mediaStream;\n        }\n\n        // Audio and/or video requested, prompt getUserMedia.\n        else if (mediaConstraints.audio || mediaConstraints.video)\n        {\n          this._localMediaStreamLocallyGenerated = true;\n\n          return navigator.mediaDevices.getUserMedia(mediaConstraints)\n            .catch((error) =>\n            {\n              if (this._status === C.STATUS_TERMINATED)\n              {\n                throw new Error('terminated');\n              }\n\n              request.reply(480);\n              this._failed('local', null, JsSIP_C.causes.USER_DENIED_MEDIA_ACCESS);\n\n              debugerror('emit \"getusermediafailed\" [error:%o]', error);\n\n              this.emit('getusermediafailed', error);\n\n              throw new Error('getUserMedia() failed');\n            });\n        }\n      })\n      // Attach MediaStream to RTCPeerconnection.\n      .then((stream) =>\n      {\n        if (this._status === C.STATUS_TERMINATED)\n        {\n          throw new Error('terminated');\n        }\n\n        this._localMediaStream = stream;\n        if (stream)\n        {\n          stream.getTracks().forEach((track) =>\n          {\n            this._connection.addTrack(track, stream);\n          });\n        }\n      })\n      // Set remote description.\n      .then(() =>\n      {\n        if (this._late_sdp)\n        {\n          return;\n        }\n\n        const e = { originator: 'remote', type: 'offer', sdp: request.body };\n\n        debug('emit \"sdp\"');\n        this.emit('sdp', e);\n\n        const offer = new RTCSessionDescription({ type: 'offer', sdp: e.sdp });\n\n        this._connectionPromiseQueue = this._connectionPromiseQueue\n          .then(() => this._connection.setRemoteDescription(offer))\n          .catch((error) =>\n          {\n            request.reply(488);\n\n            this._failed('system', null, JsSIP_C.causes.WEBRTC_ERROR);\n\n            debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n            this.emit('peerconnection:setremotedescriptionfailed', error);\n\n            throw new Error('peerconnection.setRemoteDescription() failed');\n          });\n\n        return this._connectionPromiseQueue;\n      })\n      // Create local description.\n      .then(() =>\n      {\n        if (this._status === C.STATUS_TERMINATED)\n        {\n          throw new Error('terminated');\n        }\n\n        // TODO: Is this event already useful?\n        this._connecting(request);\n\n        if (! this._late_sdp)\n        {\n          return this._createLocalDescription('answer', rtcAnswerConstraints)\n            .catch(() =>\n            {\n              request.reply(500);\n\n              throw new Error('_createLocalDescription() failed');\n            });\n        }\n        else\n        {\n          return this._createLocalDescription('offer', this._rtcOfferConstraints)\n            .catch(() =>\n            {\n              request.reply(500);\n\n              throw new Error('_createLocalDescription() failed');\n            });\n        }\n      })\n      // Send reply.\n      .then((desc) =>\n      {\n        if (this._status === C.STATUS_TERMINATED)\n        {\n          throw new Error('terminated');\n        }\n\n        this._handleSessionTimersInIncomingRequest(request, extraHeaders);\n\n        request.reply(200, null, extraHeaders,\n          desc,\n          () =>\n          {\n            this._status = C.STATUS_WAITING_FOR_ACK;\n\n            this._setInvite2xxTimer(request, desc);\n            this._setACKTimer();\n            this._accepted('local');\n          },\n          () =>\n          {\n            this._failed('system', null, JsSIP_C.causes.CONNECTION_ERROR);\n          }\n        );\n      })\n      .catch((error) =>\n      {\n        if (this._status === C.STATUS_TERMINATED)\n        {\n          return;\n        }\n\n        debugerror(error);\n      });\n  }\n\n  /**\n   * Terminate the call.\n   */\n  terminate(options = {})\n  {\n    debug('terminate()');\n\n    const cause = options.cause || JsSIP_C.causes.BYE;\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const body = options.body;\n\n    let cancel_reason;\n    let status_code = options.status_code;\n    let reason_phrase = options.reason_phrase;\n\n    // Check Session Status.\n    if (this._status === C.STATUS_TERMINATED)\n    {\n      throw new Exceptions.InvalidStateError(this._status);\n    }\n\n    switch (this._status)\n    {\n      // - UAC -\n      case C.STATUS_NULL:\n      case C.STATUS_INVITE_SENT:\n      case C.STATUS_1XX_RECEIVED:\n        debug('canceling session');\n\n        if (status_code && (status_code < 200 || status_code >= 700))\n        {\n          throw new TypeError(`Invalid status_code: ${status_code}`);\n        }\n        else if (status_code)\n        {\n          reason_phrase = reason_phrase || JsSIP_C.REASON_PHRASE[status_code] || '';\n          cancel_reason = `SIP ;cause=${status_code} ;text=\"${reason_phrase}\"`;\n        }\n\n        // Check Session Status.\n        if (this._status === C.STATUS_NULL || this._status === C.STATUS_INVITE_SENT)\n        {\n          this._is_canceled = true;\n          this._cancel_reason = cancel_reason;\n        }\n        else if (this._status === C.STATUS_1XX_RECEIVED)\n        {\n          this._request.cancel(cancel_reason);\n        }\n\n        this._status = C.STATUS_CANCELED;\n\n        this._failed('local', null, JsSIP_C.causes.CANCELED);\n        break;\n\n        // - UAS -\n      case C.STATUS_WAITING_FOR_ANSWER:\n      case C.STATUS_ANSWERED:\n        debug('rejecting session');\n\n        status_code = status_code || 480;\n\n        if (status_code < 300 || status_code >= 700)\n        {\n          throw new TypeError(`Invalid status_code: ${status_code}`);\n        }\n\n        this._request.reply(status_code, reason_phrase, extraHeaders, body);\n        this._failed('local', null, JsSIP_C.causes.REJECTED);\n        break;\n\n      case C.STATUS_WAITING_FOR_ACK:\n      case C.STATUS_CONFIRMED:\n        debug('terminating session');\n\n        reason_phrase = options.reason_phrase || JsSIP_C.REASON_PHRASE[status_code] || '';\n\n        if (status_code && (status_code < 200 || status_code >= 700))\n        {\n          throw new TypeError(`Invalid status_code: ${status_code}`);\n        }\n        else if (status_code)\n        {\n          extraHeaders.push(`Reason: SIP ;cause=${status_code}; text=\"${reason_phrase}\"`);\n        }\n\n        /* RFC 3261 section 15 (Terminating a session):\n          *\n          * \"...the callee's UA MUST NOT send a BYE on a confirmed dialog\n          * until it has received an ACK for its 2xx response or until the server\n          * transaction times out.\"\n          */\n        if (this._status === C.STATUS_WAITING_FOR_ACK &&\n            this._direction === 'incoming' &&\n            this._request.server_transaction.state !== Transactions.C.STATUS_TERMINATED)\n        {\n\n          // Save the dialog for later restoration.\n          const dialog = this._dialog;\n\n          // Send the BYE as soon as the ACK is received...\n          this.receiveRequest = ({ method }) =>\n          {\n            if (method === JsSIP_C.ACK)\n            {\n              this.sendRequest(JsSIP_C.BYE, {\n                extraHeaders,\n                body\n              });\n              dialog.terminate();\n            }\n          };\n\n          // .., or when the INVITE transaction times out\n          this._request.server_transaction.on('stateChanged', () =>\n          {\n            if (this._request.server_transaction.state ===\n                Transactions.C.STATUS_TERMINATED)\n            {\n              this.sendRequest(JsSIP_C.BYE, {\n                extraHeaders,\n                body\n              });\n              dialog.terminate();\n            }\n          });\n\n          this._ended('local', null, cause);\n\n          // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-).\n          this._dialog = dialog;\n\n          // Restore the dialog into 'ua' so the ACK can reach 'this' session.\n          this._ua.newDialog(dialog);\n        }\n        else\n        {\n          this.sendRequest(JsSIP_C.BYE, {\n            extraHeaders,\n            body\n          });\n\n          this._ended('local', null, cause);\n        }\n    }\n  }\n\n  sendDTMF(tones, options = {})\n  {\n    debug('sendDTMF() | tones: %s', tones);\n\n    let position = 0;\n    let duration = options.duration || null;\n    let interToneGap = options.interToneGap || null;\n\n    if (tones === undefined)\n    {\n      throw new TypeError('Not enough arguments');\n    }\n\n    // Check Session Status.\n    if (this._status !== C.STATUS_CONFIRMED && this._status !== C.STATUS_WAITING_FOR_ACK)\n    {\n      throw new Exceptions.InvalidStateError(this._status);\n    }\n\n    // Convert to string.\n    if (typeof tones === 'number')\n    {\n      tones = tones.toString();\n    }\n\n    // Check tones.\n    if (!tones || typeof tones !== 'string' || !tones.match(/^[0-9A-DR#*,]+$/i))\n    {\n      throw new TypeError(`Invalid tones: ${tones}`);\n    }\n\n    // Check duration.\n    if (duration && !Utils.isDecimal(duration))\n    {\n      throw new TypeError(`Invalid tone duration: ${duration}`);\n    }\n    else if (!duration)\n    {\n      duration = RTCSession_DTMF.C.DEFAULT_DURATION;\n    }\n    else if (duration < RTCSession_DTMF.C.MIN_DURATION)\n    {\n      debug(`\"duration\" value is lower than the minimum allowed, setting it to ${RTCSession_DTMF.C.MIN_DURATION} milliseconds`);\n      duration = RTCSession_DTMF.C.MIN_DURATION;\n    }\n    else if (duration > RTCSession_DTMF.C.MAX_DURATION)\n    {\n      debug(`\"duration\" value is greater than the maximum allowed, setting it to ${RTCSession_DTMF.C.MAX_DURATION} milliseconds`);\n      duration = RTCSession_DTMF.C.MAX_DURATION;\n    }\n    else\n    {\n      duration = Math.abs(duration);\n    }\n    options.duration = duration;\n\n    // Check interToneGap.\n    if (interToneGap && !Utils.isDecimal(interToneGap))\n    {\n      throw new TypeError(`Invalid interToneGap: ${interToneGap}`);\n    }\n    else if (!interToneGap)\n    {\n      interToneGap = RTCSession_DTMF.C.DEFAULT_INTER_TONE_GAP;\n    }\n    else if (interToneGap < RTCSession_DTMF.C.MIN_INTER_TONE_GAP)\n    {\n      debug(`\"interToneGap\" value is lower than the minimum allowed, setting it to ${RTCSession_DTMF.C.MIN_INTER_TONE_GAP} milliseconds`);\n      interToneGap = RTCSession_DTMF.C.MIN_INTER_TONE_GAP;\n    }\n    else\n    {\n      interToneGap = Math.abs(interToneGap);\n    }\n\n    if (this._tones)\n    {\n      // Tones are already queued, just add to the queue.\n      this._tones += tones;\n\n      return;\n    }\n\n    this._tones = tones;\n\n    // Send the first tone.\n    _sendDTMF.call(this);\n\n    function _sendDTMF()\n    {\n      let timeout;\n\n      if (this._status === C.STATUS_TERMINATED ||\n          !this._tones || position >= this._tones.length)\n      {\n        // Stop sending DTMF.\n        this._tones = null;\n\n        return;\n      }\n\n      const tone = this._tones[position];\n\n      position += 1;\n\n      if (tone === ',')\n      {\n        timeout = 2000;\n      }\n      else\n      {\n        const dtmf = new RTCSession_DTMF(this);\n\n        options.eventHandlers = {\n          onFailed : () => { this._tones = null; }\n        };\n        dtmf.send(tone, options);\n        timeout = duration + interToneGap;\n      }\n\n      // Set timeout for the next tone.\n      setTimeout(_sendDTMF.bind(this), timeout);\n    }\n  }\n\n  sendInfo(contentType, body, options = {})\n  {\n    debug('sendInfo()');\n\n    // Check Session Status.\n    if (this._status !== C.STATUS_CONFIRMED && this._status !== C.STATUS_WAITING_FOR_ACK)\n    {\n      throw new Exceptions.InvalidStateError(this._status);\n    }\n\n    const info = new RTCSession_Info(this);\n\n    info.send(contentType, body, options);\n  }\n\n  /**\n   * Mute\n   */\n  mute(options = { audio: true, video: false })\n  {\n    debug('mute()');\n\n    let audioMuted = false, videoMuted = false;\n\n    if (this._audioMuted === false && options.audio)\n    {\n      audioMuted = true;\n      this._audioMuted = true;\n      this._toggleMuteAudio(true);\n    }\n\n    if (this._videoMuted === false && options.video)\n    {\n      videoMuted = true;\n      this._videoMuted = true;\n      this._toggleMuteVideo(true);\n    }\n\n    if (audioMuted === true || videoMuted === true)\n    {\n      this._onmute({\n        audio : audioMuted,\n        video : videoMuted\n      });\n    }\n  }\n\n  /**\n   * Unmute\n   */\n  unmute(options = { audio: true, video: true })\n  {\n    debug('unmute()');\n\n    let audioUnMuted = false, videoUnMuted = false;\n\n    if (this._audioMuted === true && options.audio)\n    {\n      audioUnMuted = true;\n      this._audioMuted = false;\n\n      if (this._localHold === false)\n      {\n        this._toggleMuteAudio(false);\n      }\n    }\n\n    if (this._videoMuted === true && options.video)\n    {\n      videoUnMuted = true;\n      this._videoMuted = false;\n\n      if (this._localHold === false)\n      {\n        this._toggleMuteVideo(false);\n      }\n    }\n\n    if (audioUnMuted === true || videoUnMuted === true)\n    {\n      this._onunmute({\n        audio : audioUnMuted,\n        video : videoUnMuted\n      });\n    }\n  }\n\n  /**\n   * Hold\n   */\n  hold(options = {}, done)\n  {\n    debug('hold()');\n\n    if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED)\n    {\n      return false;\n    }\n\n    if (this._localHold === true)\n    {\n      return false;\n    }\n\n    if (! this._isReadyToReOffer())\n    {\n      return false;\n    }\n\n    this._localHold = true;\n    this._onhold('local');\n\n    const eventHandlers = {\n      succeeded : () =>\n      {\n        if (done) { done(); }\n      },\n      failed : () =>\n      {\n        this.terminate({\n          cause         : JsSIP_C.causes.WEBRTC_ERROR,\n          status_code   : 500,\n          reason_phrase : 'Hold Failed'\n        });\n      }\n    };\n\n    if (options.useUpdate)\n    {\n      this._sendUpdate({\n        sdpOffer     : true,\n        eventHandlers,\n        extraHeaders : options.extraHeaders\n      });\n    }\n    else\n    {\n      this._sendReinvite({\n        eventHandlers,\n        extraHeaders : options.extraHeaders\n      });\n    }\n\n    return true;\n  }\n\n  unhold(options = {}, done)\n  {\n    debug('unhold()');\n\n    if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED)\n    {\n      return false;\n    }\n\n    if (this._localHold === false)\n    {\n      return false;\n    }\n\n    if (! this._isReadyToReOffer())\n    {\n      return false;\n    }\n\n    this._localHold = false;\n    this._onunhold('local');\n\n    const eventHandlers = {\n      succeeded : () =>\n      {\n        if (done) { done(); }\n      },\n      failed : () =>\n      {\n        this.terminate({\n          cause         : JsSIP_C.causes.WEBRTC_ERROR,\n          status_code   : 500,\n          reason_phrase : 'Unhold Failed'\n        });\n      }\n    };\n\n    if (options.useUpdate)\n    {\n      this._sendUpdate({\n        sdpOffer     : true,\n        eventHandlers,\n        extraHeaders : options.extraHeaders\n      });\n    }\n    else\n    {\n      this._sendReinvite({\n        eventHandlers,\n        extraHeaders : options.extraHeaders\n      });\n    }\n\n    return true;\n  }\n\n  renegotiate(options = {}, done)\n  {\n    debug('renegotiate()');\n\n    const rtcOfferConstraints = options.rtcOfferConstraints || null;\n\n    if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED)\n    {\n      return false;\n    }\n\n    if (! this._isReadyToReOffer())\n    {\n      return false;\n    }\n\n    const eventHandlers = {\n      succeeded : () =>\n      {\n        if (done) { done(); }\n      },\n      failed : () =>\n      {\n        this.terminate({\n          cause         : JsSIP_C.causes.WEBRTC_ERROR,\n          status_code   : 500,\n          reason_phrase : 'Media Renegotiation Failed'\n        });\n      }\n    };\n\n    this._setLocalMediaStatus();\n\n    if (options.useUpdate)\n    {\n      this._sendUpdate({\n        sdpOffer     : true,\n        eventHandlers,\n        rtcOfferConstraints,\n        extraHeaders : options.extraHeaders\n      });\n    }\n    else\n    {\n      this._sendReinvite({\n        eventHandlers,\n        rtcOfferConstraints,\n        extraHeaders : options.extraHeaders\n      });\n    }\n\n    return true;\n  }\n\n  /**\n   * Refer\n   */\n  refer(target, options)\n  {\n    debug('refer()');\n\n    const originalTarget = target;\n\n    if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED)\n    {\n      return false;\n    }\n\n    // Check target validity.\n    target = this._ua.normalizeTarget(target);\n    if (!target)\n    {\n      throw new TypeError(`Invalid target: ${originalTarget}`);\n    }\n\n    const referSubscriber = new RTCSession_ReferSubscriber(this);\n\n    referSubscriber.sendRefer(target, options);\n\n    // Store in the map.\n    const id = referSubscriber.id;\n\n    this._referSubscribers[id] = referSubscriber;\n\n    // Listen for ending events so we can remove it from the map.\n    referSubscriber.on('requestFailed', () =>\n    {\n      delete this._referSubscribers[id];\n    });\n    referSubscriber.on('accepted', () =>\n    {\n      delete this._referSubscribers[id];\n    });\n    referSubscriber.on('failed', () =>\n    {\n      delete this._referSubscribers[id];\n    });\n\n    return referSubscriber;\n  }\n\n  /**\n   * Send a generic in-dialog Request\n   */\n  sendRequest(method, options)\n  {\n    debug('sendRequest()');\n\n    return this._dialog.sendRequest(method, options);\n  }\n\n  /**\n   * In dialog Request Reception\n   */\n  receiveRequest(request)\n  {\n    debug('receiveRequest()');\n\n    if (request.method === JsSIP_C.CANCEL)\n    {\n      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL\n      * was in progress and that the UAC MAY continue with the session established by\n      * any 2xx response, or MAY terminate with BYE. JsSIP does continue with the\n      * established session. So the CANCEL is processed only if the session is not yet\n      * established.\n      */\n\n      /*\n      * Terminate the whole session in case the user didn't accept (or yet send the answer)\n      * nor reject the request opening the session.\n      */\n      if (this._status === C.STATUS_WAITING_FOR_ANSWER ||\n          this._status === C.STATUS_ANSWERED)\n      {\n        this._status = C.STATUS_CANCELED;\n        this._request.reply(487);\n        this._failed('remote', request, JsSIP_C.causes.CANCELED);\n      }\n    }\n    else\n    {\n      // Requests arriving here are in-dialog requests.\n      switch (request.method)\n      {\n        case JsSIP_C.ACK:\n          if (this._status !== C.STATUS_WAITING_FOR_ACK)\n          {\n            return;\n          }\n\n          // Update signaling status.\n          this._status = C.STATUS_CONFIRMED;\n\n          clearTimeout(this._timers.ackTimer);\n          clearTimeout(this._timers.invite2xxTimer);\n\n          if (this._late_sdp)\n          {\n            if (!request.body)\n            {\n              this.terminate({\n                cause       : JsSIP_C.causes.MISSING_SDP,\n                status_code : 400\n              });\n              break;\n            }\n\n            const e = { originator: 'remote', type: 'answer', sdp: request.body };\n\n            debug('emit \"sdp\"');\n            this.emit('sdp', e);\n\n            const answer = new RTCSessionDescription({ type: 'answer', sdp: e.sdp });\n\n            this._connectionPromiseQueue = this._connectionPromiseQueue\n              .then(() => this._connection.setRemoteDescription(answer))\n              .then(() =>\n              {\n                if (!this._is_confirmed)\n                {\n                  this._confirmed('remote', request);\n                }\n              })\n              .catch((error) =>\n              {\n                this.terminate({\n                  cause       : JsSIP_C.causes.BAD_MEDIA_DESCRIPTION,\n                  status_code : 488\n                });\n\n                debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n                this.emit('peerconnection:setremotedescriptionfailed', error);\n              });\n          }\n          else\n          if (!this._is_confirmed)\n          {\n            this._confirmed('remote', request);\n          }\n\n          break;\n        case JsSIP_C.BYE:\n          if (this._status === C.STATUS_CONFIRMED)\n          {\n            request.reply(200);\n            this._ended('remote', request, JsSIP_C.causes.BYE);\n          }\n          else if (this._status === C.STATUS_INVITE_RECEIVED)\n          {\n            request.reply(200);\n            this._request.reply(487, 'BYE Received');\n            this._ended('remote', request, JsSIP_C.causes.BYE);\n          }\n          else\n          {\n            request.reply(403, 'Wrong Status');\n          }\n          break;\n        case JsSIP_C.INVITE:\n          if (this._status === C.STATUS_CONFIRMED)\n          {\n            if (request.hasHeader('replaces'))\n            {\n              this._receiveReplaces(request);\n            }\n            else\n            {\n              this._receiveReinvite(request);\n            }\n          }\n          else\n          {\n            request.reply(403, 'Wrong Status');\n          }\n          break;\n        case JsSIP_C.INFO:\n          if (this._status === C.STATUS_1XX_RECEIVED ||\n              this._status === C.STATUS_WAITING_FOR_ANSWER ||\n              this._status === C.STATUS_ANSWERED ||\n              this._status === C.STATUS_WAITING_FOR_ACK ||\n              this._status === C.STATUS_CONFIRMED)\n          {\n            const contentType = request.getHeader('content-type');\n\n            if (contentType && (contentType.match(/^application\\/dtmf-relay/i)))\n            {\n              new RTCSession_DTMF(this).init_incoming(request);\n            }\n            else if (contentType !== undefined)\n            {\n              new RTCSession_Info(this).init_incoming(request);\n            }\n            else\n            {\n              request.reply(415);\n            }\n          }\n          else\n          {\n            request.reply(403, 'Wrong Status');\n          }\n          break;\n        case JsSIP_C.UPDATE:\n          if (this._status === C.STATUS_CONFIRMED)\n          {\n            this._receiveUpdate(request);\n          }\n          else\n          {\n            request.reply(403, 'Wrong Status');\n          }\n          break;\n        case JsSIP_C.REFER:\n          if (this._status === C.STATUS_CONFIRMED)\n          {\n            this._receiveRefer(request);\n          }\n          else\n          {\n            request.reply(403, 'Wrong Status');\n          }\n          break;\n        case JsSIP_C.NOTIFY:\n          if (this._status === C.STATUS_CONFIRMED)\n          {\n            this._receiveNotify(request);\n          }\n          else\n          {\n            request.reply(403, 'Wrong Status');\n          }\n          break;\n        default:\n          request.reply(501);\n      }\n    }\n  }\n\n  /**\n   * Session Callbacks\n   */\n\n  onTransportError()\n  {\n    debugerror('onTransportError()');\n\n    if (this._status !== C.STATUS_TERMINATED)\n    {\n      this.terminate({\n        status_code   : 500,\n        reason_phrase : JsSIP_C.causes.CONNECTION_ERROR,\n        cause         : JsSIP_C.causes.CONNECTION_ERROR\n      });\n    }\n  }\n\n  onRequestTimeout()\n  {\n    debugerror('onRequestTimeout()');\n\n    if (this._status !== C.STATUS_TERMINATED)\n    {\n      this.terminate({\n        status_code   : 408,\n        reason_phrase : JsSIP_C.causes.REQUEST_TIMEOUT,\n        cause         : JsSIP_C.causes.REQUEST_TIMEOUT\n      });\n    }\n  }\n\n  onDialogError()\n  {\n    debugerror('onDialogError()');\n\n    if (this._status !== C.STATUS_TERMINATED)\n    {\n      this.terminate({\n        status_code   : 500,\n        reason_phrase : JsSIP_C.causes.DIALOG_ERROR,\n        cause         : JsSIP_C.causes.DIALOG_ERROR\n      });\n    }\n  }\n\n  // Called from DTMF handler.\n  newDTMF(data)\n  {\n    debug('newDTMF()');\n\n    this.emit('newDTMF', data);\n  }\n\n  // Called from Info handler.\n  newInfo(data)\n  {\n    debug('newInfo()');\n\n    this.emit('newInfo', data);\n  }\n\n  /**\n   * Check if RTCSession is ready for an outgoing re-INVITE or UPDATE with SDP.\n   */\n  _isReadyToReOffer()\n  {\n    if (! this._rtcReady)\n    {\n      debug('_isReadyToReOffer() | internal WebRTC status not ready');\n\n      return false;\n    }\n\n    // No established yet.\n    if (! this._dialog)\n    {\n      debug('_isReadyToReOffer() | session not established yet');\n\n      return false;\n    }\n\n    // Another INVITE transaction is in progress.\n    if (this._dialog.uac_pending_reply === true ||\n        this._dialog.uas_pending_reply === true)\n    {\n      debug('_isReadyToReOffer() | there is another INVITE/UPDATE transaction in progress');\n\n      return false;\n    }\n\n    return true;\n  }\n\n  _close()\n  {\n    debug('close()');\n\n    if (this._status === C.STATUS_TERMINATED)\n    {\n      return;\n    }\n\n    this._status = C.STATUS_TERMINATED;\n\n    // Terminate RTC.\n    if (this._connection)\n    {\n      try\n      {\n        this._connection.close();\n      }\n      catch (error)\n      {\n        debugerror('close() | error closing the RTCPeerConnection: %o', error);\n      }\n    }\n\n    // Close local MediaStream if it was not given by the user.\n    if (this._localMediaStream && this._localMediaStreamLocallyGenerated)\n    {\n      debug('close() | closing local MediaStream');\n\n      Utils.closeMediaStream(this._localMediaStream);\n    }\n\n    // Terminate signaling.\n\n    // Clear SIP timers.\n    for (const timer in this._timers)\n    {\n      if (Object.prototype.hasOwnProperty.call(this._timers, timer))\n      {\n        clearTimeout(this._timers[timer]);\n      }\n    }\n\n    // Clear Session Timers.\n    clearTimeout(this._sessionTimers.timer);\n\n    // Terminate confirmed dialog.\n    if (this._dialog)\n    {\n      this._dialog.terminate();\n      delete this._dialog;\n    }\n\n    // Terminate early dialogs.\n    for (const dialog in this._earlyDialogs)\n    {\n      if (Object.prototype.hasOwnProperty.call(this._earlyDialogs, dialog))\n      {\n        this._earlyDialogs[dialog].terminate();\n        delete this._earlyDialogs[dialog];\n      }\n    }\n\n    // Terminate REFER subscribers.\n    for (const subscriber in this._referSubscribers)\n    {\n      if (Object.prototype.hasOwnProperty.call(this._referSubscribers, subscriber))\n      {\n        delete this._referSubscribers[subscriber];\n      }\n    }\n\n    this._ua.destroyRTCSession(this);\n  }\n\n  /**\n   * Private API.\n   */\n\n  /**\n   * RFC3261 13.3.1.4\n   * Response retransmissions cannot be accomplished by transaction layer\n   *  since it is destroyed when receiving the first 2xx answer\n   */\n  _setInvite2xxTimer(request, body)\n  {\n    let timeout = Timers.T1;\n\n    function invite2xxRetransmission()\n    {\n      if (this._status !== C.STATUS_WAITING_FOR_ACK)\n      {\n        return;\n      }\n\n      request.reply(200, null, [ `Contact: ${this._contact}` ], body);\n\n      if (timeout < Timers.T2)\n      {\n        timeout = timeout * 2;\n        if (timeout > Timers.T2)\n        {\n          timeout = Timers.T2;\n        }\n      }\n\n      this._timers.invite2xxTimer = setTimeout(\n        invite2xxRetransmission.bind(this), timeout);\n    }\n\n    this._timers.invite2xxTimer = setTimeout(\n      invite2xxRetransmission.bind(this), timeout);\n  }\n\n\n  /**\n   * RFC3261 14.2\n   * If a UAS generates a 2xx response and never receives an ACK,\n   *  it SHOULD generate a BYE to terminate the dialog.\n   */\n  _setACKTimer()\n  {\n    this._timers.ackTimer = setTimeout(() =>\n    {\n      if (this._status === C.STATUS_WAITING_FOR_ACK)\n      {\n        debug('no ACK received, terminating the session');\n\n        clearTimeout(this._timers.invite2xxTimer);\n        this.sendRequest(JsSIP_C.BYE);\n        this._ended('remote', null, JsSIP_C.causes.NO_ACK);\n      }\n    }, Timers.TIMER_H);\n  }\n\n\n  _createRTCConnection(pcConfig, rtcConstraints)\n  {\n    this._connection = new RTCPeerConnection(pcConfig, rtcConstraints);\n\n    this._connection.addEventListener('iceconnectionstatechange', () =>\n    {\n      const state = this._connection.iceConnectionState;\n\n      // TODO: Do more with different states.\n      if (state === 'failed')\n      {\n        this.terminate({\n          cause         : JsSIP_C.causes.RTP_TIMEOUT,\n          status_code   : 408,\n          reason_phrase : JsSIP_C.causes.RTP_TIMEOUT\n        });\n      }\n    });\n\n    debug('emit \"peerconnection\"');\n\n    this.emit('peerconnection', {\n      peerconnection : this._connection\n    });\n  }\n\n  _createLocalDescription(type, constraints)\n  {\n    debug('createLocalDescription()');\n\n    if (type !== 'offer' && type !== 'answer')\n      throw new Error(`createLocalDescription() | invalid type \"${type}\"`);\n\n    const connection = this._connection;\n\n    this._rtcReady = false;\n\n    return Promise.resolve()\n      // Create Offer or Answer.\n      .then(() =>\n      {\n        if (type === 'offer')\n        {\n          return connection.createOffer(constraints)\n            .catch((error) =>\n            {\n              debugerror('emit \"peerconnection:createofferfailed\" [error:%o]', error);\n\n              this.emit('peerconnection:createofferfailed', error);\n\n              return Promise.reject(error);\n            });\n        }\n        else\n        {\n          return connection.createAnswer(constraints)\n            .catch((error) =>\n            {\n              debugerror('emit \"peerconnection:createanswerfailed\" [error:%o]', error);\n\n              this.emit('peerconnection:createanswerfailed', error);\n\n              return Promise.reject(error);\n            });\n        }\n      })\n      // Set local description.\n      .then((desc) =>\n      {\n        return connection.setLocalDescription(desc)\n          .catch((error) =>\n          {\n            this._rtcReady = true;\n\n            debugerror('emit \"peerconnection:setlocaldescriptionfailed\" [error:%o]', error);\n\n            this.emit('peerconnection:setlocaldescriptionfailed', error);\n\n            return Promise.reject(error);\n          });\n      })\n      .then(() =>\n      {\n        // Resolve right away if 'pc.iceGatheringState' is 'complete'.\n        if (connection.iceGatheringState === 'complete')\n        {\n          this._rtcReady = true;\n\n          const e = { originator: 'local', type: type, sdp: connection.localDescription.sdp };\n\n          debug('emit \"sdp\"');\n\n          this.emit('sdp', e);\n\n          return Promise.resolve(e.sdp);\n        }\n\n        // Add 'pc.onicencandidate' event handler to resolve on last candidate.\n        return new Promise((resolve) =>\n        {\n          let finished = false;\n          let listener;\n\n          const ready = () =>\n          {\n            connection.removeEventListener('icecandidate', listener);\n\n            finished = true;\n            this._rtcReady = true;\n\n            const e = { originator: 'local', type: type, sdp: connection.localDescription.sdp };\n\n            debug('emit \"sdp\"');\n\n            this.emit('sdp', e);\n\n            resolve(e.sdp);\n          };\n\n          connection.addEventListener('icecandidate', listener = (event) =>\n          {\n            const candidate = event.candidate;\n\n            if (candidate)\n            {\n              this.emit('icecandidate', {\n                candidate,\n                ready\n              });\n            }\n\n            else if (! finished)\n            {\n              ready();\n            }\n          });\n        });\n      });\n  }\n\n  /**\n   * Dialog Management\n   */\n  _createDialog(message, type, early)\n  {\n    const local_tag = (type === 'UAS') ? message.to_tag : message.from_tag;\n    const remote_tag = (type === 'UAS') ? message.from_tag : message.to_tag;\n    const id = message.call_id + local_tag + remote_tag;\n\n    let early_dialog = this._earlyDialogs[id];\n\n    // Early Dialog.\n    if (early)\n    {\n      if (early_dialog)\n      {\n        return true;\n      }\n      else\n      {\n        early_dialog = new Dialog(this, message, type, Dialog.C.STATUS_EARLY);\n\n        // Dialog has been successfully created.\n        if (early_dialog.error)\n        {\n          debug(early_dialog.error);\n          this._failed('remote', message, JsSIP_C.causes.INTERNAL_ERROR);\n\n          return false;\n        }\n        else\n        {\n          this._earlyDialogs[id] = early_dialog;\n\n          return true;\n        }\n      }\n    }\n\n    // Confirmed Dialog.\n    else\n    {\n      this._from_tag = message.from_tag;\n      this._to_tag = message.to_tag;\n\n      // In case the dialog is in _early_ state, update it.\n      if (early_dialog)\n      {\n        early_dialog.update(message, type);\n        this._dialog = early_dialog;\n        delete this._earlyDialogs[id];\n\n        return true;\n      }\n\n      // Otherwise, create a _confirmed_ dialog.\n      const dialog = new Dialog(this, message, type);\n\n      if (dialog.error)\n      {\n        debug(dialog.error);\n        this._failed('remote', message, JsSIP_C.causes.INTERNAL_ERROR);\n\n        return false;\n      }\n      else\n      {\n        this._dialog = dialog;\n\n        return true;\n      }\n    }\n  }\n\n  /**\n   * In dialog INVITE Reception\n   */\n\n  _receiveReinvite(request)\n  {\n    debug('receiveReinvite()');\n\n    const contentType = request.getHeader('Content-Type');\n    const data = {\n      request,\n      callback : undefined,\n      reject   : reject.bind(this)\n    };\n\n    let rejected = false;\n\n    function reject(options = {})\n    {\n      rejected = true;\n\n      const status_code = options.status_code || 403;\n      const reason_phrase = options.reason_phrase || '';\n      const extraHeaders = Utils.cloneArray(options.extraHeaders);\n\n      if (this._status !== C.STATUS_CONFIRMED)\n      {\n        return false;\n      }\n\n      if (status_code < 300 || status_code >= 700)\n      {\n        throw new TypeError(`Invalid status_code: ${status_code}`);\n      }\n\n      request.reply(status_code, reason_phrase, extraHeaders);\n    }\n\n    // Emit 'reinvite'.\n    this.emit('reinvite', data);\n\n    if (rejected)\n    {\n      return;\n    }\n\n    this._late_sdp = false;\n\n    // Request without SDP.\n    if (!request.body)\n    {\n      this._late_sdp = true;\n\n      this._connectionPromiseQueue = this._connectionPromiseQueue\n        .then(() => this._createLocalDescription('offer', this._rtcOfferConstraints))\n        .then((sdp) =>\n        {\n          sendAnswer.call(this, sdp);\n        })\n        .catch(() =>\n        {\n          request.reply(500);\n        });\n\n      return;\n    }\n\n    // Request with SDP.\n    if (contentType !== 'application/sdp')\n    {\n      debug('invalid Content-Type');\n      request.reply(415);\n\n      return;\n    }\n\n    this._processInDialogSdpOffer(request)\n      // Send answer.\n      .then((desc) =>\n      {\n        if (this._status === C.STATUS_TERMINATED)\n        {\n          return;\n        }\n\n        sendAnswer.call(this, desc);\n      })\n      .catch((error) =>\n      {\n        debugerror(error);\n      });\n\n    function sendAnswer(desc)\n    {\n      const extraHeaders = [ `Contact: ${this._contact}` ];\n\n      this._handleSessionTimersInIncomingRequest(request, extraHeaders);\n\n      if (this._late_sdp)\n      {\n        desc = this._mangleOffer(desc);\n      }\n\n      request.reply(200, null, extraHeaders, desc,\n        () =>\n        {\n          this._status = C.STATUS_WAITING_FOR_ACK;\n          this._setInvite2xxTimer(request, desc);\n          this._setACKTimer();\n        }\n      );\n\n      // If callback is given execute it.\n      if (typeof data.callback === 'function')\n      {\n        data.callback();\n      }\n    }\n  }\n\n  /**\n   * In dialog UPDATE Reception\n   */\n  _receiveUpdate(request)\n  {\n    debug('receiveUpdate()');\n\n    const contentType = request.getHeader('Content-Type');\n    const data = {\n      request,\n      callback : undefined,\n      reject   : reject.bind(this)\n    };\n\n    let rejected = false;\n\n    function reject(options = {})\n    {\n      rejected = true;\n\n      const status_code = options.status_code || 403;\n      const reason_phrase = options.reason_phrase || '';\n      const extraHeaders = Utils.cloneArray(options.extraHeaders);\n\n      if (this._status !== C.STATUS_CONFIRMED)\n      {\n        return false;\n      }\n\n      if (status_code < 300 || status_code >= 700)\n      {\n        throw new TypeError(`Invalid status_code: ${status_code}`);\n      }\n\n      request.reply(status_code, reason_phrase, extraHeaders);\n    }\n\n    // Emit 'update'.\n    this.emit('update', data);\n\n    if (rejected)\n    {\n      return;\n    }\n\n    if (! request.body)\n    {\n      sendAnswer.call(this, null);\n\n      return;\n    }\n\n    if (contentType !== 'application/sdp')\n    {\n      debug('invalid Content-Type');\n\n      request.reply(415);\n\n      return;\n    }\n\n    this._processInDialogSdpOffer(request)\n      // Send answer.\n      .then((desc) =>\n      {\n        if (this._status === C.STATUS_TERMINATED)\n        {\n          return;\n        }\n\n        sendAnswer.call(this, desc);\n      })\n      .catch((error) =>\n      {\n        debugerror(error);\n      });\n\n    function sendAnswer(desc)\n    {\n      const extraHeaders = [ `Contact: ${this._contact}` ];\n\n      this._handleSessionTimersInIncomingRequest(request, extraHeaders);\n\n      request.reply(200, null, extraHeaders, desc);\n\n      // If callback is given execute it.\n      if (typeof data.callback === 'function')\n      {\n        data.callback();\n      }\n    }\n  }\n\n  _processInDialogSdpOffer(request)\n  {\n    debug('_processInDialogSdpOffer()');\n\n    const sdp = request.parseSDP();\n\n    let hold = false;\n\n    for (const m of sdp.media)\n    {\n      if (holdMediaTypes.indexOf(m.type) === -1)\n      {\n        continue;\n      }\n\n      const direction = m.direction || sdp.direction || 'sendrecv';\n\n      if (direction === 'sendonly' || direction === 'inactive')\n      {\n        hold = true;\n      }\n      // If at least one of the streams is active don't emit 'hold'.\n      else\n      {\n        hold = false;\n        break;\n      }\n    }\n\n    const e = { originator: 'remote', type: 'offer', sdp: request.body };\n\n    debug('emit \"sdp\"');\n    this.emit('sdp', e);\n\n    const offer = new RTCSessionDescription({ type: 'offer', sdp: e.sdp });\n\n    this._connectionPromiseQueue = this._connectionPromiseQueue\n      // Set remote description.\n      .then(() =>\n      {\n        if (this._status === C.STATUS_TERMINATED)\n        {\n          throw new Error('terminated');\n        }\n\n        return this._connection.setRemoteDescription(offer)\n          .catch((error) =>\n          {\n            request.reply(488);\n            debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n            this.emit('peerconnection:setremotedescriptionfailed', error);\n\n            throw new Error('peerconnection.setRemoteDescription() failed');\n          });\n      })\n      .then(() =>\n      {\n        if (this._status === C.STATUS_TERMINATED)\n        {\n          throw new Error('terminated');\n        }\n\n        if (this._remoteHold === true && hold === false)\n        {\n          this._remoteHold = false;\n          this._onunhold('remote');\n        }\n        else if (this._remoteHold === false && hold === true)\n        {\n          this._remoteHold = true;\n          this._onhold('remote');\n        }\n      })\n      // Create local description.\n      .then(() =>\n      {\n        if (this._status === C.STATUS_TERMINATED)\n        {\n          throw new Error('terminated');\n        }\n\n        return this._createLocalDescription('answer', this._rtcAnswerConstraints)\n          .catch(() =>\n          {\n            request.reply(500);\n\n            throw new Error('_createLocalDescription() failed');\n          });\n      });\n\n    return this._connectionPromiseQueue;\n  }\n\n  /**\n   * In dialog Refer Reception\n   */\n  _receiveRefer(request)\n  {\n    debug('receiveRefer()');\n\n    if (!request.refer_to)\n    {\n      debug('no Refer-To header field present in REFER');\n      request.reply(400);\n\n      return;\n    }\n\n    if (request.refer_to.uri.scheme !== JsSIP_C.SIP)\n    {\n      debug('Refer-To header field points to a non-SIP URI scheme');\n      request.reply(416);\n\n      return;\n    }\n\n    // Reply before the transaction timer expires.\n    request.reply(202);\n\n    const notifier = new RTCSession_ReferNotifier(this, request.cseq);\n\n    debug('emit \"refer\"');\n\n    // Emit 'refer'.\n    this.emit('refer', {\n      request,\n      accept : (initCallback, options) =>\n      {\n        accept.call(this, initCallback, options);\n      },\n      reject : () =>\n      {\n        reject.call(this);\n      }\n    });\n\n    function accept(initCallback, options = {})\n    {\n      initCallback = (typeof initCallback === 'function')? initCallback : null;\n\n      if (this._status !== C.STATUS_WAITING_FOR_ACK &&\n          this._status !== C.STATUS_CONFIRMED)\n      {\n        return false;\n      }\n\n      const session = new RTCSession(this._ua);\n\n      session.on('progress', ({ response }) =>\n      {\n        notifier.notify(response.status_code, response.reason_phrase);\n      });\n\n      session.on('accepted', ({ response }) =>\n      {\n        notifier.notify(response.status_code, response.reason_phrase);\n      });\n\n      session.on('_failed', ({ message, cause }) =>\n      {\n        if (message)\n        {\n          notifier.notify(message.status_code, message.reason_phrase);\n        }\n        else\n        {\n          notifier.notify(487, cause);\n        }\n      });\n\n      // Consider the Replaces header present in the Refer-To URI.\n      if (request.refer_to.uri.hasHeader('replaces'))\n      {\n        const replaces = decodeURIComponent(request.refer_to.uri.getHeader('replaces'));\n\n        options.extraHeaders = Utils.cloneArray(options.extraHeaders);\n        options.extraHeaders.push(`Replaces: ${replaces}`);\n      }\n\n      session.connect(request.refer_to.uri.toAor(), options, initCallback);\n    }\n\n    function reject()\n    {\n      notifier.notify(603);\n    }\n  }\n\n  /**\n   * In dialog Notify Reception\n   */\n  _receiveNotify(request)\n  {\n    debug('receiveNotify()');\n\n    if (!request.event)\n    {\n      request.reply(400);\n    }\n\n    switch (request.event.event)\n    {\n      case 'refer': {\n        let id;\n        let referSubscriber;\n\n        if (request.event.params && request.event.params.id)\n        {\n          id = request.event.params.id;\n          referSubscriber = this._referSubscribers[id];\n        }\n        else if (Object.keys(this._referSubscribers).length === 1)\n        {\n          referSubscriber = this._referSubscribers[\n            Object.keys(this._referSubscribers)[0]];\n        }\n        else\n        {\n          request.reply(400, 'Missing event id parameter');\n\n          return;\n        }\n\n        if (!referSubscriber)\n        {\n          request.reply(481, 'Subscription does not exist');\n\n          return;\n        }\n\n        referSubscriber.receiveNotify(request);\n        request.reply(200);\n\n        break;\n      }\n\n      default: {\n        request.reply(489);\n      }\n    }\n  }\n\n  /**\n   * INVITE with Replaces Reception\n   */\n  _receiveReplaces(request)\n  {\n    debug('receiveReplaces()');\n\n    function accept(initCallback)\n    {\n      if (this._status !== C.STATUS_WAITING_FOR_ACK &&\n          this._status !== C.STATUS_CONFIRMED)\n      {\n        return false;\n      }\n\n      const session = new RTCSession(this._ua);\n\n      // Terminate the current session when the new one is confirmed.\n      session.on('confirmed', () =>\n      {\n        this.terminate();\n      });\n\n      session.init_incoming(request, initCallback);\n    }\n\n    function reject()\n    {\n      debug('Replaced INVITE rejected by the user');\n      request.reply(486);\n    }\n\n    // Emit 'replace'.\n    this.emit('replaces', {\n      request,\n      accept : (initCallback) => { accept.call(this, initCallback); },\n      reject : () => { reject.call(this); }\n    });\n  }\n\n  /**\n   * Initial Request Sender\n   */\n  _sendInitialRequest(mediaConstraints, rtcOfferConstraints, mediaStream)\n  {\n    const request_sender = new RequestSender(this._ua, this._request, {\n      onRequestTimeout : () =>\n      {\n        this.onRequestTimeout();\n      },\n      onTransportError : () =>\n      {\n        this.onTransportError();\n      },\n      // Update the request on authentication.\n      onAuthenticated : (request) =>\n      {\n        this._request = request;\n      },\n      onReceiveResponse : (response) =>\n      {\n        this._receiveInviteResponse(response);\n      }\n    });\n\n    // This Promise is resolved within the next iteration, so the app has now\n    // a chance to set events such as 'peerconnection' and 'connecting'.\n    Promise.resolve()\n      // Get a stream if required.\n      .then(() =>\n      {\n        // A stream is given, let the app set events such as 'peerconnection' and 'connecting'.\n        if (mediaStream)\n        {\n          return mediaStream;\n        }\n        // Request for user media access.\n        else if (mediaConstraints.audio || mediaConstraints.video)\n        {\n          this._localMediaStreamLocallyGenerated = true;\n\n          return navigator.mediaDevices.getUserMedia(mediaConstraints)\n            .catch((error) =>\n            {\n              if (this._status === C.STATUS_TERMINATED)\n              {\n                throw new Error('terminated');\n              }\n\n              this._failed('local', null, JsSIP_C.causes.USER_DENIED_MEDIA_ACCESS);\n\n              debugerror('emit \"getusermediafailed\" [error:%o]', error);\n\n              this.emit('getusermediafailed', error);\n\n              throw error;\n            });\n        }\n      })\n      .then((stream) =>\n      {\n        if (this._status === C.STATUS_TERMINATED)\n        {\n          throw new Error('terminated');\n        }\n\n        this._localMediaStream = stream;\n\n        if (stream)\n        {\n          stream.getTracks().forEach((track) =>\n          {\n            this._connection.addTrack(track, stream);\n          });\n        }\n\n        // TODO: should this be triggered here?\n        this._connecting(this._request);\n\n        return this._createLocalDescription('offer', rtcOfferConstraints)\n          .catch((error) =>\n          {\n            this._failed('local', null, JsSIP_C.causes.WEBRTC_ERROR);\n\n            throw error;\n          });\n      })\n      .then((desc) =>\n      {\n        if (this._is_canceled || this._status === C.STATUS_TERMINATED)\n        {\n          throw new Error('terminated');\n        }\n\n        this._request.body = desc;\n        this._status = C.STATUS_INVITE_SENT;\n\n        debug('emit \"sending\" [request:%o]', this._request);\n\n        // Emit 'sending' so the app can mangle the body before the request is sent.\n        this.emit('sending', {\n          request : this._request\n        });\n\n        request_sender.send();\n      })\n      .catch((error) =>\n      {\n        if (this._status === C.STATUS_TERMINATED)\n        {\n          return;\n        }\n\n        debugerror(error);\n      });\n  }\n\n  /**\n   * Reception of Response for Initial INVITE\n   */\n  _receiveInviteResponse(response)\n  {\n    debug('receiveInviteResponse()');\n\n    // Handle 2XX retransmissions and responses from forked requests.\n    if (this._dialog && (response.status_code >=200 && response.status_code <=299))\n    {\n\n      /*\n       * If it is a retransmission from the endpoint that established\n       * the dialog, send an ACK\n       */\n      if (this._dialog.id.call_id === response.call_id &&\n          this._dialog.id.local_tag === response.from_tag &&\n          this._dialog.id.remote_tag === response.to_tag)\n      {\n        this.sendRequest(JsSIP_C.ACK);\n\n        return;\n      }\n\n      // If not, send an ACK  and terminate.\n      else\n      {\n        const dialog = new Dialog(this, response, 'UAC');\n\n        if (dialog.error !== undefined)\n        {\n          debug(dialog.error);\n\n          return;\n        }\n\n        this.sendRequest(JsSIP_C.ACK);\n        this.sendRequest(JsSIP_C.BYE);\n\n        return;\n      }\n\n    }\n\n    // Proceed to cancellation if the user requested.\n    if (this._is_canceled)\n    {\n      if (response.status_code >= 100 && response.status_code < 200)\n      {\n        this._request.cancel(this._cancel_reason);\n      }\n      else if (response.status_code >= 200 && response.status_code < 299)\n      {\n        this._acceptAndTerminate(response);\n      }\n\n      return;\n    }\n\n    if (this._status !== C.STATUS_INVITE_SENT && this._status !== C.STATUS_1XX_RECEIVED)\n    {\n      return;\n    }\n\n    switch (true)\n    {\n      case /^100$/.test(response.status_code):\n        this._status = C.STATUS_1XX_RECEIVED;\n        break;\n\n      case /^1[0-9]{2}$/.test(response.status_code):\n      {\n        // Do nothing with 1xx responses without To tag.\n        if (!response.to_tag)\n        {\n          debug('1xx response received without to tag');\n          break;\n        }\n\n        // Create Early Dialog if 1XX comes with contact.\n        if (response.hasHeader('contact'))\n        {\n          // An error on dialog creation will fire 'failed' event.\n          if (! this._createDialog(response, 'UAC', true))\n          {\n            break;\n          }\n        }\n\n        this._status = C.STATUS_1XX_RECEIVED;\n        this._progress('remote', response);\n\n        if (!response.body)\n        {\n          break;\n        }\n\n        const e = { originator: 'remote', type: 'answer', sdp: response.body };\n\n        debug('emit \"sdp\"');\n        this.emit('sdp', e);\n\n        const answer = new RTCSessionDescription({ type: 'answer', sdp: e.sdp });\n\n        this._connectionPromiseQueue = this._connectionPromiseQueue\n          .then(() => this._connection.setRemoteDescription(answer))\n          .catch((error) =>\n          {\n            debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n            this.emit('peerconnection:setremotedescriptionfailed', error);\n          });\n        break;\n      }\n\n      case /^2[0-9]{2}$/.test(response.status_code):\n      {\n        this._status = C.STATUS_CONFIRMED;\n\n        if (!response.body)\n        {\n          this._acceptAndTerminate(response, 400, JsSIP_C.causes.MISSING_SDP);\n          this._failed('remote', response, JsSIP_C.causes.BAD_MEDIA_DESCRIPTION);\n          break;\n        }\n\n        // An error on dialog creation will fire 'failed' event.\n        if (! this._createDialog(response, 'UAC'))\n        {\n          break;\n        }\n\n        const e = { originator: 'remote', type: 'answer', sdp: response.body };\n\n        debug('emit \"sdp\"');\n        this.emit('sdp', e);\n\n        const answer = new RTCSessionDescription({ type: 'answer', sdp: e.sdp });\n\n        this._connectionPromiseQueue = this._connectionPromiseQueue\n          .then(() =>\n          {\n            // Be ready for 200 with SDP after a 180/183 with SDP.\n            // We created a SDP 'answer' for it, so check the current signaling state.\n            if (this._connection.signalingState === 'stable')\n            {\n              return this._connection.createOffer(this._rtcOfferConstraints)\n                .then((offer) => this._connection.setLocalDescription(offer))\n                .catch((error) =>\n                {\n                  this._acceptAndTerminate(response, 500, error.toString());\n                  this._failed('local', response, JsSIP_C.causes.WEBRTC_ERROR);\n                });\n            }\n          })\n          .then(() =>\n          {\n            this._connection.setRemoteDescription(answer)\n              .then(() =>\n              {\n                // Handle Session Timers.\n                this._handleSessionTimersInIncomingResponse(response);\n\n                this._accepted('remote', response);\n                this.sendRequest(JsSIP_C.ACK);\n                this._confirmed('local', null);\n              })\n              .catch((error) =>\n              {\n                this._acceptAndTerminate(response, 488, 'Not Acceptable Here');\n                this._failed('remote', response, JsSIP_C.causes.BAD_MEDIA_DESCRIPTION);\n\n                debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n                this.emit('peerconnection:setremotedescriptionfailed', error);\n              });\n          });\n        break;\n      }\n\n      default:\n      {\n        const cause = Utils.sipErrorCause(response.status_code);\n\n        this._failed('remote', response, cause);\n      }\n    }\n  }\n\n  /**\n   * Send Re-INVITE\n   */\n  _sendReinvite(options = {})\n  {\n    debug('sendReinvite()');\n\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const eventHandlers = options.eventHandlers || {};\n    const rtcOfferConstraints = options.rtcOfferConstraints ||\n      this._rtcOfferConstraints || null;\n\n    let succeeded = false;\n\n    extraHeaders.push(`Contact: ${this._contact}`);\n    extraHeaders.push('Content-Type: application/sdp');\n\n    // Session Timers.\n    if (this._sessionTimers.running)\n    {\n      extraHeaders.push(`Session-Expires: ${this._sessionTimers.currentExpires};refresher=${this._sessionTimers.refresher ? 'uac' : 'uas'}`);\n    }\n\n    this._connectionPromiseQueue = this._connectionPromiseQueue\n      .then(() => this._createLocalDescription('offer', rtcOfferConstraints))\n      .then((sdp) =>\n      {\n        sdp = this._mangleOffer(sdp);\n\n        const e = { originator: 'local', type: 'offer', sdp };\n\n        debug('emit \"sdp\"');\n        this.emit('sdp', e);\n\n        this.sendRequest(JsSIP_C.INVITE, {\n          extraHeaders,\n          body          : sdp,\n          eventHandlers : {\n            onSuccessResponse : (response) =>\n            {\n              onSucceeded.call(this, response);\n              succeeded = true;\n            },\n            onErrorResponse : (response) =>\n            {\n              onFailed.call(this, response);\n            },\n            onTransportError : () =>\n            {\n              this.onTransportError(); // Do nothing because session ends.\n            },\n            onRequestTimeout : () =>\n            {\n              this.onRequestTimeout(); // Do nothing because session ends.\n            },\n            onDialogError : () =>\n            {\n              this.onDialogError(); // Do nothing because session ends.\n            }\n          }\n        });\n      })\n      .catch(() =>\n      {\n        onFailed();\n      });\n\n    function onSucceeded(response)\n    {\n      if (this._status === C.STATUS_TERMINATED)\n      {\n        return;\n      }\n\n      this.sendRequest(JsSIP_C.ACK);\n\n      // If it is a 2XX retransmission exit now.\n      if (succeeded) { return; }\n\n      // Handle Session Timers.\n      this._handleSessionTimersInIncomingResponse(response);\n\n      // Must have SDP answer.\n      if (! response.body)\n      {\n        onFailed.call(this);\n\n        return;\n      }\n      else if (response.getHeader('Content-Type') !== 'application/sdp')\n      {\n        onFailed.call(this);\n\n        return;\n      }\n\n      const e = { originator: 'remote', type: 'answer', sdp: response.body };\n\n      debug('emit \"sdp\"');\n      this.emit('sdp', e);\n\n      const answer = new RTCSessionDescription({ type: 'answer', sdp: e.sdp });\n\n      this._connectionPromiseQueue = this._connectionPromiseQueue\n        .then(() => this._connection.setRemoteDescription(answer))\n        .then(() =>\n        {\n          if (eventHandlers.succeeded)\n          {\n            eventHandlers.succeeded(response);\n          }\n        })\n        .catch((error) =>\n        {\n          onFailed.call(this);\n\n          debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n          this.emit('peerconnection:setremotedescriptionfailed', error);\n        });\n    }\n\n    function onFailed(response)\n    {\n      if (eventHandlers.failed)\n      {\n        eventHandlers.failed(response);\n      }\n    }\n  }\n\n  /**\n   * Send UPDATE\n   */\n  _sendUpdate(options = {})\n  {\n    debug('sendUpdate()');\n\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const eventHandlers = options.eventHandlers || {};\n    const rtcOfferConstraints = options.rtcOfferConstraints ||\n      this._rtcOfferConstraints || null;\n    const sdpOffer = options.sdpOffer || false;\n\n    let succeeded = false;\n\n    extraHeaders.push(`Contact: ${this._contact}`);\n\n    // Session Timers.\n    if (this._sessionTimers.running)\n    {\n      extraHeaders.push(`Session-Expires: ${this._sessionTimers.currentExpires};refresher=${this._sessionTimers.refresher ? 'uac' : 'uas'}`);\n    }\n\n    if (sdpOffer)\n    {\n      extraHeaders.push('Content-Type: application/sdp');\n\n      this._connectionPromiseQueue = this._connectionPromiseQueue\n        .then(() => this._createLocalDescription('offer', rtcOfferConstraints))\n        .then((sdp) =>\n        {\n          sdp = this._mangleOffer(sdp);\n\n          const e = { originator: 'local', type: 'offer', sdp };\n\n          debug('emit \"sdp\"');\n          this.emit('sdp', e);\n\n          this.sendRequest(JsSIP_C.UPDATE, {\n            extraHeaders,\n            body          : sdp,\n            eventHandlers : {\n              onSuccessResponse : (response) =>\n              {\n                onSucceeded.call(this, response);\n                succeeded = true;\n              },\n              onErrorResponse : (response) =>\n              {\n                onFailed.call(this, response);\n              },\n              onTransportError : () =>\n              {\n                this.onTransportError(); // Do nothing because session ends.\n              },\n              onRequestTimeout : () =>\n              {\n                this.onRequestTimeout(); // Do nothing because session ends.\n              },\n              onDialogError : () =>\n              {\n                this.onDialogError(); // Do nothing because session ends.\n              }\n            }\n          });\n        })\n        .catch(() =>\n        {\n          onFailed.call(this);\n        });\n    }\n\n    // No SDP.\n    else\n    {\n      this.sendRequest(JsSIP_C.UPDATE, {\n        extraHeaders,\n        eventHandlers : {\n          onSuccessResponse : (response) =>\n          {\n            onSucceeded.call(this, response);\n          },\n          onErrorResponse : (response) =>\n          {\n            onFailed.call(this, response);\n          },\n          onTransportError : () =>\n          {\n            this.onTransportError(); // Do nothing because session ends.\n          },\n          onRequestTimeout : () =>\n          {\n            this.onRequestTimeout(); // Do nothing because session ends.\n          },\n          onDialogError : () =>\n          {\n            this.onDialogError(); // Do nothing because session ends.\n          }\n        }\n      });\n    }\n\n    function onSucceeded(response)\n    {\n      if (this._status === C.STATUS_TERMINATED)\n      {\n        return;\n      }\n\n      // If it is a 2XX retransmission exit now.\n      if (succeeded) { return; }\n\n      // Handle Session Timers.\n      this._handleSessionTimersInIncomingResponse(response);\n\n      // Must have SDP answer.\n      if (sdpOffer)\n      {\n        if (! response.body)\n        {\n          onFailed.call(this);\n\n          return;\n        }\n        else if (response.getHeader('Content-Type') !== 'application/sdp')\n        {\n          onFailed.call(this);\n\n          return;\n        }\n\n        const e = { originator: 'remote', type: 'answer', sdp: response.body };\n\n        debug('emit \"sdp\"');\n        this.emit('sdp', e);\n\n        const answer = new RTCSessionDescription({ type: 'answer', sdp: e.sdp });\n\n        this._connectionPromiseQueue = this._connectionPromiseQueue\n          .then(() => this._connection.setRemoteDescription(answer))\n          .then(() =>\n          {\n            if (eventHandlers.succeeded)\n            {\n              eventHandlers.succeeded(response);\n            }\n          })\n          .catch((error) =>\n          {\n            onFailed.call(this);\n\n            debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n            this.emit('peerconnection:setremotedescriptionfailed', error);\n          });\n      }\n      // No SDP answer.\n      else\n      if (eventHandlers.succeeded)\n      {\n        eventHandlers.succeeded(response);\n      }\n    }\n\n    function onFailed(response)\n    {\n      if (eventHandlers.failed) { eventHandlers.failed(response); }\n    }\n  }\n\n  _acceptAndTerminate(response, status_code, reason_phrase)\n  {\n    debug('acceptAndTerminate()');\n\n    const extraHeaders = [];\n\n    if (status_code)\n    {\n      reason_phrase = reason_phrase || JsSIP_C.REASON_PHRASE[status_code] || '';\n      extraHeaders.push(`Reason: SIP ;cause=${status_code}; text=\"${reason_phrase}\"`);\n    }\n\n    // An error on dialog creation will fire 'failed' event.\n    if (this._dialog || this._createDialog(response, 'UAC'))\n    {\n      this.sendRequest(JsSIP_C.ACK);\n      this.sendRequest(JsSIP_C.BYE, {\n        extraHeaders\n      });\n    }\n\n    // Update session status.\n    this._status = C.STATUS_TERMINATED;\n  }\n\n  /**\n   * Correctly set the SDP direction attributes if the call is on local hold\n   */\n  _mangleOffer(sdp)\n  {\n\n    if (! this._localHold && ! this._remoteHold)\n    {\n      return sdp;\n    }\n\n    sdp = sdp_transform.parse(sdp);\n\n    // Local hold.\n    if (this._localHold && ! this._remoteHold)\n    {\n      debug('mangleOffer() | me on hold, mangling offer');\n      for (const m of sdp.media)\n      {\n        if (holdMediaTypes.indexOf(m.type) === -1)\n        {\n          continue;\n        }\n        if (!m.direction)\n        {\n          m.direction = 'sendonly';\n        }\n        else if (m.direction === 'sendrecv')\n        {\n          m.direction = 'sendonly';\n        }\n        else if (m.direction === 'recvonly')\n        {\n          m.direction = 'inactive';\n        }\n      }\n    }\n    // Local and remote hold.\n    else if (this._localHold && this._remoteHold)\n    {\n      debug('mangleOffer() | both on hold, mangling offer');\n      for (const m of sdp.media)\n      {\n        if (holdMediaTypes.indexOf(m.type) === -1)\n        {\n          continue;\n        }\n        m.direction = 'inactive';\n      }\n    }\n    // Remote hold.\n    else if (this._remoteHold)\n    {\n      debug('mangleOffer() | remote on hold, mangling offer');\n      for (const m of sdp.media)\n      {\n        if (holdMediaTypes.indexOf(m.type) === -1)\n        {\n          continue;\n        }\n        if (!m.direction)\n        {\n          m.direction = 'recvonly';\n        }\n        else if (m.direction === 'sendrecv')\n        {\n          m.direction = 'recvonly';\n        }\n        else if (m.direction === 'recvonly')\n        {\n          m.direction = 'inactive';\n        }\n      }\n    }\n\n    return sdp_transform.write(sdp);\n  }\n\n  _setLocalMediaStatus()\n  {\n    let enableAudio = true, enableVideo = true;\n\n    if (this._localHold || this._remoteHold)\n    {\n      enableAudio = false;\n      enableVideo = false;\n    }\n\n    if (this._audioMuted)\n    {\n      enableAudio = false;\n    }\n\n    if (this._videoMuted)\n    {\n      enableVideo = false;\n    }\n\n    this._toggleMuteAudio(!enableAudio);\n    this._toggleMuteVideo(!enableVideo);\n  }\n\n  /**\n   * Handle SessionTimers for an incoming INVITE or UPDATE.\n   * @param  {IncomingRequest} request\n   * @param  {Array} responseExtraHeaders  Extra headers for the 200 response.\n   */\n  _handleSessionTimersInIncomingRequest(request, responseExtraHeaders)\n  {\n    if (! this._sessionTimers.enabled) { return; }\n\n    let session_expires_refresher;\n\n    if (request.session_expires && request.session_expires >= JsSIP_C.MIN_SESSION_EXPIRES)\n    {\n      this._sessionTimers.currentExpires = request.session_expires;\n      session_expires_refresher = request.session_expires_refresher || 'uas';\n    }\n    else\n    {\n      this._sessionTimers.currentExpires = this._sessionTimers.defaultExpires;\n      session_expires_refresher = 'uas';\n    }\n\n    responseExtraHeaders.push(`Session-Expires: ${this._sessionTimers.currentExpires};refresher=${session_expires_refresher}`);\n\n    this._sessionTimers.refresher = (session_expires_refresher === 'uas');\n    this._runSessionTimer();\n  }\n\n  /**\n   * Handle SessionTimers for an incoming response to INVITE or UPDATE.\n   * @param  {IncomingResponse} response\n   */\n  _handleSessionTimersInIncomingResponse(response)\n  {\n    if (! this._sessionTimers.enabled) { return; }\n\n    let session_expires_refresher;\n\n    if (response.session_expires &&\n        response.session_expires >= JsSIP_C.MIN_SESSION_EXPIRES)\n    {\n      this._sessionTimers.currentExpires = response.session_expires;\n      session_expires_refresher = response.session_expires_refresher || 'uac';\n    }\n    else\n    {\n      this._sessionTimers.currentExpires = this._sessionTimers.defaultExpires;\n      session_expires_refresher = 'uac';\n    }\n\n    this._sessionTimers.refresher = (session_expires_refresher === 'uac');\n    this._runSessionTimer();\n  }\n\n  _runSessionTimer()\n  {\n    const expires = this._sessionTimers.currentExpires;\n\n    this._sessionTimers.running = true;\n\n    clearTimeout(this._sessionTimers.timer);\n\n    // I'm the refresher.\n    if (this._sessionTimers.refresher)\n    {\n      this._sessionTimers.timer = setTimeout(() =>\n      {\n        if (this._status === C.STATUS_TERMINATED) { return; }\n\n        debug('runSessionTimer() | sending session refresh request');\n\n        if (this._sessionTimers.refreshMethod === JsSIP_C.UPDATE)\n        {\n          this._sendUpdate();\n        }\n        else\n        {\n          this._sendReinvite();\n        }\n      }, expires * 500); // Half the given interval (as the RFC states).\n    }\n\n    // I'm not the refresher.\n    else\n    {\n      this._sessionTimers.timer = setTimeout(() =>\n      {\n        if (this._status === C.STATUS_TERMINATED) { return; }\n\n        debugerror('runSessionTimer() | timer expired, terminating the session');\n\n        this.terminate({\n          cause         : JsSIP_C.causes.REQUEST_TIMEOUT,\n          status_code   : 408,\n          reason_phrase : 'Session Timer Expired'\n        });\n      }, expires * 1100);\n    }\n  }\n\n  _toggleMuteAudio(mute)\n  {\n    const senders = this._connection.getSenders().filter((sender) =>\n    {\n      return sender.track && sender.track.kind === 'audio';\n    });\n\n    for (const sender of senders)\n    {\n      sender.track.enabled = !mute;\n    }\n  }\n\n  _toggleMuteVideo(mute)\n  {\n    const senders = this._connection.getSenders().filter((sender) =>\n    {\n      return sender.track && sender.track.kind === 'video';\n    });\n\n    for (const sender of senders)\n    {\n      sender.track.enabled = !mute;\n    }\n  }\n\n  _newRTCSession(originator, request)\n  {\n    debug('newRTCSession()');\n\n    this._ua.newRTCSession(this, {\n      originator,\n      session : this,\n      request\n    });\n  }\n\n  _connecting(request)\n  {\n    debug('session connecting');\n\n    debug('emit \"connecting\"');\n\n    this.emit('connecting', {\n      request\n    });\n  }\n\n  _progress(originator, response)\n  {\n    debug('session progress');\n\n    debug('emit \"progress\"');\n\n    this.emit('progress', {\n      originator,\n      response : response || null\n    });\n  }\n\n  _accepted(originator, message)\n  {\n    debug('session accepted');\n\n    this._start_time = new Date();\n\n    debug('emit \"accepted\"');\n\n    this.emit('accepted', {\n      originator,\n      response : message || null\n    });\n  }\n\n  _confirmed(originator, ack)\n  {\n    debug('session confirmed');\n\n    this._is_confirmed = true;\n\n    debug('emit \"confirmed\"');\n\n    this.emit('confirmed', {\n      originator,\n      ack : ack || null\n    });\n  }\n\n  _ended(originator, message, cause)\n  {\n    debug('session ended');\n\n    this._end_time = new Date();\n\n    this._close();\n\n    debug('emit \"ended\"');\n\n    this.emit('ended', {\n      originator,\n      message : message || null,\n      cause\n    });\n  }\n\n  _failed(originator, message, cause)\n  {\n    debug('session failed');\n\n    // Emit private '_failed' event first.\n    debug('emit \"_failed\"');\n\n    this.emit('_failed', {\n      originator,\n      message : message || null,\n      cause\n    });\n\n    this._close();\n\n    debug('emit \"failed\"');\n\n    this.emit('failed', {\n      originator,\n      message : message || null,\n      cause\n    });\n  }\n\n  _onhold(originator)\n  {\n    debug('session onhold');\n\n    this._setLocalMediaStatus();\n\n    debug('emit \"hold\"');\n\n    this.emit('hold', {\n      originator\n    });\n  }\n\n  _onunhold(originator)\n  {\n    debug('session onunhold');\n\n    this._setLocalMediaStatus();\n\n    debug('emit \"unhold\"');\n\n    this.emit('unhold', {\n      originator\n    });\n  }\n\n  _onmute({ audio, video })\n  {\n    debug('session onmute');\n\n    this._setLocalMediaStatus();\n\n    debug('emit \"muted\"');\n\n    this.emit('muted', {\n      audio,\n      video\n    });\n  }\n\n  _onunmute({ audio, video })\n  {\n    debug('session onunmute');\n\n    this._setLocalMediaStatus();\n\n    debug('emit \"unmuted\"');\n\n    this.emit('unmuted', {\n      audio,\n      video\n    });\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/RTCSession.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/RTCSession/DTMF.js":
/*!***************************************************!*\
  !*** ./node_modules/jssip/lib/RTCSession/DTMF.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nconst JsSIP_C = __webpack_require__(/*! ../Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst Exceptions = __webpack_require__(/*! ../Exceptions */ \"./node_modules/jssip/lib/Exceptions.js\");\nconst Utils = __webpack_require__(/*! ../Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:RTCSession:DTMF');\nconst debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:ERROR:RTCSession:DTMF');\n\ndebugerror.log = console.warn.bind(console);\n\nconst C = {\n  MIN_DURATION           : 70,\n  MAX_DURATION           : 6000,\n  DEFAULT_DURATION       : 100,\n  MIN_INTER_TONE_GAP     : 50,\n  DEFAULT_INTER_TONE_GAP : 500\n};\n\nmodule.exports = class DTMF extends EventEmitter\n{\n  constructor(session)\n  {\n    super();\n\n    this._session = session;\n    this._direction = null;\n    this._tone = null;\n    this._duration = null;\n    this._request = null;\n  }\n\n  get tone()\n  {\n    return this._tone;\n  }\n\n  get duration()\n  {\n    return this._duration;\n  }\n\n  send(tone, options = {})\n  {\n    if (tone === undefined)\n    {\n      throw new TypeError('Not enough arguments');\n    }\n\n    this._direction = 'outgoing';\n\n    // Check RTCSession Status.\n    if (this._session.status !== this._session.C.STATUS_CONFIRMED &&\n      this._session.status !== this._session.C.STATUS_WAITING_FOR_ACK)\n    {\n      throw new Exceptions.InvalidStateError(this._session.status);\n    }\n\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n\n    this.eventHandlers = options.eventHandlers || {};\n\n    // Check tone type.\n    if (typeof tone === 'string')\n    {\n      tone = tone.toUpperCase();\n    }\n    else if (typeof tone === 'number')\n    {\n      tone = tone.toString();\n    }\n    else\n    {\n      throw new TypeError(`Invalid tone: ${tone}`);\n    }\n\n    // Check tone value.\n    if (!tone.match(/^[0-9A-DR#*]$/))\n    {\n      throw new TypeError(`Invalid tone: ${tone}`);\n    }\n    else\n    {\n      this._tone = tone;\n    }\n\n    // Duration is checked/corrected in RTCSession.\n    this._duration = options.duration;\n\n    extraHeaders.push('Content-Type: application/dtmf-relay');\n\n    let body = `Signal=${this._tone}\\r\\n`;\n\n    body += `Duration=${this._duration}`;\n\n    this._session.newDTMF({\n      originator : 'local',\n      dtmf       : this,\n      request    : this._request\n    });\n\n    this._session.sendRequest(JsSIP_C.INFO, {\n      extraHeaders,\n      eventHandlers : {\n        onSuccessResponse : (response) =>\n        {\n          this.emit('succeeded', {\n            originator : 'remote',\n            response\n          });\n        },\n        onErrorResponse : (response) =>\n        {\n          if (this.eventHandlers.onFailed)\n          {\n            this.eventHandlers.onFailed();\n          }\n\n          this.emit('failed', {\n            originator : 'remote',\n            response\n          });\n        },\n        onRequestTimeout : () =>\n        {\n          this._session.onRequestTimeout();\n        },\n        onTransportError : () =>\n        {\n          this._session.onTransportError();\n        },\n        onDialogError : () =>\n        {\n          this._session.onDialogError();\n        }\n      },\n      body\n    });\n  }\n\n  init_incoming(request)\n  {\n    const reg_tone = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/;\n    const reg_duration = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n\n    this._direction = 'incoming';\n    this._request = request;\n\n    request.reply(200);\n\n    if (request.body)\n    {\n      const body = request.body.split('\\n');\n\n      if (body.length >= 1)\n      {\n        if (reg_tone.test(body[0]))\n        {\n          this._tone = body[0].replace(reg_tone, '$2');\n        }\n      }\n      if (body.length >=2)\n      {\n        if (reg_duration.test(body[1]))\n        {\n          this._duration = parseInt(body[1].replace(reg_duration, '$2'), 10);\n        }\n      }\n    }\n\n    if (!this._duration)\n    {\n      this._duration = C.DEFAULT_DURATION;\n    }\n\n    if (!this._tone)\n    {\n      debug('invalid INFO DTMF received, discarded');\n    }\n    else\n    {\n      this._session.newDTMF({\n        originator : 'remote',\n        dtmf       : this,\n        request\n      });\n    }\n  }\n};\n\n/**\n * Expose C object.\n */\nmodule.exports.C = C;\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/RTCSession/DTMF.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/RTCSession/Info.js":
/*!***************************************************!*\
  !*** ./node_modules/jssip/lib/RTCSession/Info.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nconst debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:ERROR:RTCSession:Info');\n\ndebugerror.log = console.warn.bind(console);\nconst JsSIP_C = __webpack_require__(/*! ../Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst Exceptions = __webpack_require__(/*! ../Exceptions */ \"./node_modules/jssip/lib/Exceptions.js\");\nconst Utils = __webpack_require__(/*! ../Utils */ \"./node_modules/jssip/lib/Utils.js\");\n\nmodule.exports = class Info extends EventEmitter\n{\n  constructor(session)\n  {\n    super();\n\n    this._session = session;\n    this._direction = null;\n    this._contentType = null;\n    this._body = null;\n  }\n\n  get contentType()\n  {\n    return this._contentType;\n  }\n\n  get body()\n  {\n    return this._body;\n  }\n\n  send(contentType, body, options = {})\n  {\n    this._direction = 'outgoing';\n\n    if (contentType === undefined)\n    {\n      throw new TypeError('Not enough arguments');\n    }\n\n    // Check RTCSession Status.\n    if (this._session.status !== this._session.C.STATUS_CONFIRMED &&\n      this._session.status !== this._session.C.STATUS_WAITING_FOR_ACK)\n    {\n      throw new Exceptions.InvalidStateError(this._session.status);\n    }\n\n    this._contentType = contentType;\n    this._body = body;\n\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n\n    extraHeaders.push(`Content-Type: ${contentType}`);\n\n    this._session.newInfo({\n      originator : 'local',\n      info       : this,\n      request    : this.request\n    });\n\n    this._session.sendRequest(JsSIP_C.INFO, {\n      extraHeaders,\n      eventHandlers : {\n        onSuccessResponse : (response) =>\n        {\n          this.emit('succeeded', {\n            originator : 'remote',\n            response\n          });\n        },\n        onErrorResponse : (response) =>\n        {\n          this.emit('failed', {\n            originator : 'remote',\n            response\n          });\n        },\n        onTransportError : () =>\n        {\n          this._session.onTransportError();\n        },\n        onRequestTimeout : () =>\n        {\n          this._session.onRequestTimeout();\n        },\n        onDialogError : () =>\n        {\n          this._session.onDialogError();\n        }\n      },\n      body\n    });\n  }\n\n  init_incoming(request)\n  {\n    this._direction = 'incoming';\n    this.request = request;\n\n    request.reply(200);\n\n    this._contentType = request.getHeader('content-type');\n    this._body = request.body;\n\n    this._session.newInfo({\n      originator : 'remote',\n      info       : this,\n      request\n    });\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/RTCSession/Info.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/RTCSession/ReferNotifier.js":
/*!************************************************************!*\
  !*** ./node_modules/jssip/lib/RTCSession/ReferNotifier.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const JsSIP_C = __webpack_require__(/*! ../Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:RTCSession:ReferNotifier');\n\nconst C = {\n  event_type : 'refer',\n  body_type  : 'message/sipfrag;version=2.0',\n  expires    : 300\n};\n\nmodule.exports = class ReferNotifier\n{\n  constructor(session, id, expires)\n  {\n    this._session = session;\n    this._id = id;\n    this._expires = expires || C.expires;\n    this._active = true;\n\n    // The creation of a Notifier results in an immediate NOTIFY.\n    this.notify(100);\n  }\n\n  notify(code, reason)\n  {\n    debug('notify()');\n\n    if (this._active === false)\n    {\n      return;\n    }\n\n    reason = reason || JsSIP_C.REASON_PHRASE[code] || '';\n\n    let state;\n\n    if (code >= 200)\n    {\n      state = 'terminated;reason=noresource';\n    }\n    else\n    {\n      state = `active;expires=${this._expires}`;\n    }\n\n    // Put this in a try/catch block.\n    this._session.sendRequest(JsSIP_C.NOTIFY, {\n      extraHeaders : [\n        `Event: ${C.event_type};id=${this._id}`,\n        `Subscription-State: ${state}`,\n        `Content-Type: ${C.body_type}`\n      ],\n      body          : `SIP/2.0 ${code} ${reason}`,\n      eventHandlers : {\n        // If a negative response is received, subscription is canceled.\n        onErrorResponse() { this._active = false; }\n      }\n    });\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/RTCSession/ReferNotifier.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/RTCSession/ReferSubscriber.js":
/*!**************************************************************!*\
  !*** ./node_modules/jssip/lib/RTCSession/ReferSubscriber.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nconst JsSIP_C = __webpack_require__(/*! ../Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst Grammar = __webpack_require__(/*! ../Grammar */ \"./node_modules/jssip/lib/Grammar.js\");\nconst Utils = __webpack_require__(/*! ../Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:RTCSession:ReferSubscriber');\n\nmodule.exports = class ReferSubscriber extends EventEmitter\n{\n  constructor(session)\n  {\n    super();\n\n    this._id = null;\n    this._session = session;\n  }\n\n  get id()\n  {\n    return this._id;\n  }\n\n  sendRefer(target, options = {})\n  {\n    debug('sendRefer()');\n\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const eventHandlers = options.eventHandlers || {};\n\n    // Set event handlers.\n    for (const event in eventHandlers)\n    {\n      if (Object.prototype.hasOwnProperty.call(eventHandlers, event))\n      {\n        this.on(event, eventHandlers[event]);\n      }\n    }\n\n    // Replaces URI header field.\n    let replaces = null;\n\n    if (options.replaces)\n    {\n      replaces = options.replaces._request.call_id;\n      replaces += `;to-tag=${options.replaces._to_tag}`;\n      replaces += `;from-tag=${options.replaces._from_tag}`;\n\n      replaces = encodeURIComponent(replaces);\n    }\n\n    // Refer-To header field.\n    const referTo = `Refer-To: <${target}${replaces?`?Replaces=${replaces}`:''}>`;\n\n    extraHeaders.push(referTo);\n\n    extraHeaders.push(`Contact: ${this._session.contact}`);\n\n    const request = this._session.sendRequest(JsSIP_C.REFER, {\n      extraHeaders,\n      eventHandlers : {\n        onSuccessResponse : (response) =>\n        {\n          this._requestSucceeded(response);\n        },\n        onErrorResponse : (response) =>\n        {\n          this._requestFailed(response, JsSIP_C.causes.REJECTED);\n        },\n        onTransportError : () =>\n        {\n          this._requestFailed(null, JsSIP_C.causes.CONNECTION_ERROR);\n        },\n        onRequestTimeout : () =>\n        {\n          this._requestFailed(null, JsSIP_C.causes.REQUEST_TIMEOUT);\n        },\n        onDialogError : () =>\n        {\n          this._requestFailed(null, JsSIP_C.causes.DIALOG_ERROR);\n        }\n      }\n    });\n\n    this._id = request.cseq;\n  }\n\n  receiveNotify(request)\n  {\n    debug('receiveNotify()');\n\n    if (!request.body)\n    {\n      return;\n    }\n\n    const status_line = Grammar.parse(request.body.trim(), 'Status_Line');\n\n    if (status_line === -1)\n    {\n      debug(`receiveNotify() | error parsing NOTIFY body: \"${request.body}\"`);\n\n      return;\n    }\n\n    switch (true)\n    {\n      case /^100$/.test(status_line.status_code):\n        this.emit('trying', {\n          request,\n          status_line\n        });\n        break;\n\n      case /^1[0-9]{2}$/.test(status_line.status_code):\n        this.emit('progress', {\n          request,\n          status_line\n        });\n        break;\n\n      case /^2[0-9]{2}$/.test(status_line.status_code):\n        this.emit('accepted', {\n          request,\n          status_line\n        });\n        break;\n\n      default:\n        this.emit('failed', {\n          request,\n          status_line\n        });\n        break;\n    }\n  }\n\n  _requestSucceeded(response)\n  {\n    debug('REFER succeeded');\n\n    debug('emit \"requestSucceeded\"');\n\n    this.emit('requestSucceeded', {\n      response\n    });\n  }\n\n  _requestFailed(response, cause)\n  {\n    debug('REFER failed');\n\n    debug('emit \"requestFailed\"');\n\n    this.emit('requestFailed', {\n      response : response || null,\n      cause\n    });\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/RTCSession/ReferSubscriber.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Registrator.js":
/*!***********************************************!*\
  !*** ./node_modules/jssip/lib/Registrator.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib/SIPMessage.js\");\nconst RequestSender = __webpack_require__(/*! ./RequestSender */ \"./node_modules/jssip/lib/RequestSender.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:Registrator');\n\nconst MIN_REGISTER_EXPIRES = 10; // In seconds.\n\nmodule.exports = class Registrator\n{\n  constructor(ua, transport)\n  {\n    const reg_id=1; // Force reg_id to 1.\n\n    this._ua = ua;\n    this._transport = transport;\n\n    this._registrar = ua.configuration.registrar_server;\n    this._expires = ua.configuration.register_expires;\n\n    // Call-ID and CSeq values RFC3261 10.2.\n    this._call_id = Utils.createRandomToken(22);\n    this._cseq = 0;\n\n    this._to_uri = ua.configuration.uri;\n\n    this._registrationTimer = null;\n\n    // Ongoing Register request.\n    this._registering = false;\n\n    // Set status.\n    this._registered = false;\n\n    // Contact header.\n    this._contact = this._ua.contact.toString();\n\n    // Sip.ice media feature tag (RFC 5768).\n    this._contact += ';+sip.ice';\n\n    // Custom headers for REGISTER and un-REGISTER.\n    this._extraHeaders = [];\n\n    // Custom Contact header params for REGISTER and un-REGISTER.\n    this._extraContactParams = '';\n\n    if (reg_id)\n    {\n      this._contact += `;reg-id=${reg_id}`;\n      this._contact += `;+sip.instance=\"<urn:uuid:${this._ua.configuration.instance_id}>\"`;\n    }\n  }\n\n  get registered()\n  {\n    return this._registered;\n  }\n\n  setExtraHeaders(extraHeaders)\n  {\n    if (! Array.isArray(extraHeaders))\n    {\n      extraHeaders = [];\n    }\n\n    this._extraHeaders = extraHeaders.slice();\n  }\n\n  setExtraContactParams(extraContactParams)\n  {\n    if (! (extraContactParams instanceof Object))\n    {\n      extraContactParams = {};\n    }\n\n    // Reset it.\n    this._extraContactParams = '';\n\n    for (const param_key in extraContactParams)\n    {\n      if (Object.prototype.hasOwnProperty.call(extraContactParams, param_key))\n      {\n        const param_value = extraContactParams[param_key];\n\n        this._extraContactParams += (`;${param_key}`);\n        if (param_value)\n        {\n          this._extraContactParams += (`=${param_value}`);\n        }\n      }\n    }\n  }\n\n  register()\n  {\n    if (this._registering)\n    {\n      debug('Register request in progress...');\n\n      return;\n    }\n\n    const extraHeaders = this._extraHeaders.slice();\n\n    extraHeaders.push(`Contact: \\\n${this._contact};expires=${this._expires}${this._extraContactParams}`);\n    extraHeaders.push(`Expires: ${this._expires}`);\n\n    const request = new SIPMessage.OutgoingRequest(\n      JsSIP_C.REGISTER, this._registrar, this._ua, {\n        'to_uri'  : this._to_uri,\n        'call_id' : this._call_id,\n        'cseq'    : (this._cseq += 1)\n      }, extraHeaders);\n\n    const request_sender = new RequestSender(this._ua, request, {\n      onRequestTimeout : () =>\n      {\n        this._registrationFailure(null, JsSIP_C.causes.REQUEST_TIMEOUT);\n      },\n      onTransportError : () =>\n      {\n        this._registrationFailure(null, JsSIP_C.causes.CONNECTION_ERROR);\n      },\n      // Increase the CSeq on authentication.\n      onAuthenticated : () =>\n      {\n        this._cseq += 1;\n      },\n      onReceiveResponse : (response) =>\n      {\n        // Discard responses to older REGISTER/un-REGISTER requests.\n        if (response.cseq !== this._cseq)\n        {\n          return;\n        }\n\n        // Clear registration timer.\n        if (this._registrationTimer !== null)\n        {\n          clearTimeout(this._registrationTimer);\n          this._registrationTimer = null;\n        }\n\n        switch (true)\n        {\n          case /^1[0-9]{2}$/.test(response.status_code):\n          {\n            // Ignore provisional responses.\n            break;\n          }\n\n          case /^2[0-9]{2}$/.test(response.status_code):\n          {\n            this._registering = false;\n\n            if (!response.hasHeader('Contact'))\n            {\n              debug('no Contact header in response to REGISTER, response ignored');\n\n              break;\n            }\n\n            const contacts = response.headers['Contact']\n              .reduce((a, b) => a.concat(b.parsed), []);\n\n            // Get the Contact pointing to us and update the expires value accordingly.\n            const contact = contacts.find((element) => (\n              element.uri.user === this._ua.contact.uri.user\n            ));\n\n            if (!contact)\n            {\n              debug('no Contact header pointing to us, response ignored');\n\n              break;\n            }\n\n            let expires = contact.getParam('expires');\n\n            if (!expires && response.hasHeader('expires'))\n            {\n              expires = response.getHeader('expires');\n            }\n\n            if (!expires)\n            {\n              expires = this._expires;\n            }\n\n            expires = Number(expires);\n\n            if (expires < MIN_REGISTER_EXPIRES)\n              expires = MIN_REGISTER_EXPIRES;\n\n            // Re-Register or emit an event before the expiration interval has elapsed.\n            // For that, decrease the expires value. ie: 3 seconds.\n            this._registrationTimer = setTimeout(() =>\n            {\n              this._registrationTimer = null;\n              // If there are no listeners for registrationExpiring, renew registration.\n              // If there are listeners, let the function listening do the register call.\n              if (this._ua.listeners('registrationExpiring').length === 0)\n              {\n                this.register();\n              }\n              else\n              {\n                this._ua.emit('registrationExpiring');\n              }\n            }, (expires * 1000) - 5000);\n\n            // Save gruu values.\n            if (contact.hasParam('temp-gruu'))\n            {\n              this._ua.contact.temp_gruu = contact.getParam('temp-gruu').replace(/\"/g, '');\n            }\n            if (contact.hasParam('pub-gruu'))\n            {\n              this._ua.contact.pub_gruu = contact.getParam('pub-gruu').replace(/\"/g, '');\n            }\n\n            if (! this._registered)\n            {\n              this._registered = true;\n              this._ua.registered({ response });\n            }\n\n            break;\n          }\n\n          // Interval too brief RFC3261 10.2.8.\n          case /^423$/.test(response.status_code):\n          {\n            if (response.hasHeader('min-expires'))\n            {\n              // Increase our registration interval to the suggested minimum.\n              this._expires = Number(response.getHeader('min-expires'));\n\n              if (this._expires < MIN_REGISTER_EXPIRES)\n                this._expires = MIN_REGISTER_EXPIRES;\n\n              // Attempt the registration again immediately.\n              this.register();\n            }\n            else\n            { // This response MUST contain a Min-Expires header field.\n              debug('423 response received for REGISTER without Min-Expires');\n\n              this._registrationFailure(response, JsSIP_C.causes.SIP_FAILURE_CODE);\n            }\n\n            break;\n          }\n\n          default:\n          {\n            const cause = Utils.sipErrorCause(response.status_code);\n\n            this._registrationFailure(response, cause);\n          }\n        }\n      }\n    });\n\n    this._registering = true;\n    request_sender.send();\n  }\n\n  unregister(options = {})\n  {\n    if (!this._registered)\n    {\n      debug('already unregistered');\n\n      return;\n    }\n\n    this._registered = false;\n\n    // Clear the registration timer.\n    if (this._registrationTimer !== null)\n    {\n      clearTimeout(this._registrationTimer);\n      this._registrationTimer = null;\n    }\n\n    const extraHeaders = this._extraHeaders.slice();\n\n    if (options.all)\n    {\n      extraHeaders.push(`Contact: *${this._extraContactParams}`);\n    }\n    else\n    {\n      extraHeaders.push(`Contact: ${this._contact};expires=0${this._extraContactParams}`);\n    }\n\n    extraHeaders.push('Expires: 0');\n\n    const request = new SIPMessage.OutgoingRequest(\n      JsSIP_C.REGISTER, this._registrar, this._ua, {\n        'to_uri'  : this._to_uri,\n        'call_id' : this._call_id,\n        'cseq'    : (this._cseq += 1)\n      }, extraHeaders);\n\n    const request_sender = new RequestSender(this._ua, request, {\n      onRequestTimeout : () =>\n      {\n        this._unregistered(null, JsSIP_C.causes.REQUEST_TIMEOUT);\n      },\n      onTransportError : () =>\n      {\n        this._unregistered(null, JsSIP_C.causes.CONNECTION_ERROR);\n      },\n      // Increase the CSeq on authentication.\n      onAuthenticated : () =>\n      {\n        this._cseq += 1;\n      },\n      onReceiveResponse : (response) =>\n      {\n        switch (true)\n        {\n          case /^1[0-9]{2}$/.test(response.status_code):\n            // Ignore provisional responses.\n            break;\n          case /^2[0-9]{2}$/.test(response.status_code):\n            this._unregistered(response);\n            break;\n          default:\n          {\n            const cause = Utils.sipErrorCause(response.status_code);\n\n            this._unregistered(response, cause);\n          }\n        }\n      }\n    });\n\n    request_sender.send();\n  }\n\n  close()\n  {\n    if (this._registered)\n    {\n      this.unregister();\n    }\n  }\n\n\n  onTransportClosed()\n  {\n    this._registering = false;\n    if (this._registrationTimer !== null)\n    {\n      clearTimeout(this._registrationTimer);\n      this._registrationTimer = null;\n    }\n\n    if (this._registered)\n    {\n      this._registered = false;\n      this._ua.unregistered({});\n    }\n  }\n\n  _registrationFailure(response, cause)\n  {\n    this._registering = false;\n    this._ua.registrationFailed({\n      response : response || null,\n      cause\n    });\n\n    if (this._registered)\n    {\n      this._registered = false;\n      this._ua.unregistered({\n        response : response || null,\n        cause\n      });\n    }\n  }\n\n  _unregistered(response, cause)\n  {\n    this._registering = false;\n    this._registered = false;\n    this._ua.unregistered({\n      response : response || null,\n      cause    : cause || null\n    });\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Registrator.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/RequestSender.js":
/*!*************************************************!*\
  !*** ./node_modules/jssip/lib/RequestSender.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst DigestAuthentication = __webpack_require__(/*! ./DigestAuthentication */ \"./node_modules/jssip/lib/DigestAuthentication.js\");\nconst Transactions = __webpack_require__(/*! ./Transactions */ \"./node_modules/jssip/lib/Transactions.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:RequestSender');\n\n// Default event handlers.\nconst EventHandlers = {\n  onRequestTimeout  : () => {},\n  onTransportError  : () => {},\n  onReceiveResponse : () => {},\n  onAuthenticated   : () => {}\n};\n\nmodule.exports = class RequestSender\n{\n  constructor(ua, request, eventHandlers)\n  {\n    this._ua = ua;\n    this._eventHandlers = eventHandlers;\n    this._method = request.method;\n    this._request = request;\n    this._auth = null;\n    this._challenged = false;\n    this._staled = false;\n\n    // Define the undefined handlers.\n    for (const handler in EventHandlers)\n    {\n      if (Object.prototype.hasOwnProperty.call(EventHandlers, handler))\n      {\n        if (!this._eventHandlers[handler])\n        {\n          this._eventHandlers[handler] = EventHandlers[handler];\n        }\n      }\n    }\n\n    // If ua is in closing process or even closed just allow sending Bye and ACK.\n    if (ua.status === ua.C.STATUS_USER_CLOSED &&\n        (this._method !== JsSIP_C.BYE || this._method !== JsSIP_C.ACK))\n    {\n      this._eventHandlers.onTransportError();\n    }\n  }\n\n  /**\n  * Create the client transaction and send the message.\n  */\n  send()\n  {\n    const eventHandlers = {\n      onRequestTimeout  : () => { this._eventHandlers.onRequestTimeout(); },\n      onTransportError  : () => { this._eventHandlers.onTransportError(); },\n      onReceiveResponse : (response) => { this._receiveResponse(response); }\n    };\n\n    switch (this._method)\n    {\n      case 'INVITE':\n        this.clientTransaction = new Transactions.InviteClientTransaction(\n          this._ua, this._ua.transport, this._request, eventHandlers);\n        break;\n      case 'ACK':\n        this.clientTransaction = new Transactions.AckClientTransaction(\n          this._ua, this._ua.transport, this._request, eventHandlers);\n        break;\n      default:\n        this.clientTransaction = new Transactions.NonInviteClientTransaction(\n          this._ua, this._ua.transport, this._request, eventHandlers);\n    }\n\n    this.clientTransaction.send();\n  }\n\n  /**\n  * Called from client transaction when receiving a correct response to the request.\n  * Authenticate request if needed or pass the response back to the applicant.\n  */\n  _receiveResponse(response)\n  {\n    let challenge;\n    let authorization_header_name;\n    const status_code = response.status_code;\n\n    /*\n    * Authentication\n    * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n    */\n    if ((status_code === 401 || status_code === 407) &&\n        (this._ua.configuration.password !== null || this._ua.configuration.ha1 !== null))\n    {\n\n      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n      if (response.status_code === 401)\n      {\n        challenge = response.parseHeader('www-authenticate');\n        authorization_header_name = 'authorization';\n      }\n      else\n      {\n        challenge = response.parseHeader('proxy-authenticate');\n        authorization_header_name = 'proxy-authorization';\n      }\n\n      // Verify it seems a valid challenge.\n      if (!challenge)\n      {\n        debug(`${response.status_code} with wrong or missing challenge, cannot authenticate`);\n        this._eventHandlers.onReceiveResponse(response);\n\n        return;\n      }\n\n      if (!this._challenged || (!this._staled && challenge.stale === true))\n      {\n        if (!this._auth)\n        {\n          this._auth = new DigestAuthentication({\n            username : this._ua.configuration.authorization_user,\n            password : this._ua.configuration.password,\n            realm    : this._ua.configuration.realm,\n            ha1      : this._ua.configuration.ha1\n          });\n        }\n\n        // Verify that the challenge is really valid.\n        if (!this._auth.authenticate(this._request, challenge))\n        {\n          this._eventHandlers.onReceiveResponse(response);\n\n          return;\n        }\n        this._challenged = true;\n\n        // Update ha1 and realm in the UA.\n        this._ua.set('realm', this._auth.get('realm'));\n        this._ua.set('ha1', this._auth.get('ha1'));\n\n        if (challenge.stale)\n        {\n          this._staled = true;\n        }\n\n        this._request = this._request.clone();\n        this._request.cseq += 1;\n        this._request.setHeader('cseq', `${this._request.cseq} ${this._method}`);\n        this._request.setHeader(authorization_header_name, this._auth.toString());\n\n        this._eventHandlers.onAuthenticated(this._request);\n        this.send();\n      }\n      else\n      {\n        this._eventHandlers.onReceiveResponse(response);\n      }\n    }\n    else\n    {\n      this._eventHandlers.onReceiveResponse(response);\n    }\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/RequestSender.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/SIPMessage.js":
/*!**********************************************!*\
  !*** ./node_modules/jssip/lib/SIPMessage.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const sdp_transform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nconst JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst NameAddrHeader = __webpack_require__(/*! ./NameAddrHeader */ \"./node_modules/jssip/lib/NameAddrHeader.js\");\nconst Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib/Grammar.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:SIPMessage');\n\n/**\n * -param {String} method request method\n * -param {String} ruri request uri\n * -param {UA} ua\n * -param {Object} params parameters that will have priority over ua.configuration parameters:\n * <br>\n *  - cseq, call_id, from_tag, from_uri, from_display_name, to_uri, to_tag, route_set\n * -param {Object} [headers] extra headers\n * -param {String} [body]\n */\nclass OutgoingRequest\n{\n  constructor(method, ruri, ua, params, extraHeaders, body)\n  {\n    // Mandatory parameters check.\n    if (!method || !ruri || !ua)\n    {\n      return null;\n    }\n\n    params = params || {};\n\n    this.ua = ua;\n    this.headers = {};\n    this.method = method;\n    this.ruri = ruri;\n    this.body = body;\n    this.extraHeaders = Utils.cloneArray(extraHeaders);\n\n    // Fill the Common SIP Request Headers.\n\n    // Route.\n    if (params.route_set)\n    {\n      this.setHeader('route', params.route_set);\n    }\n    else if (ua.configuration.use_preloaded_route)\n    {\n      this.setHeader('route', `<${ua.transport.sip_uri};lr>`);\n    }\n\n    // Via.\n    // Empty Via header. Will be filled by the client transaction.\n    this.setHeader('via', '');\n\n    // Max-Forwards.\n    this.setHeader('max-forwards', JsSIP_C.MAX_FORWARDS);\n\n    // To\n    const to_uri = params.to_uri || ruri;\n    const to_params = params.to_tag ? { tag: params.to_tag } : null;\n    const to_display_name = typeof params.to_display_name !== 'undefined' ? params.to_display_name : null;\n\n    this.to = new NameAddrHeader(to_uri, to_display_name, to_params);\n    this.setHeader('to', this.to.toString());\n\n    // From.\n    const from_uri = params.from_uri || ua.configuration.uri;\n    const from_params = { tag: params.from_tag || Utils.newTag() };\n    let display_name;\n\n    if (typeof params.from_display_name !== 'undefined')\n    {\n      display_name = params.from_display_name;\n    }\n    else if (ua.configuration.display_name)\n    {\n      display_name = ua.configuration.display_name;\n    }\n    else\n    {\n      display_name = null;\n    }\n\n    this.from = new NameAddrHeader(from_uri, display_name, from_params);\n    this.setHeader('from', this.from.toString());\n\n    // Call-ID.\n    const call_id = params.call_id ||\n      (ua.configuration.jssip_id + Utils.createRandomToken(15));\n\n    this.call_id = call_id;\n    this.setHeader('call-id', call_id);\n\n    // CSeq.\n    const cseq = params.cseq || Math.floor(Math.random() * 10000);\n\n    this.cseq = cseq;\n    this.setHeader('cseq', `${cseq} ${method}`);\n  }\n\n  /**\n   * Replace the the given header by the given value.\n   * -param {String} name header name\n   * -param {String | Array} value header value\n   */\n  setHeader(name, value)\n  {\n    // Remove the header from extraHeaders if present.\n    const regexp = new RegExp(`^\\\\s*${name}\\\\s*:`, 'i');\n\n    for (let idx=0; idx<this.extraHeaders.length; idx++)\n    {\n      if (regexp.test(this.extraHeaders[idx]))\n      {\n        this.extraHeaders.splice(idx, 1);\n      }\n    }\n\n    this.headers[Utils.headerize(name)] = (Array.isArray(value)) ? value : [ value ];\n  }\n\n  /**\n   * Get the value of the given header name at the given position.\n   * -param {String} name header name\n   * -returns {String|undefined} Returns the specified header, null if header doesn't exist.\n   */\n  getHeader(name)\n  {\n    const headers = this.headers[Utils.headerize(name)];\n\n    if (headers)\n    {\n      if (headers[0])\n      {\n        return headers[0];\n      }\n    }\n    else\n    {\n      const regexp = new RegExp(`^\\\\s*${name}\\\\s*:`, 'i');\n\n      for (const header of this.extraHeaders)\n      {\n        if (regexp.test(header))\n        {\n          return header.substring(header.indexOf(':')+1).trim();\n        }\n      }\n    }\n\n    return;\n  }\n\n  /**\n   * Get the header/s of the given name.\n   * -param {String} name header name\n   * -returns {Array} Array with all the headers of the specified name.\n   */\n  getHeaders(name)\n  {\n    const headers = this.headers[Utils.headerize(name)];\n    const result = [];\n\n    if (headers)\n    {\n      for (const header of headers)\n      {\n        result.push(header);\n      }\n\n      return result;\n    }\n    else\n    {\n      const regexp = new RegExp(`^\\\\s*${name}\\\\s*:`, 'i');\n\n      for (const header of this.extraHeaders)\n      {\n        if (regexp.test(header))\n        {\n          result.push(header.substring(header.indexOf(':')+1).trim());\n        }\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   * Verify the existence of the given header.\n   * -param {String} name header name\n   * -returns {boolean} true if header with given name exists, false otherwise\n   */\n  hasHeader(name)\n  {\n    if (this.headers[Utils.headerize(name)])\n    {\n      return true;\n    }\n    else\n    {\n      const regexp = new RegExp(`^\\\\s*${name}\\\\s*:`, 'i');\n\n      for (const header of this.extraHeaders)\n      {\n        if (regexp.test(header))\n        {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Parse the current body as a SDP and store the resulting object\n   * into this.sdp.\n   * -param {Boolean} force: Parse even if this.sdp already exists.\n   *\n   * Returns this.sdp.\n   */\n  parseSDP(force)\n  {\n    if (!force && this.sdp)\n    {\n      return this.sdp;\n    }\n    else\n    {\n      this.sdp = sdp_transform.parse(this.body || '');\n\n      return this.sdp;\n    }\n  }\n\n  toString()\n  {\n    let msg = `${this.method} ${this.ruri} SIP/2.0\\r\\n`;\n\n    for (const headerName in this.headers)\n    {\n      if (Object.prototype.hasOwnProperty.call(this.headers, headerName))\n      {\n        for (const headerValue of this.headers[headerName])\n        {\n          msg += `${headerName}: ${headerValue}\\r\\n`;\n        }\n      }\n    }\n\n    for (const header of this.extraHeaders)\n    {\n      msg += `${header.trim()}\\r\\n`;\n    }\n\n    // Supported.\n    const supported = [];\n\n    switch (this.method)\n    {\n      case JsSIP_C.REGISTER:\n        supported.push('path', 'gruu');\n        break;\n      case JsSIP_C.INVITE:\n        if (this.ua.configuration.session_timers)\n        {\n          supported.push('timer');\n        }\n        if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu)\n        {\n          supported.push('gruu');\n        }\n        supported.push('ice', 'replaces');\n        break;\n      case JsSIP_C.UPDATE:\n        if (this.ua.configuration.session_timers)\n        {\n          supported.push('timer');\n        }\n        supported.push('ice');\n        break;\n    }\n\n    supported.push('outbound');\n\n    const userAgent = this.ua.configuration.user_agent || JsSIP_C.USER_AGENT;\n\n    // Allow.\n    msg += `Allow: ${JsSIP_C.ALLOWED_METHODS}\\r\\n`;\n    msg += `Supported: ${supported}\\r\\n`;\n    msg += `User-Agent: ${userAgent}\\r\\n`;\n\n    if (this.body)\n    {\n      const length = Utils.str_utf8_length(this.body);\n\n      msg += `Content-Length: ${length}\\r\\n\\r\\n`;\n      msg += this.body;\n    }\n    else\n    {\n      msg += 'Content-Length: 0\\r\\n\\r\\n';\n    }\n\n    return msg;\n  }\n\n  clone()\n  {\n    const request = new OutgoingRequest(this.method, this.ruri, this.ua);\n\n    Object.keys(this.headers).forEach(function(name)\n    {\n      request.headers[name] = this.headers[name].slice();\n    }, this);\n\n    request.body = this.body;\n    request.extraHeaders = Utils.cloneArray(this.extraHeaders);\n    request.to = this.to;\n    request.from = this.from;\n    request.call_id = this.call_id;\n    request.cseq = this.cseq;\n\n    return request;\n  }\n}\n\nclass InitialOutgoingInviteRequest extends OutgoingRequest\n{\n  constructor(ruri, ua, params, extraHeaders, body)\n  {\n    super(JsSIP_C.INVITE, ruri, ua, params, extraHeaders, body);\n\n    this.transaction = null;\n  }\n\n  cancel(reason)\n  {\n    this.transaction.cancel(reason);\n  }\n\n  clone()\n  {\n    const request = new InitialOutgoingInviteRequest(this.ruri, this.ua);\n\n    Object.keys(this.headers).forEach(function(name)\n    {\n      request.headers[name] = this.headers[name].slice();\n    }, this);\n\n    request.body = this.body;\n    request.extraHeaders = Utils.cloneArray(this.extraHeaders);\n    request.to = this.to;\n    request.from = this.from;\n    request.call_id = this.call_id;\n    request.cseq = this.cseq;\n\n    request.transaction = this.transaction;\n\n    return request;\n  }\n}\n\nclass IncomingMessage\n{\n  constructor()\n  {\n    this.data = null;\n    this.headers = null;\n    this.method = null;\n    this.via = null;\n    this.via_branch = null;\n    this.call_id = null;\n    this.cseq = null;\n    this.from = null;\n    this.from_tag = null;\n    this.to = null;\n    this.to_tag = null;\n    this.body = null;\n    this.sdp = null;\n  }\n\n  /**\n  * Insert a header of the given name and value into the last position of the\n  * header array.\n  */\n  addHeader(name, value)\n  {\n    const header = { raw: value };\n\n    name = Utils.headerize(name);\n\n    if (this.headers[name])\n    {\n      this.headers[name].push(header);\n    }\n    else\n    {\n      this.headers[name] = [ header ];\n    }\n  }\n\n  /**\n   * Get the value of the given header name at the given position.\n   */\n  getHeader(name)\n  {\n    const header = this.headers[Utils.headerize(name)];\n\n    if (header)\n    {\n      if (header[0])\n      {\n        return header[0].raw;\n      }\n    }\n    else\n    {\n      return;\n    }\n  }\n\n  /**\n   * Get the header/s of the given name.\n   */\n  getHeaders(name)\n  {\n    const headers = this.headers[Utils.headerize(name)];\n    const result = [];\n\n    if (!headers)\n    {\n      return [];\n    }\n\n    for (const header of headers)\n    {\n      result.push(header.raw);\n    }\n\n    return result;\n  }\n\n  /**\n   * Verify the existence of the given header.\n   */\n  hasHeader(name)\n  {\n    return (this.headers[Utils.headerize(name)]) ? true : false;\n  }\n\n  /**\n  * Parse the given header on the given index.\n  * -param {String} name header name\n  * -param {Number} [idx=0] header index\n  * -returns {Object|undefined} Parsed header object, undefined if the header\n  *  is not present or in case of a parsing error.\n  */\n  parseHeader(name, idx = 0)\n  {\n    name = Utils.headerize(name);\n\n    if (!this.headers[name])\n    {\n      debug(`header \"${name}\" not present`);\n\n      return;\n    }\n    else if (idx >= this.headers[name].length)\n    {\n      debug(`not so many \"${name}\" headers present`);\n\n      return;\n    }\n\n    const header = this.headers[name][idx];\n    const value = header.raw;\n\n    if (header.parsed)\n    {\n      return header.parsed;\n    }\n\n    // Substitute '-' by '_' for grammar rule matching.\n    const parsed = Grammar.parse(value, name.replace(/-/g, '_'));\n\n    if (parsed === -1)\n    {\n      this.headers[name].splice(idx, 1); // delete from headers\n      debug(`error parsing \"${name}\" header field with value \"${value}\"`);\n\n      return;\n    }\n    else\n    {\n      header.parsed = parsed;\n\n      return parsed;\n    }\n  }\n\n  /**\n   * Message Header attribute selector. Alias of parseHeader.\n   * -param {String} name header name\n   * -param {Number} [idx=0] header index\n   * -returns {Object|undefined} Parsed header object, undefined if the header\n   *  is not present or in case of a parsing error.\n   *\n   * -example\n   * message.s('via',3).port\n   */\n  s(name, idx)\n  {\n    return this.parseHeader(name, idx);\n  }\n\n  /**\n  * Replace the value of the given header by the value.\n  * -param {String} name header name\n  * -param {String} value header value\n  */\n  setHeader(name, value)\n  {\n    const header = { raw: value };\n\n    this.headers[Utils.headerize(name)] = [ header ];\n  }\n\n  /**\n   * Parse the current body as a SDP and store the resulting object\n   * into this.sdp.\n   * -param {Boolean} force: Parse even if this.sdp already exists.\n   *\n   * Returns this.sdp.\n   */\n  parseSDP(force)\n  {\n    if (!force && this.sdp)\n    {\n      return this.sdp;\n    }\n    else\n    {\n      this.sdp = sdp_transform.parse(this.body || '');\n\n      return this.sdp;\n    }\n  }\n\n  toString()\n  {\n    return this.data;\n  }\n}\n\nclass IncomingRequest extends IncomingMessage\n{\n  constructor(ua)\n  {\n    super();\n\n    this.ua = ua;\n    this.headers = {};\n    this.ruri = null;\n    this.transport = null;\n    this.server_transaction = null;\n  }\n\n  /**\n  * Stateful reply.\n  * -param {Number} code status code\n  * -param {String} reason reason phrase\n  * -param {Object} headers extra headers\n  * -param {String} body body\n  * -param {Function} [onSuccess] onSuccess callback\n  * -param {Function} [onFailure] onFailure callback\n  */\n  reply(code, reason, extraHeaders, body, onSuccess, onFailure)\n  {\n    const supported = [];\n    let to = this.getHeader('To');\n\n    code = code || null;\n    reason = reason || null;\n\n    // Validate code and reason values.\n    if (!code || (code < 100 || code > 699))\n    {\n      throw new TypeError(`Invalid status_code: ${code}`);\n    }\n    else if (reason && typeof reason !== 'string' && !(reason instanceof String))\n    {\n      throw new TypeError(`Invalid reason_phrase: ${reason}`);\n    }\n\n    reason = reason || JsSIP_C.REASON_PHRASE[code] || '';\n    extraHeaders = Utils.cloneArray(extraHeaders);\n\n    let response = `SIP/2.0 ${code} ${reason}\\r\\n`;\n\n    if (this.method === JsSIP_C.INVITE && code > 100 && code <= 200)\n    {\n      const headers = this.getHeaders('record-route');\n\n      for (const header of headers)\n      {\n        response += `Record-Route: ${header}\\r\\n`;\n      }\n    }\n\n    const vias = this.getHeaders('via');\n\n    for (const via of vias)\n    {\n      response += `Via: ${via}\\r\\n`;\n    }\n\n    if (!this.to_tag && code > 100)\n    {\n      to += `;tag=${Utils.newTag()}`;\n    }\n    else if (this.to_tag && !this.s('to').hasParam('tag'))\n    {\n      to += `;tag=${this.to_tag}`;\n    }\n\n    response += `To: ${to}\\r\\n`;\n    response += `From: ${this.getHeader('From')}\\r\\n`;\n    response += `Call-ID: ${this.call_id}\\r\\n`;\n    response += `CSeq: ${this.cseq} ${this.method}\\r\\n`;\n\n    for (const header of extraHeaders)\n    {\n      response += `${header.trim()}\\r\\n`;\n    }\n\n    // Supported.\n    switch (this.method)\n    {\n      case JsSIP_C.INVITE:\n        if (this.ua.configuration.session_timers)\n        {\n          supported.push('timer');\n        }\n        if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu)\n        {\n          supported.push('gruu');\n        }\n        supported.push('ice', 'replaces');\n        break;\n      case JsSIP_C.UPDATE:\n        if (this.ua.configuration.session_timers)\n        {\n          supported.push('timer');\n        }\n        if (body)\n        {\n          supported.push('ice');\n        }\n        supported.push('replaces');\n    }\n\n    supported.push('outbound');\n\n    // Allow and Accept.\n    if (this.method === JsSIP_C.OPTIONS)\n    {\n      response += `Allow: ${JsSIP_C.ALLOWED_METHODS}\\r\\n`;\n      response += `Accept: ${JsSIP_C.ACCEPTED_BODY_TYPES}\\r\\n`;\n    }\n    else if (code === 405)\n    {\n      response += `Allow: ${JsSIP_C.ALLOWED_METHODS}\\r\\n`;\n    }\n    else if (code === 415)\n    {\n      response += `Accept: ${JsSIP_C.ACCEPTED_BODY_TYPES}\\r\\n`;\n    }\n\n    response += `Supported: ${supported}\\r\\n`;\n\n    if (body)\n    {\n      const length = Utils.str_utf8_length(body);\n\n      response += 'Content-Type: application/sdp\\r\\n';\n      response += `Content-Length: ${length}\\r\\n\\r\\n`;\n      response += body;\n    }\n    else\n    {\n      response += `Content-Length: ${0}\\r\\n\\r\\n`;\n    }\n\n    this.server_transaction.receiveResponse(code, response, onSuccess, onFailure);\n  }\n\n  /**\n  * Stateless reply.\n  * -param {Number} code status code\n  * -param {String} reason reason phrase\n  */\n  reply_sl(code = null, reason = null)\n  {\n    const vias = this.getHeaders('via');\n\n    // Validate code and reason values.\n    if (!code || (code < 100 || code > 699))\n    {\n      throw new TypeError(`Invalid status_code: ${code}`);\n    }\n    else if (reason && typeof reason !== 'string' && !(reason instanceof String))\n    {\n      throw new TypeError(`Invalid reason_phrase: ${reason}`);\n    }\n\n    reason = reason || JsSIP_C.REASON_PHRASE[code] || '';\n\n    let response = `SIP/2.0 ${code} ${reason}\\r\\n`;\n\n    for (const via of vias)\n    {\n      response += `Via: ${via}\\r\\n`;\n    }\n\n    let to = this.getHeader('To');\n\n    if (!this.to_tag && code > 100)\n    {\n      to += `;tag=${Utils.newTag()}`;\n    }\n    else if (this.to_tag && !this.s('to').hasParam('tag'))\n    {\n      to += `;tag=${this.to_tag}`;\n    }\n\n    response += `To: ${to}\\r\\n`;\n    response += `From: ${this.getHeader('From')}\\r\\n`;\n    response += `Call-ID: ${this.call_id}\\r\\n`;\n    response += `CSeq: ${this.cseq} ${this.method}\\r\\n`;\n    response += `Content-Length: ${0}\\r\\n\\r\\n`;\n\n    this.transport.send(response);\n  }\n}\n\nclass IncomingResponse extends IncomingMessage\n{\n  constructor()\n  {\n    super();\n\n    this.headers = {};\n    this.status_code = null;\n    this.reason_phrase = null;\n  }\n}\n\nmodule.exports = {\n  OutgoingRequest,\n  InitialOutgoingInviteRequest,\n  IncomingRequest,\n  IncomingResponse\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/SIPMessage.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Socket.js":
/*!******************************************!*\
  !*** ./node_modules/jssip/lib/Socket.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib/Grammar.js\");\nconst debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:ERROR:Socket');\n\ndebugerror.log = console.warn.bind(console);\n\n/**\n * Interface documentation: https://jssip.net/documentation/$last_version/api/socket/\n *\n * interface Socket {\n *  attribute String via_transport\n *  attribute String url\n *  attribute String sip_uri\n *\n *  method connect();\n *  method disconnect();\n *  method send(data);\n *\n *  attribute EventHandler onconnect\n *  attribute EventHandler ondisconnect\n *  attribute EventHandler ondata\n * }\n *\n */\n\nexports.isSocket = (socket) =>\n{\n  // Ignore if an array is given.\n  if (Array.isArray(socket))\n  {\n    return false;\n  }\n\n  if (typeof socket === 'undefined')\n  {\n    debugerror('undefined JsSIP.Socket instance');\n\n    return false;\n  }\n\n  // Check Properties.\n  try\n  {\n    if (!Utils.isString(socket.url))\n    {\n      debugerror('missing or invalid JsSIP.Socket url property');\n      throw new Error();\n    }\n\n    if (!Utils.isString(socket.via_transport))\n    {\n      debugerror('missing or invalid JsSIP.Socket via_transport property');\n      throw new Error();\n    }\n\n    if (Grammar.parse(socket.sip_uri, 'SIP_URI') === -1)\n    {\n      debugerror('missing or invalid JsSIP.Socket sip_uri property');\n      throw new Error();\n    }\n  }\n  catch (e)\n  {\n    return false;\n  }\n\n  // Check Methods.\n  try\n  {\n    [ 'connect', 'disconnect', 'send' ].forEach((method) =>\n    {\n      if (!Utils.isFunction(socket[method]))\n      {\n        debugerror(`missing or invalid JsSIP.Socket method: ${method}`);\n        throw new Error();\n      }\n    });\n  }\n  catch (e)\n  {\n    return false;\n  }\n\n  return true;\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Socket.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Timers.js":
/*!******************************************!*\
  !*** ./node_modules/jssip/lib/Timers.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const T1 = 500, T2 = 4000, T4 = 5000;\n\nmodule.exports = {\n  T1,\n  T2,\n  T4,\n  TIMER_B                       : 64 * T1,\n  TIMER_D                       : 0 * T1,\n  TIMER_F                       : 64 * T1,\n  TIMER_H                       : 64 * T1,\n  TIMER_I                       : 0 * T1,\n  TIMER_J                       : 0 * T1,\n  TIMER_K                       : 0 * T4,\n  TIMER_L                       : 64 * T1,\n  TIMER_M                       : 64 * T1,\n  PROVISIONAL_RESPONSE_INTERVAL : 60000 // See RFC 3261 Section 13.3.1.1\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Timers.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Transactions.js":
/*!************************************************!*\
  !*** ./node_modules/jssip/lib/Transactions.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nconst JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib/SIPMessage.js\");\nconst Timers = __webpack_require__(/*! ./Timers */ \"./node_modules/jssip/lib/Timers.js\");\nconst debugnict = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:NonInviteClientTransaction');\nconst debugict = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:InviteClientTransaction');\nconst debugact = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:AckClientTransaction');\nconst debugnist = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:NonInviteServerTransaction');\nconst debugist = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:InviteServerTransaction');\n\nconst C = {\n  // Transaction states.\n  STATUS_TRYING     : 1,\n  STATUS_PROCEEDING : 2,\n  STATUS_CALLING    : 3,\n  STATUS_ACCEPTED   : 4,\n  STATUS_COMPLETED  : 5,\n  STATUS_TERMINATED : 6,\n  STATUS_CONFIRMED  : 7,\n\n  // Transaction types.\n  NON_INVITE_CLIENT : 'nict',\n  NON_INVITE_SERVER : 'nist',\n  INVITE_CLIENT     : 'ict',\n  INVITE_SERVER     : 'ist'\n};\n\nclass NonInviteClientTransaction extends EventEmitter\n{\n  constructor(ua, transport, request, eventHandlers)\n  {\n    super();\n\n    this.type = C.NON_INVITE_CLIENT;\n    this.id = `z9hG4bK${Math.floor(Math.random() * 10000000)}`;\n    this.ua = ua;\n    this.transport = transport;\n    this.request = request;\n    this.eventHandlers = eventHandlers;\n\n    let via = `SIP/2.0/${transport.via_transport}`;\n\n    via += ` ${ua.configuration.via_host};branch=${this.id}`;\n\n    this.request.setHeader('via', via);\n\n    this.ua.newTransaction(this);\n  }\n\n  get C()\n  {\n    return C;\n  }\n\n  stateChanged(state)\n  {\n    this.state = state;\n    this.emit('stateChanged');\n  }\n\n  send()\n  {\n    this.stateChanged(C.STATUS_TRYING);\n    this.F = setTimeout(() => { this.timer_F(); }, Timers.TIMER_F);\n\n    if (!this.transport.send(this.request))\n    {\n      this.onTransportError();\n    }\n  }\n\n  onTransportError()\n  {\n    debugnict(`transport error occurred, deleting transaction ${this.id}`);\n    clearTimeout(this.F);\n    clearTimeout(this.K);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n    this.eventHandlers.onTransportError();\n  }\n\n  timer_F()\n  {\n    debugnict(`Timer F expired for transaction ${this.id}`);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n    this.eventHandlers.onRequestTimeout();\n  }\n\n  timer_K()\n  {\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n\n  receiveResponse(response)\n  {\n    const status_code = response.status_code;\n\n    if (status_code < 200)\n    {\n      switch (this.state)\n      {\n        case C.STATUS_TRYING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_PROCEEDING);\n          this.eventHandlers.onReceiveResponse(response);\n          break;\n      }\n    }\n    else\n    {\n      switch (this.state)\n      {\n        case C.STATUS_TRYING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_COMPLETED);\n          clearTimeout(this.F);\n\n          if (status_code === 408)\n          {\n            this.eventHandlers.onRequestTimeout();\n          }\n          else\n          {\n            this.eventHandlers.onReceiveResponse(response);\n          }\n\n          this.K = setTimeout(() => { this.timer_K(); }, Timers.TIMER_K);\n          break;\n        case C.STATUS_COMPLETED:\n          break;\n      }\n    }\n  }\n}\n\nclass InviteClientTransaction extends EventEmitter\n{\n  constructor(ua, transport, request, eventHandlers)\n  {\n    super();\n\n    this.type = C.INVITE_CLIENT;\n    this.id = `z9hG4bK${Math.floor(Math.random() * 10000000)}`;\n    this.ua = ua;\n    this.transport = transport;\n    this.request = request;\n    this.eventHandlers = eventHandlers;\n    request.transaction = this;\n\n    let via = `SIP/2.0/${transport.via_transport}`;\n\n    via += ` ${ua.configuration.via_host};branch=${this.id}`;\n\n    this.request.setHeader('via', via);\n\n    this.ua.newTransaction(this);\n  }\n\n  get C()\n  {\n    return C;\n  }\n\n  stateChanged(state)\n  {\n    this.state = state;\n    this.emit('stateChanged');\n  }\n\n  send()\n  {\n    this.stateChanged(C.STATUS_CALLING);\n    this.B = setTimeout(() =>\n    {\n      this.timer_B();\n    }, Timers.TIMER_B);\n\n    if (!this.transport.send(this.request))\n    {\n      this.onTransportError();\n    }\n  }\n\n  onTransportError()\n  {\n    clearTimeout(this.B);\n    clearTimeout(this.D);\n    clearTimeout(this.M);\n\n    if (this.state !== C.STATUS_ACCEPTED)\n    {\n      debugict(`transport error occurred, deleting transaction ${this.id}`);\n      this.eventHandlers.onTransportError();\n    }\n\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n\n  // RFC 6026 7.2.\n  timer_M()\n  {\n    debugict(`Timer M expired for transaction ${this.id}`);\n\n    if (this.state === C.STATUS_ACCEPTED)\n    {\n      clearTimeout(this.B);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }\n\n  // RFC 3261 17.1.1.\n  timer_B()\n  {\n    debugict(`Timer B expired for transaction ${this.id}`);\n    if (this.state === C.STATUS_CALLING)\n    {\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n      this.eventHandlers.onRequestTimeout();\n    }\n  }\n\n  timer_D()\n  {\n    debugict(`Timer D expired for transaction ${this.id}`);\n    clearTimeout(this.B);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n\n  sendACK(response)\n  {\n    const ack = new SIPMessage.OutgoingRequest(JsSIP_C.ACK, this.request.ruri,\n      this.ua, {\n        'route_set' : this.request.getHeaders('route'),\n        'call_id'   : this.request.getHeader('call-id'),\n        'cseq'      : this.request.cseq\n      });\n\n    ack.setHeader('from', this.request.getHeader('from'));\n    ack.setHeader('via', this.request.getHeader('via'));\n    ack.setHeader('to', response.getHeader('to'));\n\n    this.D = setTimeout(() => { this.timer_D(); }, Timers.TIMER_D);\n\n    this.transport.send(ack);\n  }\n\n  cancel(reason)\n  {\n    // Send only if a provisional response (>100) has been received.\n    if (this.state !== C.STATUS_PROCEEDING)\n    {\n      return;\n    }\n\n    const cancel = new SIPMessage.OutgoingRequest(JsSIP_C.CANCEL, this.request.ruri,\n      this.ua, {\n        'route_set' : this.request.getHeaders('route'),\n        'call_id'   : this.request.getHeader('call-id'),\n        'cseq'      : this.request.cseq\n      });\n\n    cancel.setHeader('from', this.request.getHeader('from'));\n    cancel.setHeader('via', this.request.getHeader('via'));\n    cancel.setHeader('to', this.request.getHeader('to'));\n\n    if (reason)\n    {\n      cancel.setHeader('reason', reason);\n    }\n\n    this.transport.send(cancel);\n  }\n\n  receiveResponse(response)\n  {\n    const status_code = response.status_code;\n\n    if (status_code >= 100 && status_code <= 199)\n    {\n      switch (this.state)\n      {\n        case C.STATUS_CALLING:\n          this.stateChanged(C.STATUS_PROCEEDING);\n          this.eventHandlers.onReceiveResponse(response);\n          break;\n        case C.STATUS_PROCEEDING:\n          this.eventHandlers.onReceiveResponse(response);\n          break;\n      }\n    }\n    else if (status_code >= 200 && status_code <= 299)\n    {\n      switch (this.state)\n      {\n        case C.STATUS_CALLING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_ACCEPTED);\n          this.M = setTimeout(() =>\n          {\n            this.timer_M();\n          }, Timers.TIMER_M);\n          this.eventHandlers.onReceiveResponse(response);\n          break;\n        case C.STATUS_ACCEPTED:\n          this.eventHandlers.onReceiveResponse(response);\n          break;\n      }\n    }\n    else if (status_code >= 300 && status_code <= 699)\n    {\n      switch (this.state)\n      {\n        case C.STATUS_CALLING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_COMPLETED);\n          this.sendACK(response);\n          this.eventHandlers.onReceiveResponse(response);\n          break;\n        case C.STATUS_COMPLETED:\n          this.sendACK(response);\n          break;\n      }\n    }\n  }\n}\n\nclass AckClientTransaction extends EventEmitter\n{\n  constructor(ua, transport, request, eventHandlers)\n  {\n    super();\n\n    this.id = `z9hG4bK${Math.floor(Math.random() * 10000000)}`;\n    this.transport = transport;\n    this.request = request;\n    this.eventHandlers = eventHandlers;\n\n    let via = `SIP/2.0/${transport.via_transport}`;\n\n    via += ` ${ua.configuration.via_host};branch=${this.id}`;\n\n    this.request.setHeader('via', via);\n  }\n\n  get C()\n  {\n    return C;\n  }\n\n  send()\n  {\n    if (!this.transport.send(this.request))\n    {\n      this.onTransportError();\n    }\n  }\n\n  onTransportError()\n  {\n    debugact(`transport error occurred for transaction ${this.id}`);\n    this.eventHandlers.onTransportError();\n  }\n}\n\nclass NonInviteServerTransaction extends EventEmitter\n{\n  constructor(ua, transport, request)\n  {\n    super();\n\n    this.type = C.NON_INVITE_SERVER;\n    this.id = request.via_branch;\n    this.ua = ua;\n    this.transport = transport;\n    this.request = request;\n    this.last_response = '';\n    request.server_transaction = this;\n\n    this.state = C.STATUS_TRYING;\n\n    ua.newTransaction(this);\n  }\n\n  get C()\n  {\n    return C;\n  }\n\n  stateChanged(state)\n  {\n    this.state = state;\n    this.emit('stateChanged');\n  }\n\n  timer_J()\n  {\n    debugnist(`Timer J expired for transaction ${this.id}`);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n\n  onTransportError()\n  {\n    if (!this.transportError)\n    {\n      this.transportError = true;\n\n      debugnist(`transport error occurred, deleting transaction ${this.id}`);\n\n      clearTimeout(this.J);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }\n\n  receiveResponse(status_code, response, onSuccess, onFailure)\n  {\n    if (status_code === 100)\n    {\n      /* RFC 4320 4.1\n       * 'A SIP element MUST NOT\n       * send any provisional response with a\n       * Status-Code other than 100 to a non-INVITE request.'\n       */\n      switch (this.state)\n      {\n        case C.STATUS_TRYING:\n          this.stateChanged(C.STATUS_PROCEEDING);\n          if (!this.transport.send(response))\n          {\n            this.onTransportError();\n          }\n          break;\n        case C.STATUS_PROCEEDING:\n          this.last_response = response;\n          if (!this.transport.send(response))\n          {\n            this.onTransportError();\n            if (onFailure)\n            {\n              onFailure();\n            }\n          }\n          else if (onSuccess)\n          {\n            onSuccess();\n          }\n          break;\n      }\n    }\n    else if (status_code >= 200 && status_code <= 699)\n    {\n      switch (this.state)\n      {\n        case C.STATUS_TRYING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_COMPLETED);\n          this.last_response = response;\n          this.J = setTimeout(() =>\n          {\n            this.timer_J();\n          }, Timers.TIMER_J);\n          if (!this.transport.send(response))\n          {\n            this.onTransportError();\n            if (onFailure)\n            {\n              onFailure();\n            }\n          }\n          else if (onSuccess)\n          {\n            onSuccess();\n          }\n          break;\n        case C.STATUS_COMPLETED:\n          break;\n      }\n    }\n  }\n}\n\nclass InviteServerTransaction extends EventEmitter\n{\n  constructor(ua, transport, request)\n  {\n    super();\n\n    this.type = C.INVITE_SERVER;\n    this.id = request.via_branch;\n    this.ua = ua;\n    this.transport = transport;\n    this.request = request;\n    this.last_response = '';\n    request.server_transaction = this;\n\n    this.state = C.STATUS_PROCEEDING;\n\n    ua.newTransaction(this);\n\n    this.resendProvisionalTimer = null;\n\n    request.reply(100);\n  }\n\n  get C()\n  {\n    return C;\n  }\n\n  stateChanged(state)\n  {\n    this.state = state;\n    this.emit('stateChanged');\n  }\n\n  timer_H()\n  {\n    debugist(`Timer H expired for transaction ${this.id}`);\n\n    if (this.state === C.STATUS_COMPLETED)\n    {\n      debugist('ACK not received, dialog will be terminated');\n    }\n\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n\n  timer_I()\n  {\n    this.stateChanged(C.STATUS_TERMINATED);\n  }\n\n  // RFC 6026 7.1.\n  timer_L()\n  {\n    debugist(`Timer L expired for transaction ${this.id}`);\n\n    if (this.state === C.STATUS_ACCEPTED)\n    {\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }\n\n  onTransportError()\n  {\n    if (!this.transportError)\n    {\n      this.transportError = true;\n\n      debugist(`transport error occurred, deleting transaction ${this.id}`);\n\n      if (this.resendProvisionalTimer !== null)\n      {\n        clearInterval(this.resendProvisionalTimer);\n        this.resendProvisionalTimer = null;\n      }\n\n      clearTimeout(this.L);\n      clearTimeout(this.H);\n      clearTimeout(this.I);\n\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }\n\n  resend_provisional()\n  {\n    if (!this.transport.send(this.last_response))\n    {\n      this.onTransportError();\n    }\n  }\n\n  // INVITE Server Transaction RFC 3261 17.2.1.\n  receiveResponse(status_code, response, onSuccess, onFailure)\n  {\n    if (status_code >= 100 && status_code <= 199)\n    {\n      switch (this.state)\n      {\n        case C.STATUS_PROCEEDING:\n          if (!this.transport.send(response))\n          {\n            this.onTransportError();\n          }\n          this.last_response = response;\n          break;\n      }\n    }\n\n    if (status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING)\n    {\n      // Trigger the resendProvisionalTimer only for the first non 100 provisional response.\n      if (this.resendProvisionalTimer === null)\n      {\n        this.resendProvisionalTimer = setInterval(() =>\n        {\n          this.resend_provisional();\n        }, Timers.PROVISIONAL_RESPONSE_INTERVAL);\n      }\n    }\n    else if (status_code >= 200 && status_code <= 299)\n    {\n      switch (this.state)\n      {\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_ACCEPTED);\n          this.last_response = response;\n          this.L = setTimeout(() =>\n          {\n            this.timer_L();\n          }, Timers.TIMER_L);\n\n          if (this.resendProvisionalTimer !== null)\n          {\n            clearInterval(this.resendProvisionalTimer);\n            this.resendProvisionalTimer = null;\n          }\n\n          /* falls through */\n        case C.STATUS_ACCEPTED:\n          // Note that this point will be reached for proceeding this.state also.\n          if (!this.transport.send(response))\n          {\n            this.onTransportError();\n            if (onFailure)\n            {\n              onFailure();\n            }\n          }\n          else if (onSuccess)\n          {\n            onSuccess();\n          }\n          break;\n      }\n    }\n    else if (status_code >= 300 && status_code <= 699)\n    {\n      switch (this.state)\n      {\n        case C.STATUS_PROCEEDING:\n          if (this.resendProvisionalTimer !== null)\n          {\n            clearInterval(this.resendProvisionalTimer);\n            this.resendProvisionalTimer = null;\n          }\n\n          if (!this.transport.send(response))\n          {\n            this.onTransportError();\n            if (onFailure)\n            {\n              onFailure();\n            }\n          }\n          else\n          {\n            this.stateChanged(C.STATUS_COMPLETED);\n            this.H = setTimeout(() =>\n            {\n              this.timer_H();\n            }, Timers.TIMER_H);\n            if (onSuccess)\n            {\n              onSuccess();\n            }\n          }\n          break;\n      }\n    }\n  }\n}\n\n/**\n * INVITE:\n *  _true_ if retransmission\n *  _false_ new request\n *\n * ACK:\n *  _true_  ACK to non2xx response\n *  _false_ ACK must be passed to TU (accepted state)\n *          ACK to 2xx response\n *\n * CANCEL:\n *  _true_  no matching invite transaction\n *  _false_ matching invite transaction and no final response sent\n *\n * OTHER:\n *  _true_  retransmission\n *  _false_ new request\n */\nfunction checkTransaction({ _transactions }, request)\n{\n  let tr;\n\n  switch (request.method)\n  {\n    case JsSIP_C.INVITE:\n      tr = _transactions.ist[request.via_branch];\n      if (tr)\n      {\n        switch (tr.state)\n        {\n          case C.STATUS_PROCEEDING:\n            tr.transport.send(tr.last_response);\n            break;\n\n            // RFC 6026 7.1 Invite retransmission.\n            // Received while in C.STATUS_ACCEPTED state. Absorb it.\n          case C.STATUS_ACCEPTED:\n            break;\n        }\n\n        return true;\n      }\n      break;\n    case JsSIP_C.ACK:\n      tr = _transactions.ist[request.via_branch];\n\n      // RFC 6026 7.1.\n      if (tr)\n      {\n        if (tr.state === C.STATUS_ACCEPTED)\n        {\n          return false;\n        }\n        else if (tr.state === C.STATUS_COMPLETED)\n        {\n          tr.state = C.STATUS_CONFIRMED;\n          tr.I = setTimeout(() => { tr.timer_I(); }, Timers.TIMER_I);\n\n          return true;\n        }\n      }\n      // ACK to 2XX Response.\n      else\n      {\n        return false;\n      }\n      break;\n    case JsSIP_C.CANCEL:\n      tr = _transactions.ist[request.via_branch];\n      if (tr)\n      {\n        request.reply_sl(200);\n        if (tr.state === C.STATUS_PROCEEDING)\n        {\n          return false;\n        }\n        else\n        {\n          return true;\n        }\n      }\n      else\n      {\n        request.reply_sl(481);\n\n        return true;\n      }\n    default:\n\n      // Non-INVITE Server Transaction RFC 3261 17.2.2.\n      tr = _transactions.nist[request.via_branch];\n      if (tr)\n      {\n        switch (tr.state)\n        {\n          case C.STATUS_TRYING:\n            break;\n          case C.STATUS_PROCEEDING:\n          case C.STATUS_COMPLETED:\n            tr.transport.send(tr.last_response);\n            break;\n        }\n\n        return true;\n      }\n      break;\n  }\n}\n\nmodule.exports = {\n  C,\n  NonInviteClientTransaction,\n  InviteClientTransaction,\n  AckClientTransaction,\n  NonInviteServerTransaction,\n  InviteServerTransaction,\n  checkTransaction\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Transactions.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Transport.js":
/*!*********************************************!*\
  !*** ./node_modules/jssip/lib/Transport.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Socket = __webpack_require__(/*! ./Socket */ \"./node_modules/jssip/lib/Socket.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:Transport');\nconst debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:ERROR:Transport');\n\ndebugerror.log = console.warn.bind(console);\n\n/**\n * Constants\n */\nconst C = {\n  // Transport status.\n  STATUS_CONNECTED    : 0,\n  STATUS_CONNECTING   : 1,\n  STATUS_DISCONNECTED : 2,\n\n  // Socket status.\n  SOCKET_STATUS_READY : 0,\n  SOCKET_STATUS_ERROR : 1,\n\n  // Recovery options.\n  recovery_options : {\n    min_interval : 2, // minimum interval in seconds between recover attempts\n    max_interval : 30 // maximum interval in seconds between recover attempts\n  }\n};\n\n/*\n * Manages one or multiple JsSIP.Socket instances.\n * Is reponsible for transport recovery logic among all socket instances.\n *\n * @socket JsSIP::Socket instance\n */\nmodule.exports = class Transport\n{\n  constructor(sockets, recovery_options = C.recovery_options)\n  {\n    debug('new()');\n\n    this.status = C.STATUS_DISCONNECTED;\n\n    // Current socket.\n    this.socket = null;\n\n    // Socket collection.\n    this.sockets = [];\n\n    this.recovery_options = recovery_options;\n    this.recover_attempts = 0;\n    this.recovery_timer = null;\n\n    this.close_requested = false;\n\n    if (typeof sockets === 'undefined')\n    {\n      throw new TypeError('Invalid argument.' +\n                          ' undefined \\'sockets\\' argument');\n    }\n\n    if (!(sockets instanceof Array))\n    {\n      sockets = [ sockets ];\n    }\n\n    sockets.forEach(function(socket)\n    {\n      if (!Socket.isSocket(socket.socket))\n      {\n        throw new TypeError('Invalid argument.' +\n                            ' invalid \\'JsSIP.Socket\\' instance');\n      }\n\n      if (socket.weight && !Number(socket.weight))\n      {\n        throw new TypeError('Invalid argument.' +\n                            ' \\'weight\\' attribute is not a number');\n      }\n\n      this.sockets.push({\n        socket : socket.socket,\n        weight : socket.weight || 0,\n        status : C.SOCKET_STATUS_READY\n      });\n    }, this);\n\n    // Get the socket with higher weight.\n    this._getSocket();\n  }\n\n  /**\n   * Instance Methods\n   */\n\n  get via_transport()\n  {\n    return this.socket.via_transport;\n  }\n\n  get url()\n  {\n    return this.socket.url;\n  }\n\n  get sip_uri()\n  {\n    return this.socket.sip_uri;\n  }\n\n  connect()\n  {\n    debug('connect()');\n\n    if (this.isConnected())\n    {\n      debug('Transport is already connected');\n\n      return;\n    }\n    else if (this.isConnecting())\n    {\n      debug('Transport is connecting');\n\n      return;\n    }\n\n    this.close_requested = false;\n    this.status = C.STATUS_CONNECTING;\n    this.onconnecting({ socket: this.socket, attempts: this.recover_attempts });\n\n    if (!this.close_requested)\n    {\n      // Bind socket event callbacks.\n      this.socket.onconnect = this._onConnect.bind(this);\n      this.socket.ondisconnect = this._onDisconnect.bind(this);\n      this.socket.ondata = this._onData.bind(this);\n\n      this.socket.connect();\n    }\n\n    return;\n  }\n\n  disconnect()\n  {\n    debug('close()');\n\n    this.close_requested = true;\n    this.recover_attempts = 0;\n    this.status = C.STATUS_DISCONNECTED;\n\n    // Clear recovery_timer.\n    if (this.recovery_timer !== null)\n    {\n      clearTimeout(this.recovery_timer);\n      this.recovery_timer = null;\n    }\n\n    // Unbind socket event callbacks.\n    this.socket.onconnect = () => {};\n    this.socket.ondisconnect = () => {};\n    this.socket.ondata = () => {};\n\n    this.socket.disconnect();\n    this.ondisconnect({\n      socket : this.socket,\n      error  : false\n    });\n  }\n\n  send(data)\n  {\n    debug('send()');\n\n    if (!this.isConnected())\n    {\n      debugerror('unable to send message, transport is not connected');\n\n      return false;\n    }\n\n    const message = data.toString();\n\n    debug(`sending message:\\n\\n${message}\\n`);\n\n    return this.socket.send(message);\n  }\n\n  isConnected()\n  {\n    return this.status === C.STATUS_CONNECTED;\n  }\n\n  isConnecting()\n  {\n    return this.status === C.STATUS_CONNECTING;\n  }\n\n  /**\n   * Private API.\n   */\n\n  _reconnect()\n  {\n    this.recover_attempts+=1;\n\n    let k = Math.floor((Math.random() * Math.pow(2, this.recover_attempts)) +1);\n\n    if (k < this.recovery_options.min_interval)\n    {\n      k = this.recovery_options.min_interval;\n    }\n\n    else if (k > this.recovery_options.max_interval)\n    {\n      k = this.recovery_options.max_interval;\n    }\n\n    debug(`reconnection attempt: ${this.recover_attempts}. next connection attempt in ${k} seconds`);\n\n    this.recovery_timer = setTimeout(() =>\n    {\n      if (!this.close_requested && !(this.isConnected() || this.isConnecting()))\n      {\n        // Get the next available socket with higher weight.\n        this._getSocket();\n\n        // Connect the socket.\n        this.connect();\n      }\n    }, k * 1000);\n  }\n\n  /**\n   * get the next available socket with higher weight\n   */\n  _getSocket()\n  {\n\n    let candidates = [];\n\n    this.sockets.forEach((socket) =>\n    {\n      if (socket.status === C.SOCKET_STATUS_ERROR)\n      {\n        return; // continue the array iteration\n      }\n      else if (candidates.length === 0)\n      {\n        candidates.push(socket);\n      }\n      else if (socket.weight > candidates[0].weight)\n      {\n        candidates = [ socket ];\n      }\n      else if (socket.weight === candidates[0].weight)\n      {\n        candidates.push(socket);\n      }\n    });\n\n    if (candidates.length === 0)\n    {\n      // All sockets have failed. reset sockets status.\n      this.sockets.forEach((socket) =>\n      {\n        socket.status = C.SOCKET_STATUS_READY;\n      });\n\n      // Get next available socket.\n      this._getSocket();\n\n      return;\n    }\n\n    const idx = Math.floor((Math.random()* candidates.length));\n\n    this.socket = candidates[idx].socket;\n  }\n\n  /**\n   * Socket Event Handlers\n   */\n\n  _onConnect()\n  {\n    this.recover_attempts = 0;\n    this.status = C.STATUS_CONNECTED;\n\n    // Clear recovery_timer.\n    if (this.recovery_timer !== null)\n    {\n      clearTimeout(this.recovery_timer);\n      this.recovery_timer = null;\n    }\n\n    this.onconnect({ socket: this });\n  }\n\n  _onDisconnect(error, code, reason)\n  {\n    this.status = C.STATUS_DISCONNECTED;\n    this.ondisconnect({\n      socket : this.socket,\n      error,\n      code,\n      reason\n    });\n\n    if (this.close_requested)\n    {\n      return;\n    }\n\n    // Update socket status.\n    else\n    {\n      this.sockets.forEach(function(socket)\n      {\n        if (this.socket === socket.socket)\n        {\n          socket.status = C.SOCKET_STATUS_ERROR;\n        }\n      }, this);\n    }\n\n    this._reconnect(error);\n  }\n\n  _onData(data)\n  {\n    // CRLF Keep Alive response from server. Ignore it.\n    if (data === '\\r\\n')\n    {\n      debug('received message with CRLF Keep Alive response');\n\n      return;\n    }\n\n    // Binary message.\n    else if (typeof data !== 'string')\n    {\n      try\n      {\n        data = String.fromCharCode.apply(null, new Uint8Array(data));\n      }\n      catch (evt)\n      {\n        debug('received binary message failed to be converted into string,' +\n              ' message discarded');\n\n        return;\n      }\n\n      debug(`received binary message:\\n\\n${data}\\n`);\n    }\n\n    // Text message.\n    else\n    {\n      debug(`received text message:\\n\\n${data}\\n`);\n    }\n\n    this.ondata({ transport: this, message: data });\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Transport.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/UA.js":
/*!**************************************!*\
  !*** ./node_modules/jssip/lib/UA.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nconst JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst Registrator = __webpack_require__(/*! ./Registrator */ \"./node_modules/jssip/lib/Registrator.js\");\nconst RTCSession = __webpack_require__(/*! ./RTCSession */ \"./node_modules/jssip/lib/RTCSession.js\");\nconst Message = __webpack_require__(/*! ./Message */ \"./node_modules/jssip/lib/Message.js\");\nconst Transactions = __webpack_require__(/*! ./Transactions */ \"./node_modules/jssip/lib/Transactions.js\");\nconst Transport = __webpack_require__(/*! ./Transport */ \"./node_modules/jssip/lib/Transport.js\");\nconst Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst Exceptions = __webpack_require__(/*! ./Exceptions */ \"./node_modules/jssip/lib/Exceptions.js\");\nconst URI = __webpack_require__(/*! ./URI */ \"./node_modules/jssip/lib/URI.js\");\nconst Parser = __webpack_require__(/*! ./Parser */ \"./node_modules/jssip/lib/Parser.js\");\nconst SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib/SIPMessage.js\");\nconst sanityCheck = __webpack_require__(/*! ./sanityCheck */ \"./node_modules/jssip/lib/sanityCheck.js\");\nconst config = __webpack_require__(/*! ./Config */ \"./node_modules/jssip/lib/Config.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:UA');\nconst debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:ERROR:UA');\n\ndebugerror.log = console.warn.bind(console);\n\nconst C = {\n  // UA status codes.\n  STATUS_INIT        : 0,\n  STATUS_READY       : 1,\n  STATUS_USER_CLOSED : 2,\n  STATUS_NOT_READY   : 3,\n\n  // UA error codes.\n  CONFIGURATION_ERROR : 1,\n  NETWORK_ERROR       : 2\n};\n\n/**\n * The User-Agent class.\n * @class JsSIP.UA\n * @param {Object} configuration Configuration parameters.\n * @throws {JsSIP.Exceptions.ConfigurationError} If a configuration parameter is invalid.\n * @throws {TypeError} If no configuration is given.\n */\nmodule.exports = class UA extends EventEmitter\n{\n  // Expose C object.\n  static get C()\n  {\n    return C;\n  }\n\n  constructor(configuration)\n  {\n    debug('new() [configuration:%o]', configuration);\n\n    super();\n\n    this._cache = {\n      credentials : {}\n    };\n\n    this._configuration = Object.assign({}, config.settings);\n    this._dynConfiguration = {};\n    this._dialogs = {};\n\n    // User actions outside any session/dialog (MESSAGE).\n    this._applicants = {};\n\n    this._sessions = {};\n    this._transport = null;\n    this._contact = null;\n    this._status = C.STATUS_INIT;\n    this._error = null;\n    this._transactions = {\n      nist : {},\n      nict : {},\n      ist  : {},\n      ict  : {}\n    };\n\n    // Custom UA empty object for high level use.\n    this._data = {};\n\n    this._closeTimer = null;\n\n    // Check configuration argument.\n    if (configuration === undefined)\n    {\n      throw new TypeError('Not enough arguments');\n    }\n\n    // Load configuration.\n    try\n    {\n      this._loadConfig(configuration);\n    }\n    catch (e)\n    {\n      this._status = C.STATUS_NOT_READY;\n      this._error = C.CONFIGURATION_ERROR;\n      throw e;\n    }\n\n    // Initialize registrator.\n    this._registrator = new Registrator(this);\n  }\n\n  get C()\n  {\n    return C;\n  }\n\n  get status()\n  {\n    return this._status;\n  }\n\n  get contact()\n  {\n    return this._contact;\n  }\n\n  get configuration()\n  {\n    return this._configuration;\n  }\n\n  get transport()\n  {\n    return this._transport;\n  }\n\n  // =================\n  //  High Level API\n  // =================\n\n  /**\n   * Connect to the server if status = STATUS_INIT.\n   * Resume UA after being closed.\n   */\n  start()\n  {\n    debug('start()');\n\n    if (this._status === C.STATUS_INIT)\n    {\n      this._transport.connect();\n    }\n    else if (this._status === C.STATUS_USER_CLOSED)\n    {\n      debug('restarting UA');\n\n      // Disconnect.\n      if (this._closeTimer !== null)\n      {\n        clearTimeout(this._closeTimer);\n        this._closeTimer = null;\n        this._transport.disconnect();\n      }\n\n      // Reconnect.\n      this._status = C.STATUS_INIT;\n      this._transport.connect();\n    }\n    else if (this._status === C.STATUS_READY)\n    {\n      debug('UA is in READY status, not restarted');\n    }\n    else\n    {\n      debug('ERROR: connection is down, Auto-Recovery system is trying to reconnect');\n    }\n\n    // Set dynamic configuration.\n    this._dynConfiguration.register = this._configuration.register;\n  }\n\n  /**\n   * Register.\n   */\n  register()\n  {\n    debug('register()');\n\n    this._dynConfiguration.register = true;\n    this._registrator.register();\n  }\n\n  /**\n   * Unregister.\n   */\n  unregister(options)\n  {\n    debug('unregister()');\n\n    this._dynConfiguration.register = false;\n    this._registrator.unregister(options);\n  }\n\n  /**\n   * Get the Registrator instance.\n   */\n  registrator()\n  {\n    return this._registrator;\n  }\n\n  /**\n   * Registration state.\n   */\n  isRegistered()\n  {\n    return this._registrator.registered;\n  }\n\n  /**\n   * Connection state.\n   */\n  isConnected()\n  {\n    return this._transport.isConnected();\n  }\n\n  /**\n   * Make an outgoing call.\n   *\n   * -param {String} target\n   * -param {Object} [options]\n   *\n   * -throws {TypeError}\n   *\n   */\n  call(target, options)\n  {\n    debug('call()');\n\n    const session = new RTCSession(this);\n\n    session.connect(target, options);\n\n    return session;\n  }\n\n  /**\n   * Send a message.\n   *\n   * -param {String} target\n   * -param {String} body\n   * -param {Object} [options]\n   *\n   * -throws {TypeError}\n   *\n   */\n  sendMessage(target, body, options)\n  {\n    debug('sendMessage()');\n\n    const message = new Message(this);\n\n    message.send(target, body, options);\n\n    return message;\n  }\n\n  /**\n   * Terminate ongoing sessions.\n   */\n  terminateSessions(options)\n  {\n    debug('terminateSessions()');\n\n    for (const idx in this._sessions)\n    {\n      if (!this._sessions[idx].isEnded())\n      {\n        this._sessions[idx].terminate(options);\n      }\n    }\n  }\n\n  /**\n   * Gracefully close.\n   *\n   */\n  stop()\n  {\n    debug('stop()');\n\n    // Remove dynamic settings.\n    this._dynConfiguration = {};\n\n    if (this._status === C.STATUS_USER_CLOSED)\n    {\n      debug('UA already closed');\n\n      return;\n    }\n\n    // Close registrator.\n    this._registrator.close();\n\n    // If there are session wait a bit so CANCEL/BYE can be sent and their responses received.\n    const num_sessions = Object.keys(this._sessions).length;\n\n    // Run  _terminate_ on every Session.\n    for (const session in this._sessions)\n    {\n      if (Object.prototype.hasOwnProperty.call(this._sessions, session))\n      {\n        debug(`closing session ${session}`);\n        try { this._sessions[session].terminate(); }\n        catch (error) {}\n      }\n    }\n\n    // Run  _close_ on every applicant.\n    for (const applicant in this._applicants)\n    {\n      if (Object.prototype.hasOwnProperty.call(this._applicants, applicant))\n        try { this._applicants[applicant].close(); }\n        catch (error) {}\n    }\n\n    this._status = C.STATUS_USER_CLOSED;\n\n    const num_transactions =\n      Object.keys(this._transactions.nict).length +\n      Object.keys(this._transactions.nist).length +\n      Object.keys(this._transactions.ict).length +\n      Object.keys(this._transactions.ist).length;\n\n    if (num_transactions === 0 && num_sessions === 0)\n    {\n      this._transport.disconnect();\n    }\n    else\n    {\n      this._closeTimer = setTimeout(() =>\n      {\n        this._closeTimer = null;\n        this._transport.disconnect();\n      }, 2000);\n    }\n  }\n\n  /**\n   * Normalice a string into a valid SIP request URI\n   * -param {String} target\n   * -returns {JsSIP.URI|undefined}\n   */\n  normalizeTarget(target)\n  {\n    return Utils.normalizeTarget(target, this._configuration.hostport_params);\n  }\n\n  /**\n   * Allow retrieving configuration and autogenerated fields in runtime.\n   */\n  get(parameter)\n  {\n    switch (parameter)\n    {\n      case 'realm':\n        return this._configuration.realm;\n\n      case 'ha1':\n        return this._configuration.ha1;\n\n      default:\n        debugerror('get() | cannot get \"%s\" parameter in runtime', parameter);\n\n        return undefined;\n    }\n  }\n\n  /**\n   * Allow configuration changes in runtime.\n   * Returns true if the parameter could be set.\n   */\n  set(parameter, value)\n  {\n    switch (parameter)\n    {\n      case 'password': {\n        this._configuration.password = String(value);\n        break;\n      }\n\n      case 'realm': {\n        this._configuration.realm = String(value);\n        break;\n      }\n\n      case 'ha1': {\n        this._configuration.ha1 = String(value);\n        // Delete the plain SIP password.\n        this._configuration.password = null;\n        break;\n      }\n\n      case 'display_name': {\n        this._configuration.display_name = value;\n        break;\n      }\n\n      default:\n        debugerror('set() | cannot set \"%s\" parameter in runtime', parameter);\n\n        return false;\n    }\n\n    return true;\n  }\n\n  // ==========================\n  // Event Handlers.\n  // ==========================\n\n  /**\n   * new Transaction\n   */\n  newTransaction(transaction)\n  {\n    this._transactions[transaction.type][transaction.id] = transaction;\n    this.emit('newTransaction', {\n      transaction\n    });\n  }\n\n  /**\n   * Transaction destroyed.\n   */\n  destroyTransaction(transaction)\n  {\n    delete this._transactions[transaction.type][transaction.id];\n    this.emit('transactionDestroyed', {\n      transaction\n    });\n  }\n\n  /**\n   * new Dialog\n   */\n  newDialog(dialog)\n  {\n    this._dialogs[dialog.id] = dialog;\n  }\n\n  /**\n   * Dialog destroyed.\n   */\n  destroyDialog(dialog)\n  {\n    delete this._dialogs[dialog.id];\n  }\n\n  /**\n   *  new Message\n   */\n  newMessage(message, data)\n  {\n    this._applicants[message] = message;\n    this.emit('newMessage', data);\n  }\n\n  /**\n   *  Message destroyed.\n   */\n  destroyMessage(message)\n  {\n    delete this._applicants[message];\n  }\n\n  /**\n   * new RTCSession\n   */\n  newRTCSession(session, data)\n  {\n    this._sessions[session.id] = session;\n    this.emit('newRTCSession', data);\n  }\n\n  /**\n   * RTCSession destroyed.\n   */\n  destroyRTCSession(session)\n  {\n    delete this._sessions[session.id];\n  }\n\n  /**\n   * Registered\n   */\n  registered(data)\n  {\n    this.emit('registered', data);\n  }\n\n  /**\n   * Unregistered\n   */\n  unregistered(data)\n  {\n    this.emit('unregistered', data);\n  }\n\n  /**\n   * Registration Failed\n   */\n  registrationFailed(data)\n  {\n    this.emit('registrationFailed', data);\n  }\n\n  // =========================\n  // ReceiveRequest.\n  // =========================\n\n  /**\n   * Request reception\n   */\n  receiveRequest(request)\n  {\n    const method = request.method;\n\n    // Check that request URI points to us.\n    if (request.ruri.user !== this._configuration.uri.user &&\n        request.ruri.user !== this._contact.uri.user)\n    {\n      debug('Request-URI does not point to us');\n      if (request.method !== JsSIP_C.ACK)\n      {\n        request.reply_sl(404);\n      }\n\n      return;\n    }\n\n    // Check request URI scheme.\n    if (request.ruri.scheme === JsSIP_C.SIPS)\n    {\n      request.reply_sl(416);\n\n      return;\n    }\n\n    // Check transaction.\n    if (Transactions.checkTransaction(this, request))\n    {\n      return;\n    }\n\n    // Create the server transaction.\n    if (method === JsSIP_C.INVITE)\n    {\n      /* eslint-disable no-new */\n      new Transactions.InviteServerTransaction(this, this._transport, request);\n      /* eslint-enable no-new */\n    }\n    else if (method !== JsSIP_C.ACK && method !== JsSIP_C.CANCEL)\n    {\n      /* eslint-disable no-new */\n      new Transactions.NonInviteServerTransaction(this, this._transport, request);\n      /* eslint-enable no-new */\n    }\n\n    /* RFC3261 12.2.2\n     * Requests that do not change in any way the state of a dialog may be\n     * received within a dialog (for example, an OPTIONS request).\n     * They are processed as if they had been received outside the dialog.\n     */\n    if (method === JsSIP_C.OPTIONS)\n    {\n      request.reply(200);\n    }\n    else if (method === JsSIP_C.MESSAGE)\n    {\n      if (this.listeners('newMessage').length === 0)\n      {\n        request.reply(405);\n\n        return;\n      }\n      const message = new Message(this);\n\n      message.init_incoming(request);\n    }\n    else if (method === JsSIP_C.INVITE)\n    {\n      // Initial INVITE.\n      if (!request.to_tag && this.listeners('newRTCSession').length === 0)\n      {\n        request.reply(405);\n\n        return;\n      }\n    }\n\n    let dialog;\n    let session;\n\n    // Initial Request.\n    if (!request.to_tag)\n    {\n      switch (method)\n      {\n        case JsSIP_C.INVITE:\n          if (window.RTCPeerConnection)\n          { // TODO\n            if (request.hasHeader('replaces'))\n            {\n              const replaces = request.replaces;\n\n              dialog = this._findDialog(\n                replaces.call_id, replaces.from_tag, replaces.to_tag);\n              if (dialog)\n              {\n                session = dialog.owner;\n                if (!session.isEnded())\n                {\n                  session.receiveRequest(request);\n                }\n                else\n                {\n                  request.reply(603);\n                }\n              }\n              else\n              {\n                request.reply(481);\n              }\n            }\n            else\n            {\n              session = new RTCSession(this);\n              session.init_incoming(request);\n            }\n          }\n          else\n          {\n            debugerror('INVITE received but WebRTC is not supported');\n            request.reply(488);\n          }\n          break;\n        case JsSIP_C.BYE:\n          // Out of dialog BYE received.\n          request.reply(481);\n          break;\n        case JsSIP_C.CANCEL:\n          session = this._findSession(request);\n          if (session)\n          {\n            session.receiveRequest(request);\n          }\n          else\n          {\n            debug('received CANCEL request for a non existent session');\n          }\n          break;\n        case JsSIP_C.ACK:\n          /* Absorb it.\n           * ACK request without a corresponding Invite Transaction\n           * and without To tag.\n           */\n          break;\n        case JsSIP_C.NOTIFY:\n          // Receive new sip event.\n          this.emit('sipEvent', {\n            event : request.event,\n            request\n          });\n          request.reply(200);\n          break;\n        default:\n          request.reply(405);\n          break;\n      }\n    }\n    // In-dialog request.\n    else\n    {\n      dialog = this._findDialog(request.call_id, request.from_tag, request.to_tag);\n\n      if (dialog)\n      {\n        dialog.receiveRequest(request);\n      }\n      else if (method === JsSIP_C.NOTIFY)\n      {\n        session = this._findSession(request);\n        if (session)\n        {\n          session.receiveRequest(request);\n        }\n        else\n        {\n          debug('received NOTIFY request for a non existent subscription');\n          request.reply(481, 'Subscription does not exist');\n        }\n      }\n\n      /* RFC3261 12.2.2\n       * Request with to tag, but no matching dialog found.\n       * Exception: ACK for an Invite request for which a dialog has not\n       * been created.\n       */\n      else\n      if (method !== JsSIP_C.ACK)\n      {\n        request.reply(481);\n      }\n    }\n  }\n\n  // =================\n  // Utils.\n  // =================\n\n  /**\n   * Get the session to which the request belongs to, if any.\n   */\n  _findSession({ call_id, from_tag, to_tag })\n  {\n    const sessionIDa = call_id + from_tag;\n    const sessionA = this._sessions[sessionIDa];\n    const sessionIDb = call_id + to_tag;\n    const sessionB = this._sessions[sessionIDb];\n\n    if (sessionA)\n    {\n      return sessionA;\n    }\n    else if (sessionB)\n    {\n      return sessionB;\n    }\n    else\n    {\n      return null;\n    }\n  }\n\n  /**\n   * Get the dialog to which the request belongs to, if any.\n   */\n  _findDialog(call_id, from_tag, to_tag)\n  {\n    let id = call_id + from_tag + to_tag;\n    let dialog = this._dialogs[id];\n\n    if (dialog)\n    {\n      return dialog;\n    }\n    else\n    {\n      id = call_id + to_tag + from_tag;\n      dialog = this._dialogs[id];\n      if (dialog)\n      {\n        return dialog;\n      }\n      else\n      {\n        return null;\n      }\n    }\n  }\n\n  _loadConfig(configuration)\n  {\n    // Check and load the given configuration.\n    try\n    {\n      config.load(this._configuration, configuration);\n    }\n    catch (e)\n    {\n      throw e;\n    }\n\n    // Post Configuration Process.\n\n    // Allow passing 0 number as display_name.\n    if (this._configuration.display_name === 0)\n    {\n      this._configuration.display_name = '0';\n    }\n\n    // Instance-id for GRUU.\n    if (!this._configuration.instance_id)\n    {\n      this._configuration.instance_id = Utils.newUUID();\n    }\n\n    // Jssip_id instance parameter. Static random tag of length 5.\n    this._configuration.jssip_id = Utils.createRandomToken(5);\n\n    // String containing this._configuration.uri without scheme and user.\n    const hostport_params = this._configuration.uri.clone();\n\n    hostport_params.user = null;\n    this._configuration.hostport_params = hostport_params.toString().replace(/^sip:/i, '');\n\n    // Transport.\n    try\n    {\n      this._transport = new Transport(this._configuration.sockets, {\n        // Recovery options.\n        max_interval : this._configuration.connection_recovery_max_interval,\n        min_interval : this._configuration.connection_recovery_min_interval\n      });\n\n      // Transport event callbacks.\n      this._transport.onconnecting = onTransportConnecting.bind(this);\n      this._transport.onconnect = onTransportConnect.bind(this);\n      this._transport.ondisconnect = onTransportDisconnect.bind(this);\n      this._transport.ondata = onTransportData.bind(this);\n    }\n    catch (e)\n    {\n      debugerror(e);\n      throw new Exceptions.ConfigurationError('sockets', this._configuration.sockets);\n    }\n\n    // Remove sockets instance from configuration object.\n    delete this._configuration.sockets;\n\n    // Check whether authorization_user is explicitly defined.\n    // Take 'this._configuration.uri.user' value if not.\n    if (!this._configuration.authorization_user)\n    {\n      this._configuration.authorization_user = this._configuration.uri.user;\n    }\n\n    // If no 'registrar_server' is set use the 'uri' value without user portion and\n    // without URI params/headers.\n    if (!this._configuration.registrar_server)\n    {\n      const registrar_server = this._configuration.uri.clone();\n\n      registrar_server.user = null;\n      registrar_server.clearParams();\n      registrar_server.clearHeaders();\n      this._configuration.registrar_server = registrar_server;\n    }\n\n    // User no_answer_timeout.\n    this._configuration.no_answer_timeout *= 1000;\n\n    // Via Host.\n    if (this._configuration.contact_uri)\n    {\n      this._configuration.via_host = this._configuration.contact_uri.host;\n    }\n\n    // Contact URI.\n    else\n    {\n      this._configuration.contact_uri = new URI('sip', Utils.createRandomToken(8), this._configuration.via_host, null, { transport: 'ws' });\n    }\n\n    this._contact = {\n      pub_gruu  : null,\n      temp_gruu : null,\n      uri       : this._configuration.contact_uri,\n      toString(options = {})\n      {\n        const anonymous = options.anonymous || null;\n        const outbound = options.outbound || null;\n        let contact = '<';\n\n        if (anonymous)\n        {\n          contact += this.temp_gruu || 'sip:anonymous@anonymous.invalid;transport=ws';\n        }\n        else\n        {\n          contact += this.pub_gruu || this.uri.toString();\n        }\n\n        if (outbound && (anonymous ? !this.temp_gruu : !this.pub_gruu))\n        {\n          contact += ';ob';\n        }\n\n        contact += '>';\n\n        return contact;\n      }\n    };\n\n    // Seal the configuration.\n    const writable_parameters = [\n      'password', 'realm', 'ha1', 'display_name', 'register'\n    ];\n\n    for (const parameter in this._configuration)\n    {\n      if (Object.prototype.hasOwnProperty.call(this._configuration, parameter))\n      {\n        if (writable_parameters.indexOf(parameter) !== -1)\n        {\n          Object.defineProperty(this._configuration, parameter, {\n            writable     : true,\n            configurable : false\n          });\n        }\n        else\n        {\n          Object.defineProperty(this._configuration, parameter, {\n            writable     : false,\n            configurable : false\n          });\n        }\n      }\n    }\n\n    debug('configuration parameters after validation:');\n    for (const parameter in this._configuration)\n    {\n      // Only show the user user configurable parameters.\n      if (Object.prototype.hasOwnProperty.call(config.settings, parameter))\n      {\n        switch (parameter)\n        {\n          case 'uri':\n          case 'registrar_server':\n            debug(`- ${parameter}: ${this._configuration[parameter]}`);\n            break;\n          case 'password':\n          case 'ha1':\n            debug(`- ${parameter}: NOT SHOWN`);\n            break;\n          default:\n            debug(`- ${parameter}: ${JSON.stringify(this._configuration[parameter])}`);\n        }\n      }\n    }\n\n    return;\n  }\n};\n\n/**\n * Transport event handlers\n */\n\n// Transport connecting event.\nfunction onTransportConnecting(data)\n{\n  this.emit('connecting', data);\n}\n\n// Transport connected event.\nfunction onTransportConnect(data)\n{\n  if (this._status === C.STATUS_USER_CLOSED)\n  {\n    return;\n  }\n\n  this._status = C.STATUS_READY;\n  this._error = null;\n\n  this.emit('connected', data);\n\n  if (this._dynConfiguration.register)\n  {\n    this._registrator.register();\n  }\n}\n\n// Transport disconnected event.\nfunction onTransportDisconnect(data)\n{\n  // Run _onTransportError_ callback on every client transaction using _transport_.\n  const client_transactions = [ 'nict', 'ict', 'nist', 'ist' ];\n\n  for (const type of client_transactions)\n  {\n    for (const id in this._transactions[type])\n    {\n      if (Object.prototype.hasOwnProperty.call(this._transactions[type], id))\n      {\n        this._transactions[type][id].onTransportError();\n      }\n    }\n  }\n\n  this.emit('disconnected', data);\n\n  // Call registrator _onTransportClosed_.\n  this._registrator.onTransportClosed();\n\n  if (this._status !== C.STATUS_USER_CLOSED)\n  {\n    this._status = C.STATUS_NOT_READY;\n    this._error = C.NETWORK_ERROR;\n  }\n}\n\n// Transport data event.\nfunction onTransportData(data)\n{\n  const transport = data.transport;\n  let message = data.message;\n\n  message = Parser.parseMessage(message, this);\n\n  if (! message)\n  {\n    return;\n  }\n\n  if (this._status === C.STATUS_USER_CLOSED &&\n      message instanceof SIPMessage.IncomingRequest)\n  {\n    return;\n  }\n\n  // Do some sanity check.\n  if (! sanityCheck(message, this, transport))\n  {\n    return;\n  }\n\n  if (message instanceof SIPMessage.IncomingRequest)\n  {\n    message.transport = transport;\n    this.receiveRequest(message);\n  }\n  else if (message instanceof SIPMessage.IncomingResponse)\n  {\n    /* Unike stated in 18.1.2, if a response does not match\n    * any transaction, it is discarded here and no passed to the core\n    * in order to be discarded there.\n    */\n\n    let transaction;\n\n    switch (message.method)\n    {\n      case JsSIP_C.INVITE:\n        transaction = this._transactions.ict[message.via_branch];\n        if (transaction)\n        {\n          transaction.receiveResponse(message);\n        }\n        break;\n      case JsSIP_C.ACK:\n        // Just in case ;-).\n        break;\n      default:\n        transaction = this._transactions.nict[message.via_branch];\n        if (transaction)\n        {\n          transaction.receiveResponse(message);\n        }\n        break;\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/UA.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/URI.js":
/*!***************************************!*\
  !*** ./node_modules/jssip/lib/URI.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib/Grammar.js\");\n\n/**\n * -param {String} [scheme]\n * -param {String} [user]\n * -param {String} host\n * -param {String} [port]\n * -param {Object} [parameters]\n * -param {Object} [headers]\n *\n */\nmodule.exports = class URI\n{\n  /**\n    * Parse the given string and returns a JsSIP.URI instance or undefined if\n    * it is an invalid URI.\n    */\n  static parse(uri)\n  {\n    uri = Grammar.parse(uri, 'SIP_URI');\n\n    if (uri !== -1)\n    {\n      return uri;\n    }\n    else\n    {\n      return undefined;\n    }\n  }\n\n  constructor(scheme, user, host, port, parameters = {}, headers = {})\n  {\n    // Checks.\n    if (!host)\n    {\n      throw new TypeError('missing or invalid \"host\" parameter');\n    }\n\n    // Initialize parameters.\n    this._parameters = {};\n    this._headers = {};\n\n    this._scheme = scheme || JsSIP_C.SIP;\n    this._user = user;\n    this._host = host;\n    this._port = port;\n\n    for (const param in parameters)\n    {\n      if (Object.prototype.hasOwnProperty.call(parameters, param))\n      {\n        this.setParam(param, parameters[param]);\n      }\n    }\n\n    for (const header in headers)\n    {\n      if (Object.prototype.hasOwnProperty.call(headers, header))\n      {\n        this.setHeader(header, headers[header]);\n      }\n    }\n  }\n\n  get scheme()\n  {\n    return this._scheme;\n  }\n\n  set scheme(value)\n  {\n    this._scheme = value.toLowerCase();\n  }\n\n  get user()\n  {\n    return this._user;\n  }\n\n  set user(value)\n  {\n    this._user = value;\n  }\n\n  get host()\n  {\n    return this._host;\n  }\n\n  set host(value)\n  {\n    this._host = value.toLowerCase();\n  }\n\n  get port()\n  {\n    return this._port;\n  }\n\n  set port(value)\n  {\n    this._port = value === 0 ? value : (parseInt(value, 10) || null);\n  }\n\n  setParam(key, value)\n  {\n    if (key)\n    {\n      this._parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();\n    }\n  }\n\n  getParam(key)\n  {\n    if (key)\n    {\n      return this._parameters[key.toLowerCase()];\n    }\n  }\n\n  hasParam(key)\n  {\n    if (key)\n    {\n      return (this._parameters.hasOwnProperty(key.toLowerCase()) && true) || false;\n    }\n  }\n\n  deleteParam(parameter)\n  {\n    parameter = parameter.toLowerCase();\n    if (this._parameters.hasOwnProperty(parameter))\n    {\n      const value = this._parameters[parameter];\n\n      delete this._parameters[parameter];\n\n      return value;\n    }\n  }\n\n  clearParams()\n  {\n    this._parameters = {};\n  }\n\n  setHeader(name, value)\n  {\n    this._headers[Utils.headerize(name)] = (Array.isArray(value)) ? value : [ value ];\n  }\n\n  getHeader(name)\n  {\n    if (name)\n    {\n      return this._headers[Utils.headerize(name)];\n    }\n  }\n\n  hasHeader(name)\n  {\n    if (name)\n    {\n      return (this._headers.hasOwnProperty(Utils.headerize(name)) && true) || false;\n    }\n  }\n\n  deleteHeader(header)\n  {\n    header = Utils.headerize(header);\n    if (this._headers.hasOwnProperty(header))\n    {\n      const value = this._headers[header];\n\n      delete this._headers[header];\n\n      return value;\n    }\n  }\n\n  clearHeaders()\n  {\n    this._headers = {};\n  }\n\n  clone()\n  {\n    return new URI(\n      this._scheme,\n      this._user,\n      this._host,\n      this._port,\n      JSON.parse(JSON.stringify(this._parameters)),\n      JSON.parse(JSON.stringify(this._headers)));\n  }\n\n  toString()\n  {\n    const headers = [];\n\n    let uri = `${this._scheme}:`;\n\n    if (this._user)\n    {\n      uri += `${Utils.escapeUser(this._user)}@`;\n    }\n    uri += this._host;\n    if (this._port || this._port === 0)\n    {\n      uri += `:${this._port}`;\n    }\n\n    for (const parameter in this._parameters)\n    {\n      if (Object.prototype.hasOwnProperty.call(this._parameters, parameter))\n      {\n        uri += `;${parameter}`;\n\n        if (this._parameters[parameter] !== null)\n        {\n          uri += `=${this._parameters[parameter]}`;\n        }\n      }\n    }\n\n    for (const header in this._headers)\n    {\n      if (Object.prototype.hasOwnProperty.call(this._headers, header))\n      {\n        for (const item of this._headers[header])\n        {\n          headers.push(`${header}=${item}`);\n        }\n      }\n    }\n\n    if (headers.length > 0)\n    {\n      uri += `?${headers.join('&')}`;\n    }\n\n    return uri;\n  }\n\n  toAor(show_port)\n  {\n    let aor = `${this._scheme}:`;\n\n    if (this._user)\n    {\n      aor += `${Utils.escapeUser(this._user)}@`;\n    }\n    aor += this._host;\n    if (show_port && (this._port || this._port === 0))\n    {\n      aor += `:${this._port}`;\n    }\n\n    return aor;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/URI.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/Utils.js":
/*!*****************************************!*\
  !*** ./node_modules/jssip/lib/Utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst URI = __webpack_require__(/*! ./URI */ \"./node_modules/jssip/lib/URI.js\");\nconst Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib/Grammar.js\");\n\nexports.str_utf8_length = (string) => unescape(encodeURIComponent(string)).length;\n\n// Used by 'hasMethods'.\nconst isFunction = exports.isFunction = (fn) =>\n{\n  if (fn !== undefined)\n  {\n    return (Object.prototype.toString.call(fn) === '[object Function]')? true : false;\n  }\n  else\n  {\n    return false;\n  }\n};\n\nexports.isString = (str) =>\n{\n  if (str !== undefined)\n  {\n    return (Object.prototype.toString.call(str) === '[object String]')? true : false;\n  }\n  else\n  {\n    return false;\n  }\n};\n\nexports.isDecimal = (num) => !isNaN(num) && (parseFloat(num) === parseInt(num, 10));\n\nexports.isEmpty = (value) =>\n{\n  return (value === null ||\n      value === '' ||\n      value === undefined ||\n      (Array.isArray(value) && value.length === 0) ||\n      (typeof(value) === 'number' && isNaN(value)));\n};\n\nexports.hasMethods = function(obj, ...methodNames)\n{\n  for (const methodName of methodNames)\n  {\n    if (isFunction(obj[methodName]))\n    {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n// Used by 'newTag'.\nconst createRandomToken = exports.createRandomToken = (size, base = 32) =>\n{\n  let i, r, token = '';\n\n  for (i=0; i < size; i++)\n  {\n    r = (Math.random() * base) | 0;\n    token += r.toString(base);\n  }\n\n  return token;\n};\n\nexports.newTag = () => createRandomToken(10);\n\n// https://stackoverflow.com/users/109538/broofa.\nexports.newUUID = () =>\n{\n  const UUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) =>\n  {\n    const r = Math.random()*16|0, v = c === 'x' ? r : ((r&0x3)|0x8);\n\n\n    return v.toString(16);\n  });\n\n  return UUID;\n};\n\nexports.hostType = (host) =>\n{\n  if (!host)\n  {\n    return;\n  }\n  else\n  {\n    host = Grammar.parse(host, 'host');\n    if (host !== -1)\n    {\n      return host.host_type;\n    }\n  }\n};\n\n/**\n* Hex-escape a SIP URI user.\n* Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n*\n* Used by 'normalizeTarget'.\n*/\nconst escapeUser = exports.escapeUser = (user) =>\n  encodeURIComponent(decodeURIComponent(user))\n    .replace(/%3A/ig, ':')\n    .replace(/%2B/ig, '+')\n    .replace(/%3F/ig, '?')\n    .replace(/%2F/ig, '/');\n\n/**\n* Normalize SIP URI.\n* NOTE: It does not allow a SIP URI without username.\n* Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.\n* Detects the domain part (if given) and properly hex-escapes the user portion.\n* If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.\n*/\nexports.normalizeTarget = (target, domain) =>\n{\n  // If no target is given then raise an error.\n  if (!target)\n  {\n    return;\n  // If a URI instance is given then return it.\n  }\n  else if (target instanceof URI)\n  {\n    return target;\n\n  // If a string is given split it by '@':\n  // - Last fragment is the desired domain.\n  // - Otherwise append the given domain argument.\n  }\n  else if (typeof target === 'string')\n  {\n    const target_array = target.split('@');\n    let target_user;\n    let target_domain;\n\n    switch (target_array.length)\n    {\n      case 1:\n        if (!domain)\n        {\n          return;\n        }\n        target_user = target;\n        target_domain = domain;\n        break;\n      case 2:\n        target_user = target_array[0];\n        target_domain = target_array[1];\n        break;\n      default:\n        target_user = target_array.slice(0, target_array.length-1).join('@');\n        target_domain = target_array[target_array.length-1];\n    }\n\n    // Remove the URI scheme (if present).\n    target_user = target_user.replace(/^(sips?|tel):/i, '');\n\n    // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.\n    if (/^[-.()]*\\+?[0-9\\-.()]+$/.test(target_user))\n    {\n      target_user = target_user.replace(/[-.()]/g, '');\n    }\n\n    // Build the complete SIP URI.\n    target = `${JsSIP_C.SIP}:${escapeUser(target_user)}@${target_domain}`;\n\n    // Finally parse the resulting URI.\n    let uri;\n\n    if ((uri = URI.parse(target)))\n    {\n      return uri;\n    }\n    else\n    {\n      return;\n    }\n  }\n  else\n  {\n    return;\n  }\n};\n\nexports.headerize = (string) =>\n{\n  const exceptions = {\n    'Call-Id'          : 'Call-ID',\n    'Cseq'             : 'CSeq',\n    'Www-Authenticate' : 'WWW-Authenticate'\n  };\n\n  const name = string.toLowerCase()\n    .replace(/_/g, '-')\n    .split('-');\n  let hname = '';\n  const parts = name.length;\n  let part;\n\n  for (part = 0; part < parts; part++)\n  {\n    if (part !== 0)\n    {\n      hname +='-';\n    }\n    hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);\n  }\n  if (exceptions[hname])\n  {\n    hname = exceptions[hname];\n  }\n\n  return hname;\n};\n\nexports.sipErrorCause = (status_code) =>\n{\n  for (const cause in JsSIP_C.SIP_ERROR_CAUSES)\n  {\n    if (JsSIP_C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1)\n    {\n      return JsSIP_C.causes[cause];\n    }\n  }\n\n  return JsSIP_C.causes.SIP_FAILURE_CODE;\n};\n\n/**\n* Generate a random Test-Net IP (https://tools.ietf.org/html/rfc5735)\n*/\nexports.getRandomTestNetIP = () =>\n{\n  function getOctet(from, to)\n  {\n    return Math.floor((Math.random() * (to-from+1)) + from);\n  }\n\n  return `192.0.2.${getOctet(1, 254)}`;\n};\n\n// MD5 (Message-Digest Algorithm) https://www.webtoolkit.info.\nexports.calculateMD5 = (string) =>\n{\n  function rotateLeft(lValue, iShiftBits)\n  {\n    return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));\n  }\n\n  function addUnsigned(lX, lY)\n  {\n    const lX8 = (lX & 0x80000000);\n    const lY8 = (lY & 0x80000000);\n    const lX4 = (lX & 0x40000000);\n    const lY4 = (lY & 0x40000000);\n    const lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);\n\n    if (lX4 & lY4)\n    {\n      return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\n    }\n    if (lX4 | lY4)\n    {\n      if (lResult & 0x40000000)\n      {\n        return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n      }\n      else\n      {\n        return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\n      }\n    }\n    else\n    {\n      return (lResult ^ lX8 ^ lY8);\n    }\n  }\n\n  function doF(x, y, z)\n  {\n    return (x & y) | ((~x) & z);\n  }\n\n  function doG(x, y, z)\n  {\n    return (x & z) | (y & (~z));\n  }\n\n  function doH(x, y, z)\n  {\n    return (x ^ y ^ z);\n  }\n\n  function doI(x, y, z)\n  {\n    return (y ^ (x | (~z)));\n  }\n\n  function doFF(a, b, c, d, x, s, ac)\n  {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doF(b, c, d), x), ac));\n\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function doGG(a, b, c, d, x, s, ac)\n  {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doG(b, c, d), x), ac));\n\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function doHH(a, b, c, d, x, s, ac)\n  {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doH(b, c, d), x), ac));\n\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function doII(a, b, c, d, x, s, ac)\n  {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doI(b, c, d), x), ac));\n\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function convertToWordArray(str)\n  {\n    let lWordCount;\n    const lMessageLength = str.length;\n    const lNumberOfWords_temp1=lMessageLength + 8;\n    const lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;\n    const lNumberOfWords = (lNumberOfWords_temp2+1)*16;\n    const lWordArray = new Array(lNumberOfWords-1);\n    let lBytePosition = 0;\n    let lByteCount = 0;\n\n    while (lByteCount < lMessageLength)\n    {\n      lWordCount = (lByteCount-(lByteCount % 4))/4;\n      lBytePosition = (lByteCount % 4)*8;\n      lWordArray[lWordCount] = (lWordArray[lWordCount] |\n          (str.charCodeAt(lByteCount)<<lBytePosition));\n      lByteCount++;\n    }\n    lWordCount = (lByteCount-(lByteCount % 4))/4;\n    lBytePosition = (lByteCount % 4)*8;\n    lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\n    lWordArray[lNumberOfWords-2] = lMessageLength<<3;\n    lWordArray[lNumberOfWords-1] = lMessageLength>>>29;\n\n    return lWordArray;\n  }\n\n  function wordToHex(lValue)\n  {\n    let wordToHexValue='', wordToHexValue_temp='', lByte, lCount;\n\n    for (lCount = 0; lCount<=3; lCount++)\n    {\n      lByte = (lValue>>>(lCount*8)) & 255;\n      wordToHexValue_temp = `0${lByte.toString(16)}`;\n      wordToHexValue = wordToHexValue +\n        wordToHexValue_temp.substr(wordToHexValue_temp.length-2, 2);\n    }\n\n    return wordToHexValue;\n  }\n\n  function utf8Encode(str)\n  {\n    str = str.replace(/\\r\\n/g, '\\n');\n    let utftext = '';\n\n    for (let n = 0; n < str.length; n++)\n    {\n      const c = str.charCodeAt(n);\n\n      if (c < 128)\n      {\n        utftext += String.fromCharCode(c);\n      }\n      else if ((c > 127) && (c < 2048))\n      {\n        utftext += String.fromCharCode((c >> 6) | 192);\n        utftext += String.fromCharCode((c & 63) | 128);\n      }\n      else\n      {\n        utftext += String.fromCharCode((c >> 12) | 224);\n        utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n        utftext += String.fromCharCode((c & 63) | 128);\n      }\n    }\n\n    return utftext;\n  }\n\n  let x=[];\n  let k, AA, BB, CC, DD, a, b, c, d;\n  const S11=7, S12=12, S13=17, S14=22;\n  const S21=5, S22=9, S23=14, S24=20;\n  const S31=4, S32=11, S33=16, S34=23;\n  const S41=6, S42=10, S43=15, S44=21;\n\n  string = utf8Encode(string);\n\n  x = convertToWordArray(string);\n\n  a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;\n\n  for (k=0; k<x.length; k+=16)\n  {\n    AA=a; BB=b; CC=c; DD=d;\n    a=doFF(a, b, c, d, x[k+0], S11, 0xD76AA478);\n    d=doFF(d, a, b, c, x[k+1], S12, 0xE8C7B756);\n    c=doFF(c, d, a, b, x[k+2], S13, 0x242070DB);\n    b=doFF(b, c, d, a, x[k+3], S14, 0xC1BDCEEE);\n    a=doFF(a, b, c, d, x[k+4], S11, 0xF57C0FAF);\n    d=doFF(d, a, b, c, x[k+5], S12, 0x4787C62A);\n    c=doFF(c, d, a, b, x[k+6], S13, 0xA8304613);\n    b=doFF(b, c, d, a, x[k+7], S14, 0xFD469501);\n    a=doFF(a, b, c, d, x[k+8], S11, 0x698098D8);\n    d=doFF(d, a, b, c, x[k+9], S12, 0x8B44F7AF);\n    c=doFF(c, d, a, b, x[k+10], S13, 0xFFFF5BB1);\n    b=doFF(b, c, d, a, x[k+11], S14, 0x895CD7BE);\n    a=doFF(a, b, c, d, x[k+12], S11, 0x6B901122);\n    d=doFF(d, a, b, c, x[k+13], S12, 0xFD987193);\n    c=doFF(c, d, a, b, x[k+14], S13, 0xA679438E);\n    b=doFF(b, c, d, a, x[k+15], S14, 0x49B40821);\n    a=doGG(a, b, c, d, x[k+1], S21, 0xF61E2562);\n    d=doGG(d, a, b, c, x[k+6], S22, 0xC040B340);\n    c=doGG(c, d, a, b, x[k+11], S23, 0x265E5A51);\n    b=doGG(b, c, d, a, x[k+0], S24, 0xE9B6C7AA);\n    a=doGG(a, b, c, d, x[k+5], S21, 0xD62F105D);\n    d=doGG(d, a, b, c, x[k+10], S22, 0x2441453);\n    c=doGG(c, d, a, b, x[k+15], S23, 0xD8A1E681);\n    b=doGG(b, c, d, a, x[k+4], S24, 0xE7D3FBC8);\n    a=doGG(a, b, c, d, x[k+9], S21, 0x21E1CDE6);\n    d=doGG(d, a, b, c, x[k+14], S22, 0xC33707D6);\n    c=doGG(c, d, a, b, x[k+3], S23, 0xF4D50D87);\n    b=doGG(b, c, d, a, x[k+8], S24, 0x455A14ED);\n    a=doGG(a, b, c, d, x[k+13], S21, 0xA9E3E905);\n    d=doGG(d, a, b, c, x[k+2], S22, 0xFCEFA3F8);\n    c=doGG(c, d, a, b, x[k+7], S23, 0x676F02D9);\n    b=doGG(b, c, d, a, x[k+12], S24, 0x8D2A4C8A);\n    a=doHH(a, b, c, d, x[k+5], S31, 0xFFFA3942);\n    d=doHH(d, a, b, c, x[k+8], S32, 0x8771F681);\n    c=doHH(c, d, a, b, x[k+11], S33, 0x6D9D6122);\n    b=doHH(b, c, d, a, x[k+14], S34, 0xFDE5380C);\n    a=doHH(a, b, c, d, x[k+1], S31, 0xA4BEEA44);\n    d=doHH(d, a, b, c, x[k+4], S32, 0x4BDECFA9);\n    c=doHH(c, d, a, b, x[k+7], S33, 0xF6BB4B60);\n    b=doHH(b, c, d, a, x[k+10], S34, 0xBEBFBC70);\n    a=doHH(a, b, c, d, x[k+13], S31, 0x289B7EC6);\n    d=doHH(d, a, b, c, x[k+0], S32, 0xEAA127FA);\n    c=doHH(c, d, a, b, x[k+3], S33, 0xD4EF3085);\n    b=doHH(b, c, d, a, x[k+6], S34, 0x4881D05);\n    a=doHH(a, b, c, d, x[k+9], S31, 0xD9D4D039);\n    d=doHH(d, a, b, c, x[k+12], S32, 0xE6DB99E5);\n    c=doHH(c, d, a, b, x[k+15], S33, 0x1FA27CF8);\n    b=doHH(b, c, d, a, x[k+2], S34, 0xC4AC5665);\n    a=doII(a, b, c, d, x[k+0], S41, 0xF4292244);\n    d=doII(d, a, b, c, x[k+7], S42, 0x432AFF97);\n    c=doII(c, d, a, b, x[k+14], S43, 0xAB9423A7);\n    b=doII(b, c, d, a, x[k+5], S44, 0xFC93A039);\n    a=doII(a, b, c, d, x[k+12], S41, 0x655B59C3);\n    d=doII(d, a, b, c, x[k+3], S42, 0x8F0CCC92);\n    c=doII(c, d, a, b, x[k+10], S43, 0xFFEFF47D);\n    b=doII(b, c, d, a, x[k+1], S44, 0x85845DD1);\n    a=doII(a, b, c, d, x[k+8], S41, 0x6FA87E4F);\n    d=doII(d, a, b, c, x[k+15], S42, 0xFE2CE6E0);\n    c=doII(c, d, a, b, x[k+6], S43, 0xA3014314);\n    b=doII(b, c, d, a, x[k+13], S44, 0x4E0811A1);\n    a=doII(a, b, c, d, x[k+4], S41, 0xF7537E82);\n    d=doII(d, a, b, c, x[k+11], S42, 0xBD3AF235);\n    c=doII(c, d, a, b, x[k+2], S43, 0x2AD7D2BB);\n    b=doII(b, c, d, a, x[k+9], S44, 0xEB86D391);\n    a=addUnsigned(a, AA);\n    b=addUnsigned(b, BB);\n    c=addUnsigned(c, CC);\n    d=addUnsigned(d, DD);\n  }\n\n  const temp = wordToHex(a)+wordToHex(b)+wordToHex(c)+wordToHex(d);\n\n  return temp.toLowerCase();\n};\n\nexports.closeMediaStream = (stream) =>\n{\n  if (!stream)\n  {\n    return;\n  }\n\n  // Latest spec states that MediaStream has no stop() method and instead must\n  // call stop() on every MediaStreamTrack.\n  try\n  {\n    let tracks;\n\n    if (stream.getTracks)\n    {\n      tracks = stream.getTracks();\n      for (const track of tracks)\n      {\n        track.stop();\n      }\n    }\n    else\n    {\n      tracks = stream.getAudioTracks();\n      for (const track of tracks)\n      {\n        track.stop();\n      }\n      tracks = stream.getVideoTracks();\n      for (const track of tracks)\n      {\n        track.stop();\n      }\n    }\n  }\n  catch (error)\n  {\n    // Deprecated by the spec, but still in use.\n    // NOTE: In Temasys IE plugin stream.stop is a callable 'object'.\n    if (typeof stream.stop === 'function' || typeof stream.stop === 'object')\n    {\n      stream.stop();\n    }\n  }\n};\n\nexports.cloneArray = (array) =>\n{\n  return (array && array.slice()) || [];\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/Utils.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/WebSocketInterface.js":
/*!******************************************************!*\
  !*** ./node_modules/jssip/lib/WebSocketInterface.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib/Grammar.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:WebSocketInterface');\nconst debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:ERROR:WebSocketInterface');\n\ndebugerror.log = console.warn.bind(console);\n\nmodule.exports = class WebSocketInterface\n{\n  constructor(url)\n  {\n    debug('new() [url:\"%s\"]', url);\n\n    this._url = url;\n    this._sip_uri = null;\n    this._via_transport = null;\n    this._ws = null;\n\n    const parsed_url = Grammar.parse(url, 'absoluteURI');\n\n    if (parsed_url === -1)\n    {\n      debugerror(`invalid WebSocket URI: ${url}`);\n      throw new TypeError(`Invalid argument: ${url}`);\n    }\n    else if (parsed_url.scheme !== 'wss' && parsed_url.scheme !== 'ws')\n    {\n      debugerror(`invalid WebSocket URI scheme: ${parsed_url.scheme}`);\n      throw new TypeError(`Invalid argument: ${url}`);\n    }\n    else\n    {\n      this._sip_uri = `sip:${parsed_url.host}${parsed_url.port ? `:${parsed_url.port}` : ''};transport=ws`;\n      this._via_transport = parsed_url.scheme.toUpperCase();\n    }\n  }\n\n  get via_transport()\n  {\n    return this._via_transport;\n  }\n\n  set via_transport(value)\n  {\n    this._via_transport = value.toUpperCase();\n  }\n\n  get sip_uri()\n  {\n    return this._sip_uri;\n  }\n\n  get url()\n  {\n    return this._url;\n  }\n\n  connect()\n  {\n    debug('connect()');\n\n    if (this.isConnected())\n    {\n      debug(`WebSocket ${this._url} is already connected`);\n\n      return;\n    }\n    else if (this.isConnecting())\n    {\n      debug(`WebSocket ${this._url} is connecting`);\n\n      return;\n    }\n\n    if (this._ws)\n    {\n      this.disconnect();\n    }\n\n    debug(`connecting to WebSocket ${this._url}`);\n\n    try\n    {\n      this._ws = new WebSocket(this._url, 'sip');\n\n      this._ws.binaryType = 'arraybuffer';\n\n      this._ws.onopen = this._onOpen.bind(this);\n      this._ws.onclose = this._onClose.bind(this);\n      this._ws.onmessage = this._onMessage.bind(this);\n      this._ws.onerror = this._onError.bind(this);\n    }\n    catch (e)\n    {\n      this._onError(e);\n    }\n  }\n\n  disconnect()\n  {\n    debug('disconnect()');\n\n    if (this._ws)\n    {\n      // Unbind websocket event callbacks.\n      this._ws.onopen = () => {};\n      this._ws.onclose = () => {};\n      this._ws.onmessage = () => {};\n      this._ws.onerror = () => {};\n\n      this._ws.close();\n      this._ws = null;\n    }\n  }\n\n  send(message)\n  {\n    debug('send()');\n\n    if (this.isConnected())\n    {\n      this._ws.send(message);\n\n      return true;\n    }\n    else\n    {\n      debugerror('unable to send message, WebSocket is not open');\n\n      return false;\n    }\n  }\n\n  isConnected()\n  {\n    return this._ws && this._ws.readyState === this._ws.OPEN;\n  }\n\n  isConnecting()\n  {\n    return this._ws && this._ws.readyState === this._ws.CONNECTING;\n  }\n\n\n  /**\n   * WebSocket Event Handlers\n   */\n\n  _onOpen()\n  {\n    debug(`WebSocket ${this._url} connected`);\n\n    this.onconnect();\n  }\n\n  _onClose({ wasClean, code, reason })\n  {\n    debug(`WebSocket ${this._url} closed`);\n\n    if (wasClean === false)\n    {\n      debug('WebSocket abrupt disconnection');\n    }\n\n    const data = {\n      socket : this,\n      error  : !wasClean,\n      code,\n      reason\n    };\n\n    this.ondisconnect(data);\n  }\n\n  _onMessage({ data })\n  {\n    debug('received WebSocket message');\n\n    this.ondata(data);\n  }\n\n  _onError(e)\n  {\n    debugerror(`WebSocket ${this._url} error: ${e}`);\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/WebSocketInterface.js?");

/***/ }),

/***/ "./node_modules/jssip/lib/sanityCheck.js":
/*!***********************************************!*\
  !*** ./node_modules/jssip/lib/sanityCheck.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib/Constants.js\");\nconst SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib/SIPMessage.js\");\nconst Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib/Utils.js\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('JsSIP:sanityCheck');\n\n// Checks for requests and responses.\nconst all = [ minimumHeaders ];\n\n// Checks for requests.\nconst requests = [\n  rfc3261_8_2_2_1,\n  rfc3261_16_3_4,\n  rfc3261_18_3_request,\n  rfc3261_8_2_2_2\n];\n\n// Checks for responses.\nconst responses = [\n  rfc3261_8_1_3_3,\n  rfc3261_18_3_response\n];\n\n// local variables.\nlet message;\nlet ua;\nlet transport;\n\nmodule.exports = (m, u, t) =>\n{\n  message = m;\n  ua = u;\n  transport = t;\n\n  for (const check of all)\n  {\n    if (check() === false)\n    {\n      return false;\n    }\n  }\n\n  if (message instanceof SIPMessage.IncomingRequest)\n  {\n    for (const check of requests)\n    {\n      if (check() === false)\n      {\n        return false;\n      }\n    }\n  }\n\n  else if (message instanceof SIPMessage.IncomingResponse)\n  {\n    for (const check of responses)\n    {\n      if (check() === false)\n      {\n        return false;\n      }\n    }\n  }\n\n  // Everything is OK.\n  return true;\n};\n\n\n/*\n * Sanity Check for incoming Messages\n *\n * Requests:\n *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme\n *  - _rfc3261_16_3_4_ Receive a Request already sent by us\n *   Does not look at via sent-by but at jssip_id, which is inserted as\n *   a prefix in all initial requests generated by the ua\n *  - _rfc3261_18_3_request_ Body Content-Length\n *  - _rfc3261_8_2_2_2_ Merged Requests\n *\n * Responses:\n *  - _rfc3261_8_1_3_3_ Multiple Via headers\n *  - _rfc3261_18_3_response_ Body Content-Length\n *\n * All:\n *  - Minimum headers in a SIP message\n */\n\n// Sanity Check functions for requests.\nfunction rfc3261_8_2_2_1()\n{\n  if (message.s('to').uri.scheme !== 'sip')\n  {\n    reply(416);\n\n    return false;\n  }\n}\n\nfunction rfc3261_16_3_4()\n{\n  if (!message.to_tag)\n  {\n    if (message.call_id.substr(0, 5) === ua.configuration.jssip_id)\n    {\n      reply(482);\n\n      return false;\n    }\n  }\n}\n\nfunction rfc3261_18_3_request()\n{\n  const len = Utils.str_utf8_length(message.body);\n  const contentLength = message.getHeader('content-length');\n\n  if (len < contentLength)\n  {\n    reply(400);\n\n    return false;\n  }\n}\n\nfunction rfc3261_8_2_2_2()\n{\n  const fromTag = message.from_tag;\n  const call_id = message.call_id;\n  const cseq = message.cseq;\n  let tr;\n\n  // Accept any in-dialog request.\n  if (message.to_tag)\n  {\n    return;\n  }\n\n  // INVITE request.\n  if (message.method === JsSIP_C.INVITE)\n  {\n    // If the branch matches the key of any IST then assume it is a retransmission\n    // and ignore the INVITE.\n    // TODO: we should reply the last response.\n    if (ua._transactions.ist[message.via_branch])\n    {\n      return false;\n    }\n    // Otherwise check whether it is a merged request.\n    else\n    {\n      for (const transaction in ua._transactions.ist)\n      {\n        if (Object.prototype.hasOwnProperty.call(ua._transactions.ist, transaction))\n        {\n          tr = ua._transactions.ist[transaction];\n          if (tr.request.from_tag === fromTag &&\n              tr.request.call_id === call_id &&\n              tr.request.cseq === cseq)\n          {\n            reply(482);\n\n            return false;\n          }\n        }\n      }\n    }\n  }\n\n  // Non INVITE request.\n\n  // If the branch matches the key of any NIST then assume it is a retransmission\n  // and ignore the request.\n  // TODO: we should reply the last response.\n  else if (ua._transactions.nist[message.via_branch])\n  {\n    return false;\n  }\n\n  // Otherwise check whether it is a merged request.\n  else\n  {\n    for (const transaction in ua._transactions.nist)\n    {\n      if (Object.prototype.hasOwnProperty.call(ua._transactions.nist, transaction))\n      {\n        tr = ua._transactions.nist[transaction];\n        if (tr.request.from_tag === fromTag &&\n            tr.request.call_id === call_id &&\n            tr.request.cseq === cseq)\n        {\n          reply(482);\n\n          return false;\n        }\n      }\n    }\n  }\n}\n\n// Sanity Check functions for responses.\nfunction rfc3261_8_1_3_3()\n{\n  if (message.getHeaders('via').length > 1)\n  {\n    debug('more than one Via header field present in the response, dropping the response');\n\n    return false;\n  }\n}\n\nfunction rfc3261_18_3_response()\n{\n  const len = Utils.str_utf8_length(message.body), contentLength = message.getHeader('content-length');\n\n  if (len < contentLength)\n  {\n    debug('message body length is lower than the value in Content-Length header field, dropping the response');\n\n    return false;\n  }\n}\n\n// Sanity Check functions for requests and responses.\nfunction minimumHeaders()\n{\n  const mandatoryHeaders = [ 'from', 'to', 'call_id', 'cseq', 'via' ];\n\n  for (const header of mandatoryHeaders)\n  {\n    if (!message.hasHeader(header))\n    {\n      debug(`missing mandatory header field : ${header}, dropping the response`);\n\n      return false;\n    }\n  }\n}\n\n// Reply.\nfunction reply(status_code)\n{\n  const vias = message.getHeaders('via');\n\n  let to;\n  let response = `SIP/2.0 ${status_code} ${JsSIP_C.REASON_PHRASE[status_code]}\\r\\n`;\n\n  for (const via of vias)\n  {\n    response += `Via: ${via}\\r\\n`;\n  }\n\n  to = message.getHeader('To');\n\n  if (!message.to_tag)\n  {\n    to += `;tag=${Utils.newTag()}`;\n  }\n\n  response += `To: ${to}\\r\\n`;\n  response += `From: ${message.getHeader('From')}\\r\\n`;\n  response += `Call-ID: ${message.call_id}\\r\\n`;\n  response += `CSeq: ${message.cseq} ${message.method}\\r\\n`;\n  response += '\\r\\n';\n\n  transport.send(response);\n}\n\n\n//# sourceURL=webpack:///./node_modules/jssip/lib/sanityCheck.js?");

/***/ }),

/***/ "./node_modules/jssip/package.json":
/*!*****************************************!*\
  !*** ./node_modules/jssip/package.json ***!
  \*****************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, bugs, bundleDependencies, contributors, dependencies, deprecated, description, devDependencies, homepage, keywords, license, main, name, repository, scripts, title, version, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"_from\\\":\\\"jssip@^3.3.6\\\",\\\"_id\\\":\\\"jssip@3.3.6\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha512-kyLxEQ7GBVlEi1PIWToAob7mH8WPtdUE51382vtjYC4ZUEa6qCXB4i9EwysX2bvpJUPbieZ1UPY8C6tLXQeBbA==\\\",\\\"_location\\\":\\\"/jssip\\\",\\\"_phantomChildren\\\":{},\\\"_requested\\\":{\\\"type\\\":\\\"range\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"jssip@^3.3.6\\\",\\\"name\\\":\\\"jssip\\\",\\\"escapedName\\\":\\\"jssip\\\",\\\"rawSpec\\\":\\\"^3.3.6\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"^3.3.6\\\"},\\\"_requiredBy\\\":[\\\"/\\\"],\\\"_resolved\\\":\\\"https://registry.npmjs.org/jssip/-/jssip-3.3.6.tgz\\\",\\\"_shasum\\\":\\\"53889624437ad386578159cc267fcefb06290a57\\\",\\\"_spec\\\":\\\"jssip@^3.3.6\\\",\\\"_where\\\":\\\"/home/julien/git/jssip_client\\\",\\\"author\\\":{\\\"name\\\":\\\"José Luis Millán\\\",\\\"email\\\":\\\"jmillan@aliax.net\\\",\\\"url\\\":\\\"https://github.com/jmillan\\\"},\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/versatica/JsSIP/issues\\\"},\\\"bundleDependencies\\\":false,\\\"contributors\\\":[{\\\"name\\\":\\\"Iñaki Baz Castillo\\\",\\\"email\\\":\\\"ibc@aliax.net\\\",\\\"url\\\":\\\"https://github.com/ibc\\\"}],\\\"dependencies\\\":{\\\"debug\\\":\\\"^4.1.1\\\",\\\"events\\\":\\\"^3.0.0\\\",\\\"sdp-transform\\\":\\\"^2.7.0\\\"},\\\"deprecated\\\":false,\\\"description\\\":\\\"the Javascript SIP library\\\",\\\"devDependencies\\\":{\\\"@babel/core\\\":\\\"^7.4.3\\\",\\\"@babel/preset-env\\\":\\\"^7.4.3\\\",\\\"ansi-colors\\\":\\\"^3.2.4\\\",\\\"browserify\\\":\\\"^16.2.3\\\",\\\"eslint\\\":\\\"^5.16.0\\\",\\\"fancy-log\\\":\\\"^1.3.3\\\",\\\"gulp\\\":\\\"^4.0.0\\\",\\\"gulp-babel\\\":\\\"^8.0.0\\\",\\\"gulp-eslint\\\":\\\"^5.0.0\\\",\\\"gulp-expect-file\\\":\\\"^1.0.1\\\",\\\"gulp-header\\\":\\\"^2.0.7\\\",\\\"gulp-nodeunit-runner\\\":\\\"^0.2.2\\\",\\\"gulp-plumber\\\":\\\"^1.2.1\\\",\\\"gulp-rename\\\":\\\"^1.4.0\\\",\\\"gulp-uglify-es\\\":\\\"^1.0.4\\\",\\\"pegjs\\\":\\\"^0.7.0\\\",\\\"vinyl-buffer\\\":\\\"^1.0.1\\\",\\\"vinyl-source-stream\\\":\\\"^2.0.0\\\"},\\\"homepage\\\":\\\"https://jssip.net\\\",\\\"keywords\\\":[\\\"sip\\\",\\\"websocket\\\",\\\"webrtc\\\",\\\"node\\\",\\\"browser\\\",\\\"library\\\"],\\\"license\\\":\\\"MIT\\\",\\\"main\\\":\\\"lib-es5/JsSIP.js\\\",\\\"name\\\":\\\"jssip\\\",\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/versatica/JsSIP.git\\\"},\\\"scripts\\\":{\\\"lint\\\":\\\"gulp lint\\\",\\\"prepublishOnly\\\":\\\"gulp babel\\\",\\\"test\\\":\\\"gulp test\\\"},\\\"title\\\":\\\"JsSIP\\\",\\\"version\\\":\\\"3.3.6\\\"}\");\n\n//# sourceURL=webpack:///./node_modules/jssip/package.json?");

/***/ }),

/***/ "./node_modules/lodash.first/index.js":
/*!********************************************!*\
  !*** ./node_modules/lodash.first/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Gets the first element of `array`.\n *\n * @static\n * @memberOf _\n * @alias head\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the first element of `array`.\n * @example\n *\n * _.first([1, 2, 3]);\n * // => 1\n *\n * _.first([]);\n * // => undefined\n */\nfunction first(array) {\n  return array ? array[0] : undefined;\n}\n\nmodule.exports = first;\n\n\n//# sourceURL=webpack:///./node_modules/lodash.first/index.js?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack:///./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js":
/*!******************************************************************!*\
  !*** ./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar SDPUtils = __webpack_require__(/*! sdp */ \"./node_modules/sdp/sdp.js\");\n\nfunction fixStatsType(stat) {\n  return {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  }[stat.type] || stat.type;\n}\n\nfunction writeMediaSection(transceiver, caps, type, stream, dtlsRole) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : dtlsRole || 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    var trackId = transceiver.rtpSender._initialTrackId ||\n        transceiver.rtpSender.track.id;\n    transceiver.rtpSender._initialTrackId = trackId;\n    // spec.\n    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +\n        trackId + '\\r\\n';\n    sdp += 'a=' + msid;\n    // for Chrome. Legacy should no longer be required.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n\n    // RTX\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n}\n\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nfunction filterIceServers(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function(server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        console.warn('RTCIceServer.url is deprecated! Use urls instead.');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function(url) {\n        var validTurn = url.indexOf('turn:') === 0 &&\n            url.indexOf('transport=udp') !== -1 &&\n            url.indexOf('turn:[') === -1 &&\n            !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&\n            url.indexOf('?transport=udp') === -1;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n}\n\n// Determines the intersection of local and remote capabilities.\nfunction getCommonCapabilities(localCapabilities, remoteCapabilities) {\n  var commonCapabilities = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: []\n  };\n\n  var findCodecByPayloadType = function(pt, codecs) {\n    pt = parseInt(pt, 10);\n    for (var i = 0; i < codecs.length; i++) {\n      if (codecs[i].payloadType === pt ||\n          codecs[i].preferredPayloadType === pt) {\n        return codecs[i];\n      }\n    }\n  };\n\n  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {\n    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);\n    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\n    return lCodec && rCodec &&\n        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\n  };\n\n  localCapabilities.codecs.forEach(function(lCodec) {\n    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n      var rCodec = remoteCapabilities.codecs[i];\n      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\n          lCodec.clockRate === rCodec.clockRate) {\n        if (lCodec.name.toLowerCase() === 'rtx' &&\n            lCodec.parameters && rCodec.parameters.apt) {\n          // for RTX we need to find the local rtx that has a apt\n          // which points to the same local codec as the remote one.\n          if (!rtxCapabilityMatches(lCodec, rCodec,\n              localCapabilities.codecs, remoteCapabilities.codecs)) {\n            continue;\n          }\n        }\n        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy\n        // number of channels is the highest common number of channels\n        rCodec.numChannels = Math.min(lCodec.numChannels,\n            rCodec.numChannels);\n        // push rCodec so we reply with offerer payload type\n        commonCapabilities.codecs.push(rCodec);\n\n        // determine common feedback mechanisms\n        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\n          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n            if (lCodec.rtcpFeedback[j].type === fb.type &&\n                lCodec.rtcpFeedback[j].parameter === fb.parameter) {\n              return true;\n            }\n          }\n          return false;\n        });\n        // FIXME: also need to determine .parameters\n        //  see https://github.com/openpeer/ortc/issues/569\n        break;\n      }\n    }\n  });\n\n  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {\n    for (var i = 0; i < remoteCapabilities.headerExtensions.length;\n         i++) {\n      var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n      if (lHeaderExtension.uri === rHeaderExtension.uri) {\n        commonCapabilities.headerExtensions.push(rHeaderExtension);\n        break;\n      }\n    }\n  });\n\n  // FIXME: fecMechanisms\n  return commonCapabilities;\n}\n\n// is action=setLocalDescription with type allowed in signalingState\nfunction isActionAllowedInSignalingState(action, type, signalingState) {\n  return {\n    offer: {\n      setLocalDescription: ['stable', 'have-local-offer'],\n      setRemoteDescription: ['stable', 'have-remote-offer']\n    },\n    answer: {\n      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],\n      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']\n    }\n  }[type][action].indexOf(signalingState) !== -1;\n}\n\nfunction maybeAddCandidate(iceTransport, candidate) {\n  // Edge's internal representation adds some fields therefore\n  // not all fieldѕ are taken into account.\n  var alreadyAdded = iceTransport.getRemoteCandidates()\n      .find(function(remoteCandidate) {\n        return candidate.foundation === remoteCandidate.foundation &&\n            candidate.ip === remoteCandidate.ip &&\n            candidate.port === remoteCandidate.port &&\n            candidate.priority === remoteCandidate.priority &&\n            candidate.protocol === remoteCandidate.protocol &&\n            candidate.type === remoteCandidate.type;\n      });\n  if (!alreadyAdded) {\n    iceTransport.addRemoteCandidate(candidate);\n  }\n  return !alreadyAdded;\n}\n\n\nfunction makeError(name, description) {\n  var e = new Error(description);\n  e.name = name;\n  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names\n  e.code = {\n    NotSupportedError: 9,\n    InvalidStateError: 11,\n    InvalidAccessError: 15,\n    TypeError: undefined,\n    OperationError: undefined\n  }[name];\n  return e;\n}\n\nmodule.exports = function(window, edgeVersion) {\n  // https://w3c.github.io/mediacapture-main/#mediastream\n  // Helper function to add the track to the stream and\n  // dispatch the event ourselves.\n  function addTrackToStreamAndFireEvent(track, stream) {\n    stream.addTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',\n        {track: track}));\n  }\n\n  function removeTrackFromStreamAndFireEvent(track, stream) {\n    stream.removeTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',\n        {track: track}));\n  }\n\n  function fireAddTrack(pc, track, receiver, streams) {\n    var trackEvent = new Event('track');\n    trackEvent.track = track;\n    trackEvent.receiver = receiver;\n    trackEvent.transceiver = {receiver: receiver};\n    trackEvent.streams = streams;\n    window.setTimeout(function() {\n      pc._dispatchEvent('track', trackEvent);\n    });\n  }\n\n  var RTCPeerConnection = function(config) {\n    var pc = this;\n\n    var _eventTarget = document.createDocumentFragment();\n    ['addEventListener', 'removeEventListener', 'dispatchEvent']\n        .forEach(function(method) {\n          pc[method] = _eventTarget[method].bind(_eventTarget);\n        });\n\n    this.canTrickleIceCandidates = null;\n\n    this.needNegotiation = false;\n\n    this.localStreams = [];\n    this.remoteStreams = [];\n\n    this._localDescription = null;\n    this._remoteDescription = null;\n\n    this.signalingState = 'stable';\n    this.iceConnectionState = 'new';\n    this.connectionState = 'new';\n    this.iceGatheringState = 'new';\n\n    config = JSON.parse(JSON.stringify(config || {}));\n\n    this.usingBundle = config.bundlePolicy === 'max-bundle';\n    if (config.rtcpMuxPolicy === 'negotiate') {\n      throw(makeError('NotSupportedError',\n          'rtcpMuxPolicy \\'negotiate\\' is not supported'));\n    } else if (!config.rtcpMuxPolicy) {\n      config.rtcpMuxPolicy = 'require';\n    }\n\n    switch (config.iceTransportPolicy) {\n      case 'all':\n      case 'relay':\n        break;\n      default:\n        config.iceTransportPolicy = 'all';\n        break;\n    }\n\n    switch (config.bundlePolicy) {\n      case 'balanced':\n      case 'max-compat':\n      case 'max-bundle':\n        break;\n      default:\n        config.bundlePolicy = 'balanced';\n        break;\n    }\n\n    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);\n\n    this._iceGatherers = [];\n    if (config.iceCandidatePoolSize) {\n      for (var i = config.iceCandidatePoolSize; i > 0; i--) {\n        this._iceGatherers.push(new window.RTCIceGatherer({\n          iceServers: config.iceServers,\n          gatherPolicy: config.iceTransportPolicy\n        }));\n      }\n    } else {\n      config.iceCandidatePoolSize = 0;\n    }\n\n    this._config = config;\n\n    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n    // everything that is needed to describe a SDP m-line.\n    this.transceivers = [];\n\n    this._sdpSessionId = SDPUtils.generateSessionId();\n    this._sdpSessionVersion = 0;\n\n    this._dtlsRole = undefined; // role for a=setup to use in answers.\n\n    this._isClosed = false;\n  };\n\n  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {\n    configurable: true,\n    get: function() {\n      return this._localDescription;\n    }\n  });\n  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {\n    configurable: true,\n    get: function() {\n      return this._remoteDescription;\n    }\n  });\n\n  // set up event handlers on prototype\n  RTCPeerConnection.prototype.onicecandidate = null;\n  RTCPeerConnection.prototype.onaddstream = null;\n  RTCPeerConnection.prototype.ontrack = null;\n  RTCPeerConnection.prototype.onremovestream = null;\n  RTCPeerConnection.prototype.onsignalingstatechange = null;\n  RTCPeerConnection.prototype.oniceconnectionstatechange = null;\n  RTCPeerConnection.prototype.onconnectionstatechange = null;\n  RTCPeerConnection.prototype.onicegatheringstatechange = null;\n  RTCPeerConnection.prototype.onnegotiationneeded = null;\n  RTCPeerConnection.prototype.ondatachannel = null;\n\n  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {\n    if (this._isClosed) {\n      return;\n    }\n    this.dispatchEvent(event);\n    if (typeof this['on' + name] === 'function') {\n      this['on' + name](event);\n    }\n  };\n\n  RTCPeerConnection.prototype._emitGatheringStateChange = function() {\n    var event = new Event('icegatheringstatechange');\n    this._dispatchEvent('icegatheringstatechange', event);\n  };\n\n  RTCPeerConnection.prototype.getConfiguration = function() {\n    return this._config;\n  };\n\n  RTCPeerConnection.prototype.getLocalStreams = function() {\n    return this.localStreams;\n  };\n\n  RTCPeerConnection.prototype.getRemoteStreams = function() {\n    return this.remoteStreams;\n  };\n\n  // internal helper to create a transceiver object.\n  // (which is not yet the same as the WebRTC 1.0 transceiver)\n  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {\n    var hasBundleTransport = this.transceivers.length > 0;\n    var transceiver = {\n      track: null,\n      iceGatherer: null,\n      iceTransport: null,\n      dtlsTransport: null,\n      localCapabilities: null,\n      remoteCapabilities: null,\n      rtpSender: null,\n      rtpReceiver: null,\n      kind: kind,\n      mid: null,\n      sendEncodingParameters: null,\n      recvEncodingParameters: null,\n      stream: null,\n      associatedRemoteMediaStreams: [],\n      wantReceive: true\n    };\n    if (this.usingBundle && hasBundleTransport) {\n      transceiver.iceTransport = this.transceivers[0].iceTransport;\n      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;\n    } else {\n      var transports = this._createIceAndDtlsTransports();\n      transceiver.iceTransport = transports.iceTransport;\n      transceiver.dtlsTransport = transports.dtlsTransport;\n    }\n    if (!doNotAdd) {\n      this.transceivers.push(transceiver);\n    }\n    return transceiver;\n  };\n\n  RTCPeerConnection.prototype.addTrack = function(track, stream) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call addTrack on a closed peerconnection.');\n    }\n\n    var alreadyExists = this.transceivers.find(function(s) {\n      return s.track === track;\n    });\n\n    if (alreadyExists) {\n      throw makeError('InvalidAccessError', 'Track already exists.');\n    }\n\n    var transceiver;\n    for (var i = 0; i < this.transceivers.length; i++) {\n      if (!this.transceivers[i].track &&\n          this.transceivers[i].kind === track.kind) {\n        transceiver = this.transceivers[i];\n      }\n    }\n    if (!transceiver) {\n      transceiver = this._createTransceiver(track.kind);\n    }\n\n    this._maybeFireNegotiationNeeded();\n\n    if (this.localStreams.indexOf(stream) === -1) {\n      this.localStreams.push(stream);\n    }\n\n    transceiver.track = track;\n    transceiver.stream = stream;\n    transceiver.rtpSender = new window.RTCRtpSender(track,\n        transceiver.dtlsTransport);\n    return transceiver.rtpSender;\n  };\n\n  RTCPeerConnection.prototype.addStream = function(stream) {\n    var pc = this;\n    if (edgeVersion >= 15025) {\n      stream.getTracks().forEach(function(track) {\n        pc.addTrack(track, stream);\n      });\n    } else {\n      // Clone is necessary for local demos mostly, attaching directly\n      // to two different senders does not work (build 10547).\n      // Fixed in 15025 (or earlier)\n      var clonedStream = stream.clone();\n      stream.getTracks().forEach(function(track, idx) {\n        var clonedTrack = clonedStream.getTracks()[idx];\n        track.addEventListener('enabled', function(event) {\n          clonedTrack.enabled = event.enabled;\n        });\n      });\n      clonedStream.getTracks().forEach(function(track) {\n        pc.addTrack(track, clonedStream);\n      });\n    }\n  };\n\n  RTCPeerConnection.prototype.removeTrack = function(sender) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call removeTrack on a closed peerconnection.');\n    }\n\n    if (!(sender instanceof window.RTCRtpSender)) {\n      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +\n          'does not implement interface RTCRtpSender.');\n    }\n\n    var transceiver = this.transceivers.find(function(t) {\n      return t.rtpSender === sender;\n    });\n\n    if (!transceiver) {\n      throw makeError('InvalidAccessError',\n          'Sender was not created by this connection.');\n    }\n    var stream = transceiver.stream;\n\n    transceiver.rtpSender.stop();\n    transceiver.rtpSender = null;\n    transceiver.track = null;\n    transceiver.stream = null;\n\n    // remove the stream from the set of local streams\n    var localStreams = this.transceivers.map(function(t) {\n      return t.stream;\n    });\n    if (localStreams.indexOf(stream) === -1 &&\n        this.localStreams.indexOf(stream) > -1) {\n      this.localStreams.splice(this.localStreams.indexOf(stream), 1);\n    }\n\n    this._maybeFireNegotiationNeeded();\n  };\n\n  RTCPeerConnection.prototype.removeStream = function(stream) {\n    var pc = this;\n    stream.getTracks().forEach(function(track) {\n      var sender = pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n      if (sender) {\n        pc.removeTrack(sender);\n      }\n    });\n  };\n\n  RTCPeerConnection.prototype.getSenders = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpSender;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpSender;\n    });\n  };\n\n  RTCPeerConnection.prototype.getReceivers = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpReceiver;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpReceiver;\n    });\n  };\n\n\n  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,\n      usingBundle) {\n    var pc = this;\n    if (usingBundle && sdpMLineIndex > 0) {\n      return this.transceivers[0].iceGatherer;\n    } else if (this._iceGatherers.length) {\n      return this._iceGatherers.shift();\n    }\n    var iceGatherer = new window.RTCIceGatherer({\n      iceServers: this._config.iceServers,\n      gatherPolicy: this._config.iceTransportPolicy\n    });\n    Object.defineProperty(iceGatherer, 'state',\n        {value: 'new', writable: true}\n    );\n\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];\n    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {\n      var end = !event.candidate || Object.keys(event.candidate).length === 0;\n      // polyfill since RTCIceGatherer.state is not implemented in\n      // Edge 10547 yet.\n      iceGatherer.state = end ? 'completed' : 'gathering';\n      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {\n        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);\n      }\n    };\n    iceGatherer.addEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    return iceGatherer;\n  };\n\n  // start gathering from an RTCIceGatherer.\n  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {\n    var pc = this;\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer.onlocalcandidate) {\n      return;\n    }\n    var bufferedCandidateEvents =\n      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;\n    iceGatherer.removeEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    iceGatherer.onlocalcandidate = function(evt) {\n      if (pc.usingBundle && sdpMLineIndex > 0) {\n        // if we know that we use bundle we can drop candidates with\n        // ѕdpMLineIndex > 0. If we don't do this then our state gets\n        // confused since we dispose the extra ice gatherer.\n        return;\n      }\n      var event = new Event('icecandidate');\n      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\n\n      var cand = evt.candidate;\n      // Edge emits an empty object for RTCIceCandidateComplete‥\n      var end = !cand || Object.keys(cand).length === 0;\n      if (end) {\n        // polyfill since RTCIceGatherer.state is not implemented in\n        // Edge 10547 yet.\n        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {\n          iceGatherer.state = 'completed';\n        }\n      } else {\n        if (iceGatherer.state === 'new') {\n          iceGatherer.state = 'gathering';\n        }\n        // RTCIceCandidate doesn't have a component, needs to be added\n        cand.component = 1;\n        // also the usernameFragment. TODO: update SDP to take both variants.\n        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;\n\n        var serializedCandidate = SDPUtils.writeCandidate(cand);\n        event.candidate = Object.assign(event.candidate,\n            SDPUtils.parseCandidate(serializedCandidate));\n\n        event.candidate.candidate = serializedCandidate;\n        event.candidate.toJSON = function() {\n          return {\n            candidate: event.candidate.candidate,\n            sdpMid: event.candidate.sdpMid,\n            sdpMLineIndex: event.candidate.sdpMLineIndex,\n            usernameFragment: event.candidate.usernameFragment\n          };\n        };\n      }\n\n      // update local description.\n      var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);\n      if (!end) {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=' + event.candidate.candidate + '\\r\\n';\n      } else {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=end-of-candidates\\r\\n';\n      }\n      pc._localDescription.sdp =\n          SDPUtils.getDescription(pc._localDescription.sdp) +\n          sections.join('');\n      var complete = pc.transceivers.every(function(transceiver) {\n        return transceiver.iceGatherer &&\n            transceiver.iceGatherer.state === 'completed';\n      });\n\n      if (pc.iceGatheringState !== 'gathering') {\n        pc.iceGatheringState = 'gathering';\n        pc._emitGatheringStateChange();\n      }\n\n      // Emit candidate. Also emit null candidate when all gatherers are\n      // complete.\n      if (!end) {\n        pc._dispatchEvent('icecandidate', event);\n      }\n      if (complete) {\n        pc._dispatchEvent('icecandidate', new Event('icecandidate'));\n        pc.iceGatheringState = 'complete';\n        pc._emitGatheringStateChange();\n      }\n    };\n\n    // emit already gathered candidates.\n    window.setTimeout(function() {\n      bufferedCandidateEvents.forEach(function(e) {\n        iceGatherer.onlocalcandidate(e);\n      });\n    }, 0);\n  };\n\n  // Create ICE transport and DTLS transport.\n  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {\n    var pc = this;\n    var iceTransport = new window.RTCIceTransport(null);\n    iceTransport.onicestatechange = function() {\n      pc._updateIceConnectionState();\n      pc._updateConnectionState();\n    };\n\n    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\n    dtlsTransport.ondtlsstatechange = function() {\n      pc._updateConnectionState();\n    };\n    dtlsTransport.onerror = function() {\n      // onerror does not set state to failed by itself.\n      Object.defineProperty(dtlsTransport, 'state',\n          {value: 'failed', writable: true});\n      pc._updateConnectionState();\n    };\n\n    return {\n      iceTransport: iceTransport,\n      dtlsTransport: dtlsTransport\n    };\n  };\n\n  // Destroy ICE gatherer, ICE transport and DTLS transport.\n  // Without triggering the callbacks.\n  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(\n      sdpMLineIndex) {\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer) {\n      delete iceGatherer.onlocalcandidate;\n      delete this.transceivers[sdpMLineIndex].iceGatherer;\n    }\n    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\n    if (iceTransport) {\n      delete iceTransport.onicestatechange;\n      delete this.transceivers[sdpMLineIndex].iceTransport;\n    }\n    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\n    if (dtlsTransport) {\n      delete dtlsTransport.ondtlsstatechange;\n      delete dtlsTransport.onerror;\n      delete this.transceivers[sdpMLineIndex].dtlsTransport;\n    }\n  };\n\n  // Start the RTP Sender and Receiver for a transceiver.\n  RTCPeerConnection.prototype._transceive = function(transceiver,\n      send, recv) {\n    var params = getCommonCapabilities(transceiver.localCapabilities,\n        transceiver.remoteCapabilities);\n    if (send && transceiver.rtpSender) {\n      params.encodings = transceiver.sendEncodingParameters;\n      params.rtcp = {\n        cname: SDPUtils.localCName,\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.recvEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpSender.send(params);\n    }\n    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {\n      // remove RTX field in Edge 14942\n      if (transceiver.kind === 'video'\n          && transceiver.recvEncodingParameters\n          && edgeVersion < 15019) {\n        transceiver.recvEncodingParameters.forEach(function(p) {\n          delete p.rtx;\n        });\n      }\n      if (transceiver.recvEncodingParameters.length) {\n        params.encodings = transceiver.recvEncodingParameters;\n      } else {\n        params.encodings = [{}];\n      }\n      params.rtcp = {\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.rtcpParameters.cname) {\n        params.rtcp.cname = transceiver.rtcpParameters.cname;\n      }\n      if (transceiver.sendEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpReceiver.receive(params);\n    }\n  };\n\n  RTCPeerConnection.prototype.setLocalDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setLocalDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set local ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var sections;\n    var sessionpart;\n    if (description.type === 'offer') {\n      // VERY limited support for SDP munging. Limited to:\n      // * changing the order of codecs\n      sections = SDPUtils.splitSections(description.sdp);\n      sessionpart = sections.shift();\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var caps = SDPUtils.parseRtpParameters(mediaSection);\n        pc.transceivers[sdpMLineIndex].localCapabilities = caps;\n      });\n\n      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n        pc._gather(transceiver.mid, sdpMLineIndex);\n      });\n    } else if (description.type === 'answer') {\n      sections = SDPUtils.splitSections(pc._remoteDescription.sdp);\n      sessionpart = sections.shift();\n      var isIceLite = SDPUtils.matchPrefix(sessionpart,\n          'a=ice-lite').length > 0;\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        var iceGatherer = transceiver.iceGatherer;\n        var iceTransport = transceiver.iceTransport;\n        var dtlsTransport = transceiver.dtlsTransport;\n        var localCapabilities = transceiver.localCapabilities;\n        var remoteCapabilities = transceiver.remoteCapabilities;\n\n        // treat bundle-only as not-rejected.\n        var rejected = SDPUtils.isRejected(mediaSection) &&\n            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n\n        if (!rejected && !transceiver.rejected) {\n          var remoteIceParameters = SDPUtils.getIceParameters(\n              mediaSection, sessionpart);\n          var remoteDtlsParameters = SDPUtils.getDtlsParameters(\n              mediaSection, sessionpart);\n          if (isIceLite) {\n            remoteDtlsParameters.role = 'server';\n          }\n\n          if (!pc.usingBundle || sdpMLineIndex === 0) {\n            pc._gather(transceiver.mid, sdpMLineIndex);\n            if (iceTransport.state === 'new') {\n              iceTransport.start(iceGatherer, remoteIceParameters,\n                  isIceLite ? 'controlling' : 'controlled');\n            }\n            if (dtlsTransport.state === 'new') {\n              dtlsTransport.start(remoteDtlsParameters);\n            }\n          }\n\n          // Calculate intersection of capabilities.\n          var params = getCommonCapabilities(localCapabilities,\n              remoteCapabilities);\n\n          // Start the RTCRtpSender. The RTCRtpReceiver for this\n          // transceiver has already been started in setRemoteDescription.\n          pc._transceive(transceiver,\n              params.codecs.length > 0,\n              false);\n        }\n      });\n    }\n\n    pc._localDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-local-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.setRemoteDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setRemoteDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set remote ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var streams = {};\n    pc.remoteStreams.forEach(function(stream) {\n      streams[stream.id] = stream;\n    });\n    var receiverList = [];\n    var sections = SDPUtils.splitSections(description.sdp);\n    var sessionpart = sections.shift();\n    var isIceLite = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-lite').length > 0;\n    var usingBundle = SDPUtils.matchPrefix(sessionpart,\n        'a=group:BUNDLE ').length > 0;\n    pc.usingBundle = usingBundle;\n    var iceOptions = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-options:')[0];\n    if (iceOptions) {\n      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')\n          .indexOf('trickle') >= 0;\n    } else {\n      pc.canTrickleIceCandidates = false;\n    }\n\n    sections.forEach(function(mediaSection, sdpMLineIndex) {\n      var lines = SDPUtils.splitLines(mediaSection);\n      var kind = SDPUtils.getKind(mediaSection);\n      // treat bundle-only as not-rejected.\n      var rejected = SDPUtils.isRejected(mediaSection) &&\n          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n      var protocol = lines[0].substr(2).split(' ')[2];\n\n      var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n      var remoteMsid = SDPUtils.parseMsid(mediaSection);\n\n      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();\n\n      // Reject datachannels which are not implemented yet.\n      if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||\n          protocol === 'UDP/DTLS/SCTP'))) {\n        // TODO: this is dangerous in the case where a non-rejected m-line\n        //     becomes rejected.\n        pc.transceivers[sdpMLineIndex] = {\n          mid: mid,\n          kind: kind,\n          protocol: protocol,\n          rejected: true\n        };\n        return;\n      }\n\n      if (!rejected && pc.transceivers[sdpMLineIndex] &&\n          pc.transceivers[sdpMLineIndex].rejected) {\n        // recycle a rejected transceiver.\n        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);\n      }\n\n      var transceiver;\n      var iceGatherer;\n      var iceTransport;\n      var dtlsTransport;\n      var rtpReceiver;\n      var sendEncodingParameters;\n      var recvEncodingParameters;\n      var localCapabilities;\n\n      var track;\n      // FIXME: ensure the mediaSection has rtcp-mux set.\n      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n      var remoteIceParameters;\n      var remoteDtlsParameters;\n      if (!rejected) {\n        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters.role = 'client';\n      }\n      recvEncodingParameters =\n          SDPUtils.parseRtpEncodingParameters(mediaSection);\n\n      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);\n\n      var isComplete = SDPUtils.matchPrefix(mediaSection,\n          'a=end-of-candidates', sessionpart).length > 0;\n      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\n          .map(function(cand) {\n            return SDPUtils.parseCandidate(cand);\n          })\n          .filter(function(cand) {\n            return cand.component === 1;\n          });\n\n      // Check if we can use BUNDLE and dispose transports.\n      if ((description.type === 'offer' || description.type === 'answer') &&\n          !rejected && usingBundle && sdpMLineIndex > 0 &&\n          pc.transceivers[sdpMLineIndex]) {\n        pc._disposeIceAndDtlsTransports(sdpMLineIndex);\n        pc.transceivers[sdpMLineIndex].iceGatherer =\n            pc.transceivers[0].iceGatherer;\n        pc.transceivers[sdpMLineIndex].iceTransport =\n            pc.transceivers[0].iceTransport;\n        pc.transceivers[sdpMLineIndex].dtlsTransport =\n            pc.transceivers[0].dtlsTransport;\n        if (pc.transceivers[sdpMLineIndex].rtpSender) {\n          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {\n          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n      }\n      if (description.type === 'offer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex] ||\n            pc._createTransceiver(kind);\n        transceiver.mid = mid;\n\n        if (!transceiver.iceGatherer) {\n          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n              usingBundle);\n        }\n\n        if (cands.length && transceiver.iceTransport.state === 'new') {\n          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {\n            transceiver.iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);\n\n        // filter RTX until additional stuff needed for RTX is implemented\n        // in adapter.js\n        if (edgeVersion < 15019) {\n          localCapabilities.codecs = localCapabilities.codecs.filter(\n              function(codec) {\n                return codec.name !== 'rtx';\n              });\n        }\n\n        sendEncodingParameters = transceiver.sendEncodingParameters || [{\n          ssrc: (2 * sdpMLineIndex + 2) * 1001\n        }];\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        var isNewTrack = false;\n        if (direction === 'sendrecv' || direction === 'sendonly') {\n          isNewTrack = !transceiver.rtpReceiver;\n          rtpReceiver = transceiver.rtpReceiver ||\n              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);\n\n          if (isNewTrack) {\n            var stream;\n            track = rtpReceiver.track;\n            // FIXME: does not work with Plan B.\n            if (remoteMsid && remoteMsid.stream === '-') {\n              // no-op. a stream id of '-' means: no associated stream.\n            } else if (remoteMsid) {\n              if (!streams[remoteMsid.stream]) {\n                streams[remoteMsid.stream] = new window.MediaStream();\n                Object.defineProperty(streams[remoteMsid.stream], 'id', {\n                  get: function() {\n                    return remoteMsid.stream;\n                  }\n                });\n              }\n              Object.defineProperty(track, 'id', {\n                get: function() {\n                  return remoteMsid.track;\n                }\n              });\n              stream = streams[remoteMsid.stream];\n            } else {\n              if (!streams.default) {\n                streams.default = new window.MediaStream();\n              }\n              stream = streams.default;\n            }\n            if (stream) {\n              addTrackToStreamAndFireEvent(track, stream);\n              transceiver.associatedRemoteMediaStreams.push(stream);\n            }\n            receiverList.push([track, rtpReceiver, stream]);\n          }\n        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {\n          transceiver.associatedRemoteMediaStreams.forEach(function(s) {\n            var nativeTrack = s.getTracks().find(function(t) {\n              return t.id === transceiver.rtpReceiver.track.id;\n            });\n            if (nativeTrack) {\n              removeTrackFromStreamAndFireEvent(nativeTrack, s);\n            }\n          });\n          transceiver.associatedRemoteMediaStreams = [];\n        }\n\n        transceiver.localCapabilities = localCapabilities;\n        transceiver.remoteCapabilities = remoteCapabilities;\n        transceiver.rtpReceiver = rtpReceiver;\n        transceiver.rtcpParameters = rtcpParameters;\n        transceiver.sendEncodingParameters = sendEncodingParameters;\n        transceiver.recvEncodingParameters = recvEncodingParameters;\n\n        // Start the RTCRtpReceiver now. The RTPSender is started in\n        // setLocalDescription.\n        pc._transceive(pc.transceivers[sdpMLineIndex],\n            false,\n            isNewTrack);\n      } else if (description.type === 'answer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex];\n        iceGatherer = transceiver.iceGatherer;\n        iceTransport = transceiver.iceTransport;\n        dtlsTransport = transceiver.dtlsTransport;\n        rtpReceiver = transceiver.rtpReceiver;\n        sendEncodingParameters = transceiver.sendEncodingParameters;\n        localCapabilities = transceiver.localCapabilities;\n\n        pc.transceivers[sdpMLineIndex].recvEncodingParameters =\n            recvEncodingParameters;\n        pc.transceivers[sdpMLineIndex].remoteCapabilities =\n            remoteCapabilities;\n        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;\n\n        if (cands.length && iceTransport.state === 'new') {\n          if ((isIceLite || isComplete) &&\n              (!usingBundle || sdpMLineIndex === 0)) {\n            iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        if (!usingBundle || sdpMLineIndex === 0) {\n          if (iceTransport.state === 'new') {\n            iceTransport.start(iceGatherer, remoteIceParameters,\n                'controlling');\n          }\n          if (dtlsTransport.state === 'new') {\n            dtlsTransport.start(remoteDtlsParameters);\n          }\n        }\n\n        // If the offer contained RTX but the answer did not,\n        // remove RTX from sendEncodingParameters.\n        var commonCapabilities = getCommonCapabilities(\n          transceiver.localCapabilities,\n          transceiver.remoteCapabilities);\n\n        var hasRtx = commonCapabilities.codecs.filter(function(c) {\n          return c.name.toLowerCase() === 'rtx';\n        }).length;\n        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n          delete transceiver.sendEncodingParameters[0].rtx;\n        }\n\n        pc._transceive(transceiver,\n            direction === 'sendrecv' || direction === 'recvonly',\n            direction === 'sendrecv' || direction === 'sendonly');\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        if (rtpReceiver &&\n            (direction === 'sendrecv' || direction === 'sendonly')) {\n          track = rtpReceiver.track;\n          if (remoteMsid) {\n            if (!streams[remoteMsid.stream]) {\n              streams[remoteMsid.stream] = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\n          } else {\n            if (!streams.default) {\n              streams.default = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams.default);\n            receiverList.push([track, rtpReceiver, streams.default]);\n          }\n        } else {\n          // FIXME: actually the receiver should be created later.\n          delete transceiver.rtpReceiver;\n        }\n      }\n    });\n\n    if (pc._dtlsRole === undefined) {\n      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';\n    }\n\n    pc._remoteDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-remote-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n    Object.keys(streams).forEach(function(sid) {\n      var stream = streams[sid];\n      if (stream.getTracks().length) {\n        if (pc.remoteStreams.indexOf(stream) === -1) {\n          pc.remoteStreams.push(stream);\n          var event = new Event('addstream');\n          event.stream = stream;\n          window.setTimeout(function() {\n            pc._dispatchEvent('addstream', event);\n          });\n        }\n\n        receiverList.forEach(function(item) {\n          var track = item[0];\n          var receiver = item[1];\n          if (stream.id !== item[2].id) {\n            return;\n          }\n          fireAddTrack(pc, track, receiver, [stream]);\n        });\n      }\n    });\n    receiverList.forEach(function(item) {\n      if (item[2]) {\n        return;\n      }\n      fireAddTrack(pc, item[0], item[1], []);\n    });\n\n    // check whether addIceCandidate({}) was called within four seconds after\n    // setRemoteDescription.\n    window.setTimeout(function() {\n      if (!(pc && pc.transceivers)) {\n        return;\n      }\n      pc.transceivers.forEach(function(transceiver) {\n        if (transceiver.iceTransport &&\n            transceiver.iceTransport.state === 'new' &&\n            transceiver.iceTransport.getRemoteCandidates().length > 0) {\n          console.warn('Timeout for addRemoteCandidate. Consider sending ' +\n              'an end-of-candidates notification');\n          transceiver.iceTransport.addRemoteCandidate({});\n        }\n      });\n    }, 4000);\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.close = function() {\n    this.transceivers.forEach(function(transceiver) {\n      /* not yet\n      if (transceiver.iceGatherer) {\n        transceiver.iceGatherer.close();\n      }\n      */\n      if (transceiver.iceTransport) {\n        transceiver.iceTransport.stop();\n      }\n      if (transceiver.dtlsTransport) {\n        transceiver.dtlsTransport.stop();\n      }\n      if (transceiver.rtpSender) {\n        transceiver.rtpSender.stop();\n      }\n      if (transceiver.rtpReceiver) {\n        transceiver.rtpReceiver.stop();\n      }\n    });\n    // FIXME: clean up tracks, local streams, remote streams, etc\n    this._isClosed = true;\n    this._updateSignalingState('closed');\n  };\n\n  // Update the signaling state.\n  RTCPeerConnection.prototype._updateSignalingState = function(newState) {\n    this.signalingState = newState;\n    var event = new Event('signalingstatechange');\n    this._dispatchEvent('signalingstatechange', event);\n  };\n\n  // Determine whether to fire the negotiationneeded event.\n  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {\n    var pc = this;\n    if (this.signalingState !== 'stable' || this.needNegotiation === true) {\n      return;\n    }\n    this.needNegotiation = true;\n    window.setTimeout(function() {\n      if (pc.needNegotiation) {\n        pc.needNegotiation = false;\n        var event = new Event('negotiationneeded');\n        pc._dispatchEvent('negotiationneeded', event);\n      }\n    }, 0);\n  };\n\n  // Update the ice connection state.\n  RTCPeerConnection.prototype._updateIceConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      checking: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      if (transceiver.iceTransport && !transceiver.rejected) {\n        states[transceiver.iceTransport.state]++;\n      }\n    });\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.checking > 0) {\n      newState = 'checking';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    } else if (states.completed > 0) {\n      newState = 'completed';\n    }\n\n    if (newState !== this.iceConnectionState) {\n      this.iceConnectionState = newState;\n      var event = new Event('iceconnectionstatechange');\n      this._dispatchEvent('iceconnectionstatechange', event);\n    }\n  };\n\n  // Update the connection state.\n  RTCPeerConnection.prototype._updateConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      connecting: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      if (transceiver.iceTransport && transceiver.dtlsTransport &&\n          !transceiver.rejected) {\n        states[transceiver.iceTransport.state]++;\n        states[transceiver.dtlsTransport.state]++;\n      }\n    });\n    // ICETransport.completed and connected are the same for this purpose.\n    states.connected += states.completed;\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.connecting > 0) {\n      newState = 'connecting';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    }\n\n    if (newState !== this.connectionState) {\n      this.connectionState = newState;\n      var event = new Event('connectionstatechange');\n      this._dispatchEvent('connectionstatechange', event);\n    }\n  };\n\n  RTCPeerConnection.prototype.createOffer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createOffer after close'));\n    }\n\n    var numAudioTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'audio';\n    }).length;\n    var numVideoTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'video';\n    }).length;\n\n    // Determine number of audio and video tracks we need to send/recv.\n    var offerOptions = arguments[0];\n    if (offerOptions) {\n      // Reject Chrome legacy constraints.\n      if (offerOptions.mandatory || offerOptions.optional) {\n        throw new TypeError(\n            'Legacy mandatory/optional constraints not supported.');\n      }\n      if (offerOptions.offerToReceiveAudio !== undefined) {\n        if (offerOptions.offerToReceiveAudio === true) {\n          numAudioTracks = 1;\n        } else if (offerOptions.offerToReceiveAudio === false) {\n          numAudioTracks = 0;\n        } else {\n          numAudioTracks = offerOptions.offerToReceiveAudio;\n        }\n      }\n      if (offerOptions.offerToReceiveVideo !== undefined) {\n        if (offerOptions.offerToReceiveVideo === true) {\n          numVideoTracks = 1;\n        } else if (offerOptions.offerToReceiveVideo === false) {\n          numVideoTracks = 0;\n        } else {\n          numVideoTracks = offerOptions.offerToReceiveVideo;\n        }\n      }\n    }\n\n    pc.transceivers.forEach(function(transceiver) {\n      if (transceiver.kind === 'audio') {\n        numAudioTracks--;\n        if (numAudioTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      } else if (transceiver.kind === 'video') {\n        numVideoTracks--;\n        if (numVideoTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      }\n    });\n\n    // Create M-lines for recvonly streams.\n    while (numAudioTracks > 0 || numVideoTracks > 0) {\n      if (numAudioTracks > 0) {\n        pc._createTransceiver('audio');\n        numAudioTracks--;\n      }\n      if (numVideoTracks > 0) {\n        pc._createTransceiver('video');\n        numVideoTracks--;\n      }\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      // For each track, create an ice gatherer, ice transport,\n      // dtls transport, potentially rtpsender and rtpreceiver.\n      var track = transceiver.track;\n      var kind = transceiver.kind;\n      var mid = transceiver.mid || SDPUtils.generateIdentifier();\n      transceiver.mid = mid;\n\n      if (!transceiver.iceGatherer) {\n        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n            pc.usingBundle);\n      }\n\n      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);\n      // filter RTX until additional stuff needed for RTX is implemented\n      // in adapter.js\n      if (edgeVersion < 15019) {\n        localCapabilities.codecs = localCapabilities.codecs.filter(\n            function(codec) {\n              return codec.name !== 'rtx';\n            });\n      }\n      localCapabilities.codecs.forEach(function(codec) {\n        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552\n        // by adding level-asymmetry-allowed=1\n        if (codec.name === 'H264' &&\n            codec.parameters['level-asymmetry-allowed'] === undefined) {\n          codec.parameters['level-asymmetry-allowed'] = '1';\n        }\n\n        // for subsequent offers, we might have to re-use the payload\n        // type of the last offer.\n        if (transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.codecs) {\n          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {\n            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&\n                codec.clockRate === remoteCodec.clockRate) {\n              codec.preferredPayloadType = remoteCodec.payloadType;\n            }\n          });\n        }\n      });\n      localCapabilities.headerExtensions.forEach(function(hdrExt) {\n        var remoteExtensions = transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.headerExtensions || [];\n        remoteExtensions.forEach(function(rHdrExt) {\n          if (hdrExt.uri === rHdrExt.uri) {\n            hdrExt.id = rHdrExt.id;\n          }\n        });\n      });\n\n      // generate an ssrc now, to be used later in rtpSender.send\n      var sendEncodingParameters = transceiver.sendEncodingParameters || [{\n        ssrc: (2 * sdpMLineIndex + 1) * 1001\n      }];\n      if (track) {\n        // add RTX\n        if (edgeVersion >= 15019 && kind === 'video' &&\n            !sendEncodingParameters[0].rtx) {\n          sendEncodingParameters[0].rtx = {\n            ssrc: sendEncodingParameters[0].ssrc + 1\n          };\n        }\n      }\n\n      if (transceiver.wantReceive) {\n        transceiver.rtpReceiver = new window.RTCRtpReceiver(\n            transceiver.dtlsTransport, kind);\n      }\n\n      transceiver.localCapabilities = localCapabilities;\n      transceiver.sendEncodingParameters = sendEncodingParameters;\n    });\n\n    // always offer BUNDLE and dispose on return if not supported.\n    if (pc._config.bundlePolicy !== 'max-compat') {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,\n          'offer', transceiver.stream, pc._dtlsRole);\n      sdp += 'a=rtcp-rsize\\r\\n';\n\n      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&\n          (sdpMLineIndex === 0 || !pc.usingBundle)) {\n        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {\n          cand.component = 1;\n          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\\r\\n';\n        });\n\n        if (transceiver.iceGatherer.state === 'completed') {\n          sdp += 'a=end-of-candidates\\r\\n';\n        }\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'offer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.createAnswer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer after close'));\n    }\n\n    if (!(pc.signalingState === 'have-remote-offer' ||\n        pc.signalingState === 'have-local-pranswer')) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer in signalingState ' + pc.signalingState));\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    if (pc.usingBundle) {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    var mediaSectionsInOffer = SDPUtils.getMediaSections(\n        pc._remoteDescription.sdp).length;\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {\n        return;\n      }\n      if (transceiver.rejected) {\n        if (transceiver.kind === 'application') {\n          if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt\n            sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n';\n          } else {\n            sdp += 'm=application 0 ' + transceiver.protocol +\n                ' webrtc-datachannel\\r\\n';\n          }\n        } else if (transceiver.kind === 'audio') {\n          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\\r\\n' +\n              'a=rtpmap:0 PCMU/8000\\r\\n';\n        } else if (transceiver.kind === 'video') {\n          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\\r\\n' +\n              'a=rtpmap:120 VP8/90000\\r\\n';\n        }\n        sdp += 'c=IN IP4 0.0.0.0\\r\\n' +\n            'a=inactive\\r\\n' +\n            'a=mid:' + transceiver.mid + '\\r\\n';\n        return;\n      }\n\n      // FIXME: look at direction.\n      if (transceiver.stream) {\n        var localTrack;\n        if (transceiver.kind === 'audio') {\n          localTrack = transceiver.stream.getAudioTracks()[0];\n        } else if (transceiver.kind === 'video') {\n          localTrack = transceiver.stream.getVideoTracks()[0];\n        }\n        if (localTrack) {\n          // add RTX\n          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&\n              !transceiver.sendEncodingParameters[0].rtx) {\n            transceiver.sendEncodingParameters[0].rtx = {\n              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1\n            };\n          }\n        }\n      }\n\n      // Calculate intersection of capabilities.\n      var commonCapabilities = getCommonCapabilities(\n          transceiver.localCapabilities,\n          transceiver.remoteCapabilities);\n\n      var hasRtx = commonCapabilities.codecs.filter(function(c) {\n        return c.name.toLowerCase() === 'rtx';\n      }).length;\n      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n        delete transceiver.sendEncodingParameters[0].rtx;\n      }\n\n      sdp += writeMediaSection(transceiver, commonCapabilities,\n          'answer', transceiver.stream, pc._dtlsRole);\n      if (transceiver.rtcpParameters &&\n          transceiver.rtcpParameters.reducedSize) {\n        sdp += 'a=rtcp-rsize\\r\\n';\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'answer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\n    var pc = this;\n    var sections;\n    if (candidate && !(candidate.sdpMLineIndex !== undefined ||\n        candidate.sdpMid)) {\n      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));\n    }\n\n    // TODO: needs to go into ops queue.\n    return new Promise(function(resolve, reject) {\n      if (!pc._remoteDescription) {\n        return reject(makeError('InvalidStateError',\n            'Can not add ICE candidate without a remote description'));\n      } else if (!candidate || candidate.candidate === '') {\n        for (var j = 0; j < pc.transceivers.length; j++) {\n          if (pc.transceivers[j].rejected) {\n            continue;\n          }\n          pc.transceivers[j].iceTransport.addRemoteCandidate({});\n          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);\n          sections[j] += 'a=end-of-candidates\\r\\n';\n          pc._remoteDescription.sdp =\n              SDPUtils.getDescription(pc._remoteDescription.sdp) +\n              sections.join('');\n          if (pc.usingBundle) {\n            break;\n          }\n        }\n      } else {\n        var sdpMLineIndex = candidate.sdpMLineIndex;\n        if (candidate.sdpMid) {\n          for (var i = 0; i < pc.transceivers.length; i++) {\n            if (pc.transceivers[i].mid === candidate.sdpMid) {\n              sdpMLineIndex = i;\n              break;\n            }\n          }\n        }\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        if (transceiver) {\n          if (transceiver.rejected) {\n            return resolve();\n          }\n          var cand = Object.keys(candidate.candidate).length > 0 ?\n              SDPUtils.parseCandidate(candidate.candidate) : {};\n          // Ignore Chrome's invalid candidates since Edge does not like them.\n          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\n            return resolve();\n          }\n          // Ignore RTCP candidates, we assume RTCP-MUX.\n          if (cand.component && cand.component !== 1) {\n            return resolve();\n          }\n          // when using bundle, avoid adding candidates to the wrong\n          // ice transport. And avoid adding candidates added in the SDP.\n          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&\n              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {\n            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {\n              return reject(makeError('OperationError',\n                  'Can not add ICE candidate'));\n            }\n          }\n\n          // update the remoteDescription.\n          var candidateString = candidate.candidate.trim();\n          if (candidateString.indexOf('a=') === 0) {\n            candidateString = candidateString.substr(2);\n          }\n          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);\n          sections[sdpMLineIndex] += 'a=' +\n              (cand.type ? candidateString : 'end-of-candidates')\n              + '\\r\\n';\n          pc._remoteDescription.sdp =\n              SDPUtils.getDescription(pc._remoteDescription.sdp) +\n              sections.join('');\n        } else {\n          return reject(makeError('OperationError',\n              'Can not add ICE candidate'));\n        }\n      }\n      resolve();\n    });\n  };\n\n  RTCPeerConnection.prototype.getStats = function(selector) {\n    if (selector && selector instanceof window.MediaStreamTrack) {\n      var senderOrReceiver = null;\n      this.transceivers.forEach(function(transceiver) {\n        if (transceiver.rtpSender &&\n            transceiver.rtpSender.track === selector) {\n          senderOrReceiver = transceiver.rtpSender;\n        } else if (transceiver.rtpReceiver &&\n            transceiver.rtpReceiver.track === selector) {\n          senderOrReceiver = transceiver.rtpReceiver;\n        }\n      });\n      if (!senderOrReceiver) {\n        throw makeError('InvalidAccessError', 'Invalid selector.');\n      }\n      return senderOrReceiver.getStats();\n    }\n\n    var promises = [];\n    this.transceivers.forEach(function(transceiver) {\n      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\n          'dtlsTransport'].forEach(function(method) {\n            if (transceiver[method]) {\n              promises.push(transceiver[method].getStats());\n            }\n          });\n    });\n    return Promise.all(promises).then(function(allStats) {\n      var results = new Map();\n      allStats.forEach(function(stats) {\n        stats.forEach(function(stat) {\n          results.set(stat.id, stat);\n        });\n      });\n      return results;\n    });\n  };\n\n  // fix low-level stat names and return Map instead of object.\n  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',\n    'RTCIceTransport', 'RTCDtlsTransport'];\n  ortcObjects.forEach(function(ortcObjectName) {\n    var obj = window[ortcObjectName];\n    if (obj && obj.prototype && obj.prototype.getStats) {\n      var nativeGetstats = obj.prototype.getStats;\n      obj.prototype.getStats = function() {\n        return nativeGetstats.apply(this)\n        .then(function(nativeStats) {\n          var mapStats = new Map();\n          Object.keys(nativeStats).forEach(function(id) {\n            nativeStats[id].type = fixStatsType(nativeStats[id]);\n            mapStats.set(id, nativeStats[id]);\n          });\n          return mapStats;\n        });\n      };\n    }\n  });\n\n  // legacy callback shims. Should be moved to adapter.js some days.\n  var methods = ['createOffer', 'createAnswer'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[0] === 'function' ||\n          typeof args[1] === 'function') { // legacy\n        return nativeMethod.apply(this, [arguments[2]])\n        .then(function(description) {\n          if (typeof args[0] === 'function') {\n            args[0].apply(null, [description]);\n          }\n        }, function(error) {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function' ||\n          typeof args[2] === 'function') { // legacy\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        }, function(error) {\n          if (typeof args[2] === 'function') {\n            args[2].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  // getStats is special. It doesn't have a spec legacy method yet we support\n  // getStats(something, cb) without error callbacks.\n  ['getStats'].forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function') {\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  return RTCPeerConnection;\n};\n\n\n//# sourceURL=webpack:///./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/grammar.js":
/*!***************************************************!*\
  !*** ./node_modules/sdp-transform/lib/grammar.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var grammar = module.exports = {\n  v: [{\n    name: 'version',\n    reg: /^(\\d*)$/\n  }],\n  o: [{\n    // o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: '%s %s %d %s IP%d %s'\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n  // k: [{}], // outdated thing ignored\n  t: [{\n    // t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: '%d %d'\n  }],\n  c: [{\n    // c=IN IP4 10.47.197.26\n    name: 'connection',\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: ['version', 'ip'],\n    format: 'IN IP%d %s'\n  }],\n  b: [{\n    // b=AS:4000\n    push: 'bandwidth',\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: ['type', 'limit'],\n    format: '%s:%s'\n  }],\n  m: [{\n    // m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n    names: ['type', 'port', 'protocol', 'payloads'],\n    format: '%s %d %s %s'\n  }],\n  a: [\n    {\n      // a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return (o.encoding)\n          ? 'rtpmap:%d %s/%s/%s'\n          : o.rate\n            ? 'rtpmap:%d %s/%s'\n            : 'rtpmap:%d %s';\n      }\n    },\n    {\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      // a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: 'fmtp:%d %s'\n    },\n    {\n      // a=control:streamid=0\n      name: 'control',\n      reg: /^control:(.*)/,\n      format: 'control:%s'\n    },\n    {\n      // a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return (o.address != null)\n          ? 'rtcp:%d %s IP%d %s'\n          : 'rtcp:%d';\n      }\n    },\n    {\n      // a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: 'rtcp-fb:%d trr-int %d'\n    },\n    {\n      // a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return (o.subtype != null)\n          ? 'rtcp-fb:%s %s %s'\n          : 'rtcp-fb:%s %s';\n      }\n    },\n    {\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      // a=extmap:1/recvonly URI-gps-string\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n      push: 'ext',\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],\n      format: function (o) {\n        return (\n          'extmap:%d' +\n          (o.direction ? '/%s' : '%v') +\n          (o['encrypt-uri'] ? ' %s' : '%v') +\n          ' %s' +\n          (o.config ? ' %s' : '')\n        );\n      }\n    },\n    {\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return (o.sessionConfig != null)\n          ? 'crypto:%d %s %s %s'\n          : 'crypto:%d %s %s';\n      }\n    },\n    {\n      // a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: 'setup:%s'\n    },\n    {\n      // a=connection:new\n      name: 'connectionType',\n      reg: /^connection:(new|existing)/,\n      format: 'connection:%s'\n    },\n    {\n      // a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: 'mid:%s'\n    },\n    {\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: 'msid:%s'\n    },\n    {\n      // a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*)/,\n      format: 'ptime:%d'\n    },\n    {\n      // a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*)/,\n      format: 'maxptime:%d'\n    },\n    {\n      // a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    {\n      // a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    },\n    {\n      // a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: 'ice-ufrag:%s'\n    },\n    {\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: 'ice-pwd:%s'\n    },\n    {\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: 'fingerprint:%s %s'\n    },\n    {\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push:'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n      format: function (o) {\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\n\n        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += (o.tcptype != null) ? ' tcptype %s' : '%v';\n\n        if (o.generation != null) {\n          str += ' generation %d';\n        }\n\n        str += (o['network-id'] != null) ? ' network-id %d' : '%v';\n        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\n        return str;\n      }\n    },\n    {\n      // a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    },\n    {\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: 'remote-candidates:%s'\n    },\n    {\n      // a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: 'ice-options:%s'\n    },\n    {\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: 'ssrcs',\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: ['id', 'attribute', 'value'],\n      format: function (o) {\n        var str = 'ssrc:%d';\n        if (o.attribute != null) {\n          str += ' %s';\n          if (o.value != null) {\n            str += ':%s';\n          }\n        }\n        return str;\n      }\n    },\n    {\n      // a=ssrc-group:FEC 1 2\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: 'ssrcGroups',\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: 'ssrc-group:%s %s'\n    },\n    {\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: 'msidSemantic',\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n    },\n    {\n      // a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: 'group:%s %s'\n    },\n    {\n      // a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    },\n    {\n      // a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    },\n    {\n      // a=sctpmap:5000 webrtc-datachannel 1024\n      name: 'sctpmap',\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n      format: function (o) {\n        return (o.maxMessageSize != null)\n          ? 'sctpmap:%s %s %s'\n          : 'sctpmap:%s %s';\n      }\n    },\n    {\n      // a=x-google-flag:conference\n      name: 'xGoogleFlag',\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: 'x-google-flag:%s'\n    },\n    {\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: 'rids',\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: ['id', 'direction', 'params'],\n      format: function (o) {\n        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\n      }\n    },\n    {\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      // a=imageattr:* send [x=800,y=640] recv *\n      // a=imageattr:100 recv [x=320,y=240]\n      push: 'imageattrs',\n      reg: new RegExp(\n        // a=imageattr:97\n        '^imageattr:(\\\\d+|\\\\*)' +\n        // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n        '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n        // recv [x=330,y=250]\n        '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\n      ),\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n      format: function (o) {\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      // a=simulcast:recv 1;4,5 send 6;7\n      name: 'simulcast',\n      reg: new RegExp(\n        // a=simulcast:\n        '^simulcast:' +\n        // send 1,2,3;~4,~5\n        '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n        // space + recv 6;~7,~8\n        '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n        // end\n        '$'\n      ),\n      names: ['dir1', 'list1', 'dir2', 'list2'],\n      format: function (o) {\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // old simulcast draft 03 (implemented by Firefox)\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      // a=simulcast: recv pt=97;98 send pt=97\n      // a=simulcast: send rid=5;6;7 paused=6,7\n      name: 'simulcast_03',\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: ['value'],\n      format: 'simulcast: %s'\n    },\n    {\n      // a=framerate:25\n      // a=framerate:29.97\n      name: 'framerate',\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: 'framerate:%s'\n    },\n    {\n      // RFC4570\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: 'sourceFilter',\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\n      format: 'source-filter: %s %s %s %s %s'\n    },\n    {\n      // a=bundle-only\n      name: 'bundleOnly',\n      reg: /^(bundle-only)/\n    },\n    {\n      // a=label:1\n      name: 'label',\n      reg: /^label:(.+)/,\n      format: 'label:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n      name: 'sctpPort',\n      reg: /^sctp-port:(\\d+)$/,\n      format: 'sctp-port:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n      name: 'maxMessageSize',\n      reg: /^max-message-size:(\\d+)$/,\n      format: 'max-message-size:%s'\n    },\n    {\n      // a=keywds:keywords\n      name: 'keywords',\n      reg: /^keywds:(.+)$/,\n      format: 'keywds:%s'\n    },\n    {\n      // a=content:main\n      name: 'content',\n      reg: /^content:(.+)/,\n      format: 'content:%s'\n    },\n    // BFCP https://tools.ietf.org/html/rfc4583\n    {\n      // a=floorctrl:c-s\n      name: 'bfcpFloorCtrl',\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\n      format: 'floorctrl:%s'\n    },\n    {\n      // a=confid:1\n      name: 'bfcpConfId',\n      reg: /^confid:(\\d+)/,\n      format: 'confid:%s'\n    },\n    {\n      // a=userid:1\n      name: 'bfcpUserId',\n      reg: /^userid:(\\d+)/,\n      format: 'userid:%s'\n    },\n    {\n      // a=floorid:1\n      name: 'bfcpFloorId',\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n      names: ['id', 'mStream'],\n      format: 'floorid:%s mstrm:%s'\n    },\n    {\n      // any a= that we don't understand is kept verbatim on media.invalid\n      push: 'invalid',\n      names: ['value']\n    }\n  ]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = '%s';\n    }\n  });\n});\n\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/grammar.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/sdp-transform/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var parser = __webpack_require__(/*! ./parser */ \"./node_modules/sdp-transform/lib/parser.js\");\nvar writer = __webpack_require__(/*! ./writer */ \"./node_modules/sdp-transform/lib/writer.js\");\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseFmtpConfig = parser.parseFmtpConfig;\nexports.parseParams = parser.parseParams;\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/index.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/parser.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/parser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  }\n  else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i+1] != null) {\n        location[names[i]] = toIntIfInt(match[i+1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  }\n  else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ?\n    {} :  // blank object that will be pushed\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\");\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {}\n    , media = []\n    , location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({rtp: [], fmtp: []});\n      location = media[media.length-1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar paramReducer = function (acc, expr) {\n  var s = expr.split(/=(.+)/, 2);\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  } else if (s.length === 1 && expr.length > 1) {\n    acc[s[0]] = undefined;\n  }\n  return acc;\n};\n\nexports.parseParams = function (str) {\n  return str.split(/;\\s?/).reduce(paramReducer, {});\n};\n\n// For backward compatibility - alias will be removed in 3.0.0\nexports.parseFmtpConfig = exports.parseParams;\n\nexports.parsePayloads = function (str) {\n  return str.toString().split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\nexports.parseImageAttributes = function (str) {\n  return str.split(' ').map(function (item) {\n    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});\n  });\n};\n\nexports.parseSimulcastStreamList = function (str) {\n  return str.split(';').map(function (stream) {\n    return stream.split(',').map(function (format) {\n      var scid, paused = false;\n\n      if (format[0] !== '~') {\n        scid = toIntIfInt(format);\n      } else {\n        scid = toIntIfInt(format.substring(1, format.length));\n        paused = true;\n      }\n\n      return {\n        scid: scid,\n        paused: paused\n      };\n    });\n  });\n};\n\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/parser.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/writer.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/writer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\");\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/writer.js?");

/***/ }),

/***/ "./node_modules/sdp/sdp.js":
/*!*********************************!*\
  !*** ./node_modules/sdp/sdp.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" /* eslint-env node */\n\n\n// SDP helpers.\nvar SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(function(line) {\n    return line.trim();\n  });\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  var parts = blob.split('\\nm=');\n  return parts.map(function(part, index) {\n    return (index > 0 ? 'm=' + part : part).trim() + '\\r\\n';\n  });\n};\n\n// returns the session description.\nSDPUtils.getDescription = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(function(line) {\n    return line.indexOf(prefix) === 0;\n  });\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\nSDPUtils.parseCandidate = function(line) {\n  var parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  var candidate = {\n    foundation: parts[0],\n    component: parseInt(parts[1], 10),\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4], // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n\n  for (var i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compability.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag\n        candidate[parts[i]] = parts[i + 1];\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\nSDPUtils.writeCandidate = function(candidate) {\n  var sdp = [];\n  sdp.push(candidate.foundation);\n  sdp.push(candidate.component);\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n\n  var type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substr(14).split(' ');\n};\n\n// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  var parts = line.substr(9).split(' ');\n  var parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generate an a=rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  var channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses an a=extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  var parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1]\n  };\n};\n\n// Generates a=extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n          ? '/' + headerExtension.direction\n          : '') +\n      ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses an ftmp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  var parsed = {};\n  var kv;\n  var parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (var j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  var line = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    var params = [];\n    Object.keys(codec.parameters).forEach(function(param) {\n      if (codec.parameters[param]) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  var parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n};\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  var lines = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(function(fb) {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses an RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  var sp = line.indexOf(' ');\n  var parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\n  };\n  var colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\nSDPUtils.parseSsrcGroup = function(line) {\n  var parts = line.substr(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(function(ssrc) {\n      return parseInt(ssrc, 10);\n    })\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n};\n\nSDPUtils.parseFingerprint = function(line) {\n  var parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1]\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n      'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role.\n  // Note2: 'algorithm' is not case sensitive except in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  var sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(function(fp) {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  // Search in session part, too.\n  lines = lines.concat(SDPUtils.splitLines(sessionpart));\n  var iceParameters = {\n    usernameFragment: lines.filter(function(line) {\n      return line.indexOf('a=ice-ufrag:') === 0;\n    })[0].substr(12),\n    password: lines.filter(function(line) {\n      return line.indexOf('a=ice-pwd:') === 0;\n    })[0].substr(10)\n  };\n  return iceParameters;\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  var description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    var pt = mline[i];\n    var rtpmapline = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      var codec = SDPUtils.parseRtpMap(rtpmapline);\n      var fmtps = SDPUtils.matchPrefix(\n          mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n          mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  var sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(function(codec) {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(function(codec) {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  var maxptime = 0;\n  caps.codecs.forEach(function(codec) {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n  sdp += 'a=rtcp-mux\\r\\n';\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(function(extension) {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  var encodingParameters = [];\n  var description = SDPUtils.parseRtpParameters(mediaSection);\n  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n  .map(function(line) {\n    return SDPUtils.parseSsrcMedia(line);\n  })\n  .filter(function(parts) {\n    return parts.attribute === 'cname';\n  });\n  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  var secondarySsrc;\n\n  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n  .map(function(line) {\n    var parts = line.substr(17).split(' ');\n    return parts.map(function(part) {\n      return parseInt(part, 10);\n    });\n  });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(function(codec) {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      var encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10)\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {ssrc: secondarySsrc};\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(function(params) {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  var rtcpParameters = {};\n\n  // Gets the first SSRC. Note tha with RTX there might be multiple\n  // SSRCs.\n  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n      .map(function(line) {\n        return SDPUtils.parseSsrcMedia(line);\n      })\n      .filter(function(obj) {\n        return obj.attribute === 'cname';\n      })[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrіbute.\n  // Note that Edge does not support unmuxed RTCP.\n  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  var parts;\n  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n  .map(function(line) {\n    return SDPUtils.parseSsrcMedia(line);\n  })\n  .filter(function(msidParts) {\n    return msidParts.attribute === 'msid';\n  });\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boilder plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n  var sessionId;\n  var version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  var user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=' + user + ' ' + sessionId + ' ' + version +\n        ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\nSDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.direction) {\n    sdp += 'a=' + transceiver.direction + '\\r\\n';\n  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    // spec.\n    var msid = 'msid:' + stream.id + ' ' +\n        transceiver.rtpSender.track.id + '\\r\\n';\n    sdp += 'a=' + msid;\n\n    // for Chrome.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  var lines = SDPUtils.splitLines(mediaSection);\n  for (var i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  var parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5]\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function(blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  var lines = SDPUtils.splitLines(blob);\n  for (var i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n  return true;\n};\n\n// Expose public methods.\nif (true) {\n  module.exports = SDPUtils;\n}\n\n\n//# sourceURL=webpack:///./node_modules/sdp/sdp.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/adapter_core.js":
/*!************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_core.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter_factory.js */ \"./node_modules/webrtc-adapter/src/js/adapter_factory.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\nconst adapter = Object(_adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"adapterFactory\"])({window});\n/* harmony default export */ __webpack_exports__[\"default\"] = (adapter);\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/adapter_core.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/adapter_factory.js":
/*!***************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_factory.js ***!
  \***************************************************************/
/*! exports provided: adapterFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adapterFactory\", function() { return adapterFactory; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/* harmony import */ var _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chrome/chrome_shim */ \"./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js\");\n/* harmony import */ var _edge_edge_shim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./edge/edge_shim */ \"./node_modules/webrtc-adapter/src/js/edge/edge_shim.js\");\n/* harmony import */ var _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./firefox/firefox_shim */ \"./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js\");\n/* harmony import */ var _safari_safari_shim__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./safari/safari_shim */ \"./node_modules/webrtc-adapter/src/js/safari/safari_shim.js\");\n/* harmony import */ var _common_shim__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common_shim */ \"./node_modules/webrtc-adapter/src/js/common_shim.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n\n  // Browser shims.\n\n\n\n\n\n\n// Shimming starts here.\nfunction adapterFactory({window} = {}, options = {\n  shimChrome: true,\n  shimFirefox: true,\n  shimEdge: true,\n  shimSafari: true,\n}) {\n  // Utils.\n  const logging = _utils__WEBPACK_IMPORTED_MODULE_0__[\"log\"];\n  const browserDetails = _utils__WEBPACK_IMPORTED_MODULE_0__[\"detectBrowser\"](window);\n\n  const adapter = {\n    browserDetails,\n    commonShim: _common_shim__WEBPACK_IMPORTED_MODULE_5__,\n    extractVersion: _utils__WEBPACK_IMPORTED_MODULE_0__[\"extractVersion\"],\n    disableLog: _utils__WEBPACK_IMPORTED_MODULE_0__[\"disableLog\"],\n    disableWarnings: _utils__WEBPACK_IMPORTED_MODULE_0__[\"disableWarnings\"]\n  };\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ || !_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__[\"shimPeerConnection\"] ||\n          !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__;\n\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__[\"shimGetUserMedia\"](window);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__[\"shimMediaStream\"](window);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__[\"shimPeerConnection\"](window);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__[\"shimOnTrack\"](window);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__[\"shimAddTrackRemoveTrack\"](window);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__[\"shimGetSendersWithDtmf\"](window);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__[\"shimGetStats\"](window);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__[\"shimSenderReceiverGetStats\"](window);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__[\"fixNegotiationNeeded\"](window);\n\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"shimRTCIceCandidate\"](window);\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"shimConnectionState\"](window);\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"shimMaxMessageSize\"](window);\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"shimSendThrowTypeError\"](window);\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"removeAllowExtmapMixed\"](window);\n      break;\n    case 'firefox':\n      if (!_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_3__ || !_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_3__[\"shimPeerConnection\"] ||\n          !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_3__;\n\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_3__[\"shimGetUserMedia\"](window);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_3__[\"shimPeerConnection\"](window);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_3__[\"shimOnTrack\"](window);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_3__[\"shimRemoveStream\"](window);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_3__[\"shimSenderGetStats\"](window);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_3__[\"shimReceiverGetStats\"](window);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_3__[\"shimRTCDataChannel\"](window);\n\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"shimRTCIceCandidate\"](window);\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"shimConnectionState\"](window);\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"shimMaxMessageSize\"](window);\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"shimSendThrowTypeError\"](window);\n      break;\n    case 'edge':\n      if (!_edge_edge_shim__WEBPACK_IMPORTED_MODULE_2__ || !_edge_edge_shim__WEBPACK_IMPORTED_MODULE_2__[\"shimPeerConnection\"] || !options.shimEdge) {\n        logging('MS edge shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming edge.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = _edge_edge_shim__WEBPACK_IMPORTED_MODULE_2__;\n\n      _edge_edge_shim__WEBPACK_IMPORTED_MODULE_2__[\"shimGetUserMedia\"](window);\n      _edge_edge_shim__WEBPACK_IMPORTED_MODULE_2__[\"shimGetDisplayMedia\"](window);\n      _edge_edge_shim__WEBPACK_IMPORTED_MODULE_2__[\"shimPeerConnection\"](window);\n      _edge_edge_shim__WEBPACK_IMPORTED_MODULE_2__[\"shimReplaceTrack\"](window);\n\n      // the edge shim implements the full RTCIceCandidate object.\n\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"shimMaxMessageSize\"](window);\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"shimSendThrowTypeError\"](window);\n      break;\n    case 'safari':\n      if (!_safari_safari_shim__WEBPACK_IMPORTED_MODULE_4__ || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = _safari_safari_shim__WEBPACK_IMPORTED_MODULE_4__;\n\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_4__[\"shimRTCIceServerUrls\"](window);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_4__[\"shimCreateOfferLegacy\"](window);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_4__[\"shimCallbacksAPI\"](window);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_4__[\"shimLocalStreamsAPI\"](window);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_4__[\"shimRemoteStreamsAPI\"](window);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_4__[\"shimTrackEventTransceiver\"](window);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_4__[\"shimGetUserMedia\"](window);\n\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"shimRTCIceCandidate\"](window);\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"shimMaxMessageSize\"](window);\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"shimSendThrowTypeError\"](window);\n      _common_shim__WEBPACK_IMPORTED_MODULE_5__[\"removeAllowExtmapMixed\"](window);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n\n  return adapter;\n}\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/adapter_factory.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js ***!
  \******************************************************************/
/*! exports provided: shimGetUserMedia, shimGetDisplayMedia, shimMediaStream, shimOnTrack, shimGetSendersWithDtmf, shimGetStats, shimSenderReceiverGetStats, shimAddTrackRemoveTrackWithNative, shimAddTrackRemoveTrack, shimPeerConnection, fixNegotiationNeeded */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimMediaStream\", function() { return shimMediaStream; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimOnTrack\", function() { return shimOnTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimGetSendersWithDtmf\", function() { return shimGetSendersWithDtmf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimGetStats\", function() { return shimGetStats; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimSenderReceiverGetStats\", function() { return shimSenderReceiverGetStats; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimAddTrackRemoveTrackWithNative\", function() { return shimAddTrackRemoveTrackWithNative; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimAddTrackRemoveTrack\", function() { return shimAddTrackRemoveTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimPeerConnection\", function() { return shimPeerConnection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fixNegotiationNeeded\", function() { return fixNegotiationNeeded; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getusermedia */ \"./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"shimGetUserMedia\", function() { return _getusermedia__WEBPACK_IMPORTED_MODULE_1__[\"shimGetUserMedia\"]; });\n\n/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getdisplaymedia */ \"./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"shimGetDisplayMedia\", function() { return _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__[\"shimGetDisplayMedia\"]; });\n\n\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\n\n\n\n\nfunction shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\n\nfunction shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n      window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        if (!this._ontrackpoly) {\n          this._ontrackpoly = (e) => {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', te => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === te.track.id);\n              } else {\n                receiver = {track: te.track};\n              }\n\n              const event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(track => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === track.id);\n              } else {\n                receiver = {track};\n              }\n              const event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n          };\n          this.addEventListener('addstream', this._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n      };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"wrapPeerConnectionEvent\"](window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver',\n          {value: {receiver: e.receiver}});\n      }\n      return e;\n    });\n  }\n}\n\nfunction shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection &&\n      !('getSenders' in window.RTCPeerConnection.prototype) &&\n      'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function(pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack =\n        function addTrack(track, stream) {\n          let sender = origAddTrack.apply(this, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(this, track);\n            this._senders.push(sender);\n          }\n          return sender;\n        };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack =\n        function removeTrack(sender) {\n          origRemoveTrack.apply(this, arguments);\n          const idx = this._senders.indexOf(sender);\n          if (idx !== -1) {\n            this._senders.splice(idx, 1);\n          }\n        };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        this._senders = this._senders || [];\n        origRemoveStream.apply(this, [stream]);\n\n        stream.getTracks().forEach(track => {\n          const sender = this._senders.find(s => s.track === track);\n          if (sender) { // remove sender\n            this._senders.splice(this._senders.indexOf(sender), 1);\n          }\n        });\n      };\n  } else if (typeof window === 'object' && window.RTCPeerConnection &&\n             'getSenders' in window.RTCPeerConnection.prototype &&\n             'createDTMFSender' in window.RTCPeerConnection.prototype &&\n             window.RTCRtpSender &&\n             !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\n\nfunction shimGetStats(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n\n    // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    }\n\n    // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n    if (origGetStats.length === 0 && (arguments.length === 0 ||\n        typeof selector !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n\n    const fixChromeStats_ = function(response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach(report => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(name => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n\n      return standardReport;\n    };\n\n    // shim getStats with maplike support\n    const makeMapStats = function(stats) {\n      return new Map(Object.keys(stats).map(key => [key, stats[key]]));\n    };\n\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function(response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n\n      return origGetStats.apply(this, [successCallbackWrapper_,\n        selector]);\n    }\n\n    // promise-support\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [\n        function(response) {\n          resolve(makeMapStats(fixChromeStats_(response)));\n        }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\n\nfunction shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"filterStats\"](result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers =\n        function getReceivers() {\n          const receivers = origGetReceivers.apply(this, []);\n          receivers.forEach(receiver => receiver._pc = this);\n          return receivers;\n        };\n    }\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"wrapPeerConnectionEvent\"](window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result =>\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"filterStats\"](result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype &&\n      'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 &&\n        arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || (sender && receiver)) {\n        return Promise.reject(new DOMException(\n          'There are more than one sender or receiver for the track.',\n          'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException(\n        'There is no sender or receiver for the track.',\n        'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\n\nfunction shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams)\n        .map(streamId => this._shimmedLocalStreams[streamId][0]);\n    };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      const sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders()\n      .filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            this._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (this._shimmedLocalStreams[streamId].length === 1) {\n            delete this._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n}\n\nfunction shimAddTrackRemoveTrack(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const browserDetails = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"detectBrowser\"](window);\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack &&\n      browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype\n      .getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      const nativeStreams = origGetLocalStreams.apply(this);\n      this._reverseStreams = this._reverseStreams || {};\n      return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n\n      origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);\n      delete this._reverseStreams[(this._streams[stream.id] ?\n          this._streams[stream.id].id : stream.id)];\n      delete this._streams[stream.id];\n    };\n\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      const streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(t => t === track)) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n      const oldStream = this._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(() => {\n          this.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        const newStream = new window.MediaStream([track]);\n        this._streams[stream.id] = newStream;\n        this._reverseStreams[newStream.id] = stream;\n        this.addStream(newStream);\n      }\n      return this.getSenders().find(s => s.track === track);\n    };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n          externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n          internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function(method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {[method]() {\n      const args = arguments;\n      const isLegacyCall = arguments.length &&\n          typeof arguments[0] === 'function';\n      if (isLegacyCall) {\n        return nativeMethod.apply(this, [\n          (description) => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          },\n          (err) => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]\n        ]);\n      }\n      return nativeMethod.apply(this, arguments)\n      .then(description => replaceInternalStreamId(this, description));\n    }};\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n\n  const origSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription =\n    function setLocalDescription() {\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(this, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(this, arguments[0]);\n      return origSetLocalDescription.apply(this, arguments);\n    };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(\n      window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype,\n      'localDescription', {\n        get() {\n          const description = origLocalDescription.get.apply(this);\n          if (description.type === '') {\n            return description;\n          }\n          return replaceInternalStreamId(this, description);\n        }\n      });\n\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      const isLocal = sender._pc === this;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n            'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      this._streams = this._streams || {};\n      let stream;\n      Object.keys(this._streams).forEach(streamid => {\n        const hasTrack = this._streams[streamid].getTracks()\n          .find(track => sender.track === track);\n        if (hasTrack) {\n          stream = this._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          this.removeStream(this._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        this.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n}\n\nfunction shimPeerConnection(window) {\n  const browserDetails = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"detectBrowser\"](window);\n\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          const nativeMethod = window.RTCPeerConnection.prototype[method];\n          const methodObj = {[method]() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          }};\n          window.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n  }\n\n  // support for addIceCandidate(null or undefined)\n  const nativeAddIceCandidate =\n      window.RTCPeerConnection.prototype.addIceCandidate;\n  window.RTCPeerConnection.prototype.addIceCandidate =\n    function addIceCandidate() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n      // in older versions. Native support planned for Chrome M77.\n      if (browserDetails.version < 78 &&\n        arguments[0] && arguments[0].candidate === '') {\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n}\n\nfunction fixNegotiationNeeded(window) {\n  _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"wrapPeerConnectionEvent\"](window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (pc.signalingState !== 'stable') {\n      return;\n    }\n    return e;\n  });\n}\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js":
/*!**********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js ***!
  \**********************************************************************/
/*! exports provided: shimGetDisplayMedia */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimGetDisplayMedia\", function() { return shimGetDisplayMedia; });\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\nfunction shimGetDisplayMedia(window, getSourceId) {\n  if (window.navigator.mediaDevices &&\n    'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!(window.navigator.mediaDevices)) {\n    return;\n  }\n  // getSourceId is a function that returns a promise resolving with\n  // the sourceId of the screen/window/tab to be shared.\n  if (typeof getSourceId !== 'function') {\n    console.error('shimGetDisplayMedia: getSourceId argument is not ' +\n        'a function');\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia =\n    function getDisplayMedia(constraints) {\n      return getSourceId(constraints)\n        .then(sourceId => {\n          const widthSpecified = constraints.video && constraints.video.width;\n          const heightSpecified = constraints.video &&\n            constraints.video.height;\n          const frameRateSpecified = constraints.video &&\n            constraints.video.frameRate;\n          constraints.video = {\n            mandatory: {\n              chromeMediaSource: 'desktop',\n              chromeMediaSourceId: sourceId,\n              maxFrameRate: frameRateSpecified || 3\n            }\n          };\n          if (widthSpecified) {\n            constraints.video.mandatory.maxWidth = widthSpecified;\n          }\n          if (heightSpecified) {\n            constraints.video.mandatory.maxHeight = heightSpecified;\n          }\n          return window.navigator.mediaDevices.getUserMedia(constraints);\n        });\n    };\n}\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js ***!
  \*******************************************************************/
/*! exports provided: shimGetUserMedia */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimGetUserMedia\", function() { return shimGetUserMedia; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nconst logging = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"log\"];\n\nfunction shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n\n  if (!navigator.mediaDevices) {\n    return;\n  }\n\n  const browserDetails = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"detectBrowser\"](window);\n\n  const constraintsToChrome_ = function(c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    const cc = {};\n    Object.keys(c).forEach(key => {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      const r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      const oldname_ = function(prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return (name === 'deviceId') ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        let oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(mix => {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n\n  const shimConstraints_ = function(constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      const remap = function(obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      let face = constraints.video.facingMode;\n      face = face && ((typeof face === 'object') ? face : {ideal: face});\n      const getSupportedFacingModeLies = browserDetails.version < 66;\n\n      if ((face && (face.exact === 'user' || face.exact === 'environment' ||\n                    face.ideal === 'user' || face.ideal === 'environment')) &&\n          !(navigator.mediaDevices.getSupportedConstraints &&\n            navigator.mediaDevices.getSupportedConstraints().facingMode &&\n            !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        let matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices()\n          .then(devices => {\n            devices = devices.filter(d => d.kind === 'videoinput');\n            let dev = devices.find(d => matches.some(match =>\n              d.label.toLowerCase().includes(match)));\n            if (!dev && devices.length && matches.includes('back')) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :\n                                                        {ideal: dev.deviceId};\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n\n  const shimError_ = function(e) {\n    if (browserDetails.version >= 64) {\n      return e;\n    }\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n      toString() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  const getUserMedia_ = function(constraints, onSuccess, onError) {\n    shimConstraints_(constraints, c => {\n      navigator.webkitGetUserMedia(c, onSuccess, e => {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n  navigator.getUserMedia = getUserMedia_.bind(navigator);\n\n  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n  // function which returns a Promise, it does not accept spec-style\n  // constraints.\n  if (navigator.mediaDevices.getUserMedia) {\n    const origGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(cs) {\n      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {\n        if (c.audio && !stream.getAudioTracks().length ||\n            c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(track => {\n            track.stop();\n          });\n          throw new DOMException('', 'NotFoundError');\n        }\n        return stream;\n      }, e => Promise.reject(shimError_(e))));\n    };\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/common_shim.js":
/*!***********************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/common_shim.js ***!
  \***********************************************************/
/*! exports provided: shimRTCIceCandidate, shimMaxMessageSize, shimSendThrowTypeError, shimConnectionState, removeAllowExtmapMixed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimRTCIceCandidate\", function() { return shimRTCIceCandidate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimMaxMessageSize\", function() { return shimMaxMessageSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimSendThrowTypeError\", function() { return shimSendThrowTypeError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimConnectionState\", function() { return shimConnectionState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeAllowExtmapMixed\", function() { return removeAllowExtmapMixed; });\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sdp */ \"./node_modules/sdp/sdp.js\");\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\nfunction shimRTCIceCandidate(window) {\n  // foundation is arbitrarily chosen as an indicator for full support for\n  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n  if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in\n      window.RTCIceCandidate.prototype)) {\n    return;\n  }\n\n  const NativeRTCIceCandidate = window.RTCIceCandidate;\n  window.RTCIceCandidate = function RTCIceCandidate(args) {\n    // Remove the a= which shouldn't be part of the candidate string.\n    if (typeof args === 'object' && args.candidate &&\n        args.candidate.indexOf('a=') === 0) {\n      args = JSON.parse(JSON.stringify(args));\n      args.candidate = args.candidate.substr(2);\n    }\n\n    if (args.candidate && args.candidate.length) {\n      // Augment the native candidate with the parsed fields.\n      const nativeCandidate = new NativeRTCIceCandidate(args);\n      const parsedCandidate = sdp__WEBPACK_IMPORTED_MODULE_0___default.a.parseCandidate(args.candidate);\n      const augmentedCandidate = Object.assign(nativeCandidate,\n          parsedCandidate);\n\n      // Add a serializer that does not serialize the extra attributes.\n      augmentedCandidate.toJSON = function toJSON() {\n        return {\n          candidate: augmentedCandidate.candidate,\n          sdpMid: augmentedCandidate.sdpMid,\n          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,\n          usernameFragment: augmentedCandidate.usernameFragment,\n        };\n      };\n      return augmentedCandidate;\n    }\n    return new NativeRTCIceCandidate(args);\n  };\n  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n\n  // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n  _utils__WEBPACK_IMPORTED_MODULE_1__[\"wrapPeerConnectionEvent\"](window, 'icecandidate', e => {\n    if (e.candidate) {\n      Object.defineProperty(e, 'candidate', {\n        value: new window.RTCIceCandidate(e.candidate),\n        writable: 'false'\n      });\n    }\n    return e;\n  });\n}\n\nfunction shimMaxMessageSize(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const browserDetails = _utils__WEBPACK_IMPORTED_MODULE_1__[\"detectBrowser\"](window);\n\n  if (!('sctp' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n      get() {\n        return typeof this._sctp === 'undefined' ? null : this._sctp;\n      }\n    });\n  }\n\n  const sctpInDescription = function(description) {\n    if (!description || !description.sdp) {\n      return false;\n    }\n    const sections = sdp__WEBPACK_IMPORTED_MODULE_0___default.a.splitSections(description.sdp);\n    sections.shift();\n    return sections.some(mediaSection => {\n      const mLine = sdp__WEBPACK_IMPORTED_MODULE_0___default.a.parseMLine(mediaSection);\n      return mLine && mLine.kind === 'application'\n          && mLine.protocol.indexOf('SCTP') !== -1;\n    });\n  };\n\n  const getRemoteFirefoxVersion = function(description) {\n    // TODO: Is there a better solution for detecting Firefox?\n    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n    if (match === null || match.length < 2) {\n      return -1;\n    }\n    const version = parseInt(match[1], 10);\n    // Test for NaN (yes, this is ugly)\n    return version !== version ? -1 : version;\n  };\n\n  const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n    // Every implementation we know can send at least 64 KiB.\n    // Note: Although Chrome is technically able to send up to 256 KiB, the\n    //       data does not reach the other peer reliably.\n    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n    let canSendMaxMessageSize = 65536;\n    if (browserDetails.browser === 'firefox') {\n      if (browserDetails.version < 57) {\n        if (remoteIsFirefox === -1) {\n          // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n          // fragmentation.\n          canSendMaxMessageSize = 16384;\n        } else {\n          // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n          // messages. Thus, supporting ~2 GiB when sending.\n          canSendMaxMessageSize = 2147483637;\n        }\n      } else if (browserDetails.version < 60) {\n        // Currently, all FF >= 57 will reset the remote maximum message size\n        // to the default value when a data channel is created at a later\n        // stage. :(\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n        canSendMaxMessageSize =\n          browserDetails.version === 57 ? 65535 : 65536;\n      } else {\n        // FF >= 60 supports sending ~2 GiB\n        canSendMaxMessageSize = 2147483637;\n      }\n    }\n    return canSendMaxMessageSize;\n  };\n\n  const getMaxMessageSize = function(description, remoteIsFirefox) {\n    // Note: 65536 bytes is the default value from the SDP spec. Also,\n    //       every implementation we know supports receiving 65536 bytes.\n    let maxMessageSize = 65536;\n\n    // FF 57 has a slightly incorrect default remote max message size, so\n    // we need to adjust it here to avoid a failure when sending.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n    if (browserDetails.browser === 'firefox'\n         && browserDetails.version === 57) {\n      maxMessageSize = 65535;\n    }\n\n    const match = sdp__WEBPACK_IMPORTED_MODULE_0___default.a.matchPrefix(description.sdp,\n      'a=max-message-size:');\n    if (match.length > 0) {\n      maxMessageSize = parseInt(match[0].substr(19), 10);\n    } else if (browserDetails.browser === 'firefox' &&\n                remoteIsFirefox !== -1) {\n      // If the maximum message size is not present in the remote SDP and\n      // both local and remote are Firefox, the remote peer can receive\n      // ~2 GiB.\n      maxMessageSize = 2147483637;\n    }\n    return maxMessageSize;\n  };\n\n  const origSetRemoteDescription =\n      window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription =\n    function setRemoteDescription() {\n      this._sctp = null;\n      // Chrome decided to not expose .sctp in plan-b mode.\n      // As usual, adapter.js has to do an 'ugly worakaround'\n      // to cover up the mess.\n      if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {\n        const {sdpSemantics} = this.getConfiguration();\n        if (sdpSemantics === 'plan-b') {\n          Object.defineProperty(this, 'sctp', {\n            get() {\n              return typeof this._sctp === 'undefined' ? null : this._sctp;\n            },\n            enumerable: true,\n            configurable: true,\n          });\n        }\n      }\n\n      if (sctpInDescription(arguments[0])) {\n        // Check if the remote is FF.\n        const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n\n        // Get the maximum message size the local peer is capable of sending\n        const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n\n        // Get the maximum message size of the remote peer.\n        const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n\n        // Determine final maximum message size\n        let maxMessageSize;\n        if (canSendMMS === 0 && remoteMMS === 0) {\n          maxMessageSize = Number.POSITIVE_INFINITY;\n        } else if (canSendMMS === 0 || remoteMMS === 0) {\n          maxMessageSize = Math.max(canSendMMS, remoteMMS);\n        } else {\n          maxMessageSize = Math.min(canSendMMS, remoteMMS);\n        }\n\n        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n        // attribute.\n        const sctp = {};\n        Object.defineProperty(sctp, 'maxMessageSize', {\n          get() {\n            return maxMessageSize;\n          }\n        });\n        this._sctp = sctp;\n      }\n\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n}\n\nfunction shimSendThrowTypeError(window) {\n  if (!(window.RTCPeerConnection &&\n      'createDataChannel' in window.RTCPeerConnection.prototype)) {\n    return;\n  }\n\n  // Note: Although Firefox >= 57 has a native implementation, the maximum\n  //       message size can be reset for all data channels at a later stage.\n  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n  function wrapDcSend(dc, pc) {\n    const origDataChannelSend = dc.send;\n    dc.send = function send() {\n      const data = arguments[0];\n      const length = data.length || data.size || data.byteLength;\n      if (dc.readyState === 'open' &&\n          pc.sctp && length > pc.sctp.maxMessageSize) {\n        throw new TypeError('Message too large (can send a maximum of ' +\n          pc.sctp.maxMessageSize + ' bytes)');\n      }\n      return origDataChannelSend.apply(dc, arguments);\n    };\n  }\n  const origCreateDataChannel =\n    window.RTCPeerConnection.prototype.createDataChannel;\n  window.RTCPeerConnection.prototype.createDataChannel =\n    function createDataChannel() {\n      const dataChannel = origCreateDataChannel.apply(this, arguments);\n      wrapDcSend(dataChannel, this);\n      return dataChannel;\n    };\n  _utils__WEBPACK_IMPORTED_MODULE_1__[\"wrapPeerConnectionEvent\"](window, 'datachannel', e => {\n    wrapDcSend(e.channel, e.target);\n    return e;\n  });\n}\n\n\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */\nfunction shimConnectionState(window) {\n  if (!window.RTCPeerConnection ||\n      'connectionState' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  Object.defineProperty(proto, 'connectionState', {\n    get() {\n      return {\n        completed: 'connected',\n        checking: 'connecting'\n      }[this.iceConnectionState] || this.iceConnectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(proto, 'onconnectionstatechange', {\n    get() {\n      return this._onconnectionstatechange || null;\n    },\n    set(cb) {\n      if (this._onconnectionstatechange) {\n        this.removeEventListener('connectionstatechange',\n            this._onconnectionstatechange);\n        delete this._onconnectionstatechange;\n      }\n      if (cb) {\n        this.addEventListener('connectionstatechange',\n            this._onconnectionstatechange = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ['setLocalDescription', 'setRemoteDescription'].forEach((method) => {\n    const origMethod = proto[method];\n    proto[method] = function() {\n      if (!this._connectionstatechangepoly) {\n        this._connectionstatechangepoly = e => {\n          const pc = e.target;\n          if (pc._lastConnectionState !== pc.connectionState) {\n            pc._lastConnectionState = pc.connectionState;\n            const newEvent = new Event('connectionstatechange', e);\n            pc.dispatchEvent(newEvent);\n          }\n          return e;\n        };\n        this.addEventListener('iceconnectionstatechange',\n          this._connectionstatechangepoly);\n      }\n      return origMethod.apply(this, arguments);\n    };\n  });\n}\n\nfunction removeAllowExtmapMixed(window) {\n  /* remove a=extmap-allow-mixed for Chrome < M71 */\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const browserDetails = _utils__WEBPACK_IMPORTED_MODULE_1__[\"detectBrowser\"](window);\n  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\n    return;\n  }\n  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription =\n  function setRemoteDescription(desc) {\n    if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\n      desc.sdp = desc.sdp.split('\\n').filter((line) => {\n        return line.trim() !== 'a=extmap-allow-mixed';\n      }).join('\\n');\n    }\n    return nativeSRD.apply(this, arguments);\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/common_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/edge/edge_shim.js":
/*!**************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/edge/edge_shim.js ***!
  \**************************************************************/
/*! exports provided: shimGetUserMedia, shimGetDisplayMedia, shimPeerConnection, shimReplaceTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimPeerConnection\", function() { return shimPeerConnection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimReplaceTrack\", function() { return shimReplaceTrack; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/* harmony import */ var _filtericeservers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filtericeservers */ \"./node_modules/webrtc-adapter/src/js/edge/filtericeservers.js\");\n/* harmony import */ var rtcpeerconnection_shim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rtcpeerconnection-shim */ \"./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js\");\n/* harmony import */ var rtcpeerconnection_shim__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rtcpeerconnection_shim__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getusermedia */ \"./node_modules/webrtc-adapter/src/js/edge/getusermedia.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"shimGetUserMedia\", function() { return _getusermedia__WEBPACK_IMPORTED_MODULE_3__[\"shimGetUserMedia\"]; });\n\n/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getdisplaymedia */ \"./node_modules/webrtc-adapter/src/js/edge/getdisplaymedia.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"shimGetDisplayMedia\", function() { return _getdisplaymedia__WEBPACK_IMPORTED_MODULE_4__[\"shimGetDisplayMedia\"]; });\n\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\n\n\n\n\nfunction shimPeerConnection(window) {\n  const browserDetails = _utils__WEBPACK_IMPORTED_MODULE_0__[\"detectBrowser\"](window);\n\n  if (window.RTCIceGatherer) {\n    if (!window.RTCIceCandidate) {\n      window.RTCIceCandidate = function RTCIceCandidate(args) {\n        return args;\n      };\n    }\n    if (!window.RTCSessionDescription) {\n      window.RTCSessionDescription = function RTCSessionDescription(args) {\n        return args;\n      };\n    }\n    // this adds an additional event listener to MediaStrackTrack that signals\n    // when a tracks enabled property was changed. Workaround for a bug in\n    // addStream, see below. No longer required in 15025+\n    if (browserDetails.version < 15025) {\n      const origMSTEnabled = Object.getOwnPropertyDescriptor(\n          window.MediaStreamTrack.prototype, 'enabled');\n      Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {\n        set(value) {\n          origMSTEnabled.set.call(this, value);\n          const ev = new Event('enabled');\n          ev.enabled = value;\n          this.dispatchEvent(ev);\n        }\n      });\n    }\n  }\n\n  // ORTC defines the DTMF sender a bit different.\n  // https://github.com/w3c/ortc/issues/714\n  if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = new window.RTCDtmfSender(this);\n          } else if (this.track.kind === 'video') {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n  // Edge currently only implements the RTCDtmfSender, not the\n  // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*\n  if (window.RTCDtmfSender && !window.RTCDTMFSender) {\n    window.RTCDTMFSender = window.RTCDtmfSender;\n  }\n\n  const RTCPeerConnectionShim = rtcpeerconnection_shim__WEBPACK_IMPORTED_MODULE_2___default()(window,\n      browserDetails.version);\n  window.RTCPeerConnection = function RTCPeerConnection(config) {\n    if (config && config.iceServers) {\n      config.iceServers = Object(_filtericeservers__WEBPACK_IMPORTED_MODULE_1__[\"filterIceServers\"])(config.iceServers,\n        browserDetails.version);\n      _utils__WEBPACK_IMPORTED_MODULE_0__[\"log\"]('ICE servers after filtering:', config.iceServers);\n    }\n    return new RTCPeerConnectionShim(config);\n  };\n  window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;\n}\n\nfunction shimReplaceTrack(window) {\n  // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614\n  if (window.RTCRtpSender &&\n      !('replaceTrack' in window.RTCRtpSender.prototype)) {\n    window.RTCRtpSender.prototype.replaceTrack =\n        window.RTCRtpSender.prototype.setTrack;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/edge/edge_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/edge/filtericeservers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/edge/filtericeservers.js ***!
  \*********************************************************************/
/*! exports provided: filterIceServers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filterIceServers\", function() { return filterIceServers; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nfunction filterIceServers(iceServers, edgeVersion) {\n  let hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(server => {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        _utils__WEBPACK_IMPORTED_MODULE_0__[\"deprecated\"]('RTCIceServer.url', 'RTCIceServer.urls');\n      }\n      const isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(url => {\n        // filter STUN unconditionally.\n        if (url.indexOf('stun:') === 0) {\n          return false;\n        }\n\n        const validTurn = url.startsWith('turn') &&\n            !url.startsWith('turn:[') &&\n            url.includes('transport=udp');\n        if (validTurn && !hasTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return validTurn && !hasTurn;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n}\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/edge/filtericeservers.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/edge/getdisplaymedia.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/edge/getdisplaymedia.js ***!
  \********************************************************************/
/*! exports provided: shimGetDisplayMedia */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimGetDisplayMedia\", function() { return shimGetDisplayMedia; });\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nfunction shimGetDisplayMedia(window) {\n  if (!('getDisplayMedia' in window.navigator)) {\n    return;\n  }\n  if (!(window.navigator.mediaDevices)) {\n    return;\n  }\n  if (window.navigator.mediaDevices &&\n    'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia =\n    window.navigator.getDisplayMedia.bind(window.navigator);\n}\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/edge/getdisplaymedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/edge/getusermedia.js":
/*!*****************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/edge/getusermedia.js ***!
  \*****************************************************************/
/*! exports provided: shimGetUserMedia */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimGetUserMedia\", function() { return shimGetUserMedia; });\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nfunction shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n\n  const shimError_ = function(e) {\n    return {\n      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint,\n      toString() {\n        return this.name;\n      }\n    };\n  };\n\n  // getUserMedia error shim.\n  const origGetUserMedia = navigator.mediaDevices.getUserMedia.\n      bind(navigator.mediaDevices);\n  navigator.mediaDevices.getUserMedia = function(c) {\n    return origGetUserMedia(c).catch(e => Promise.reject(shimError_(e)));\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/edge/getusermedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js ***!
  \********************************************************************/
/*! exports provided: shimGetUserMedia, shimGetDisplayMedia, shimOnTrack, shimPeerConnection, shimSenderGetStats, shimReceiverGetStats, shimRemoveStream, shimRTCDataChannel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimOnTrack\", function() { return shimOnTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimPeerConnection\", function() { return shimPeerConnection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimSenderGetStats\", function() { return shimSenderGetStats; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimReceiverGetStats\", function() { return shimReceiverGetStats; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimRemoveStream\", function() { return shimRemoveStream; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimRTCDataChannel\", function() { return shimRTCDataChannel; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getusermedia */ \"./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"shimGetUserMedia\", function() { return _getusermedia__WEBPACK_IMPORTED_MODULE_1__[\"shimGetUserMedia\"]; });\n\n/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getdisplaymedia */ \"./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"shimGetDisplayMedia\", function() { return _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__[\"shimGetDisplayMedia\"]; });\n\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\n\nfunction shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCTrackEvent &&\n      ('receiver' in window.RTCTrackEvent.prototype) &&\n      !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {receiver: this.receiver};\n      }\n    });\n  }\n}\n\nfunction shimPeerConnection(window) {\n  const browserDetails = _utils__WEBPACK_IMPORTED_MODULE_0__[\"detectBrowser\"](window);\n\n  if (typeof window !== 'object' ||\n      !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {\n    return; // probably media.peerconnection.enabled=false in about:config\n  }\n  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.mozRTCPeerConnection;\n  }\n\n  if (browserDetails.version < 53) {\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          const nativeMethod = window.RTCPeerConnection.prototype[method];\n          const methodObj = {[method]() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          }};\n          window.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n  }\n\n  // support for addIceCandidate(null or undefined)\n  // as well as ignoring {sdpMid, candidate: \"\"}\n  if (browserDetails.version < 68) {\n    const nativeAddIceCandidate =\n        window.RTCPeerConnection.prototype.addIceCandidate;\n    window.RTCPeerConnection.prototype.addIceCandidate =\n    function addIceCandidate() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n      // in older versions.\n      if (arguments[0] && arguments[0].candidate === '') {\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n  }\n\n  const modernStatsTypes = {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  };\n\n  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n    return nativeGetStats.apply(this, [selector || null])\n      .then(stats => {\n        if (browserDetails.version < 53 && !onSucc) {\n          // Shim only promise getStats with spec-hyphens in type names\n          // Leave callback version alone; misc old uses of forEach before Map\n          try {\n            stats.forEach(stat => {\n              stat.type = modernStatsTypes[stat.type] || stat.type;\n            });\n          } catch (e) {\n            if (e.name !== 'TypeError') {\n              throw e;\n            }\n            // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n            stats.forEach((stat, i) => {\n              stats.set(i, Object.assign({}, stat, {\n                type: modernStatsTypes[stat.type] || stat.type\n              }));\n            });\n          }\n        }\n        return stats;\n      })\n      .then(onSucc, onErr);\n  };\n}\n\nfunction shimSenderGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\n    return;\n  }\n  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n  if (origGetSenders) {\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n  }\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  if (origAddTrack) {\n    window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n      const sender = origAddTrack.apply(this, arguments);\n      sender._pc = this;\n      return sender;\n    };\n  }\n  window.RTCRtpSender.prototype.getStats = function getStats() {\n    return this.track ? this._pc.getStats(this.track) :\n        Promise.resolve(new Map());\n  };\n}\n\nfunction shimReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\n    return;\n  }\n  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n  if (origGetReceivers) {\n    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n      const receivers = origGetReceivers.apply(this, []);\n      receivers.forEach(receiver => receiver._pc = this);\n      return receivers;\n    };\n  }\n  _utils__WEBPACK_IMPORTED_MODULE_0__[\"wrapPeerConnectionEvent\"](window, 'track', e => {\n    e.receiver._pc = e.srcElement;\n    return e;\n  });\n  window.RTCRtpReceiver.prototype.getStats = function getStats() {\n    return this._pc.getStats(this.track);\n  };\n}\n\nfunction shimRemoveStream(window) {\n  if (!window.RTCPeerConnection ||\n      'removeStream' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      _utils__WEBPACK_IMPORTED_MODULE_0__[\"deprecated\"]('removeStream', 'removeTrack');\n      this.getSenders().forEach(sender => {\n        if (sender.track && stream.getTracks().includes(sender.track)) {\n          this.removeTrack(sender);\n        }\n      });\n    };\n}\n\nfunction shimRTCDataChannel(window) {\n  // rename DataChannel to RTCDataChannel (native fix in FF60):\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n  if (window.DataChannel && !window.RTCDataChannel) {\n    window.RTCDataChannel = window.DataChannel;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js":
/*!***********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js ***!
  \***********************************************************************/
/*! exports provided: shimGetDisplayMedia */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimGetDisplayMedia\", function() { return shimGetDisplayMedia; });\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nfunction shimGetDisplayMedia(window, preferredMediaSource) {\n  if (window.navigator.mediaDevices &&\n    'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!(window.navigator.mediaDevices)) {\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia =\n    function getDisplayMedia(constraints) {\n      if (!(constraints && constraints.video)) {\n        const err = new DOMException('getDisplayMedia without video ' +\n            'constraints is undefined');\n        err.name = 'NotFoundError';\n        // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n        err.code = 8;\n        return Promise.reject(err);\n      }\n      if (constraints.video === true) {\n        constraints.video = {mediaSource: preferredMediaSource};\n      } else {\n        constraints.video.mediaSource = preferredMediaSource;\n      }\n      return window.navigator.mediaDevices.getUserMedia(constraints);\n    };\n}\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js ***!
  \********************************************************************/
/*! exports provided: shimGetUserMedia */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimGetUserMedia\", function() { return shimGetUserMedia; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\nfunction shimGetUserMedia(window) {\n  const browserDetails = _utils__WEBPACK_IMPORTED_MODULE_0__[\"detectBrowser\"](window);\n  const navigator = window && window.navigator;\n  const MediaStreamTrack = window && window.MediaStreamTrack;\n\n  navigator.getUserMedia = function(constraints, onSuccess, onError) {\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    _utils__WEBPACK_IMPORTED_MODULE_0__[\"deprecated\"]('navigator.getUserMedia',\n        'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n\n  if (!(browserDetails.version > 55 &&\n      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    const remap = function(obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n\n    const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function() {\n        const obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      const nativeApplyConstraints =\n        MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function(c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/safari/safari_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/safari/safari_shim.js ***!
  \******************************************************************/
/*! exports provided: shimLocalStreamsAPI, shimRemoteStreamsAPI, shimCallbacksAPI, shimGetUserMedia, shimConstraints, shimRTCIceServerUrls, shimTrackEventTransceiver, shimCreateOfferLegacy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimLocalStreamsAPI\", function() { return shimLocalStreamsAPI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimRemoteStreamsAPI\", function() { return shimRemoteStreamsAPI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimCallbacksAPI\", function() { return shimCallbacksAPI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimGetUserMedia\", function() { return shimGetUserMedia; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimConstraints\", function() { return shimConstraints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimRTCIceServerUrls\", function() { return shimRTCIceServerUrls; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimTrackEventTransceiver\", function() { return shimTrackEventTransceiver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shimCreateOfferLegacy\", function() { return shimCreateOfferLegacy; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n\n\nfunction shimLocalStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getLocalStreams =\n      function getLocalStreams() {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        return this._localStreams;\n      };\n  }\n  if (!('addStream' in window.RTCPeerConnection.prototype)) {\n    const _addTrack = window.RTCPeerConnection.prototype.addTrack;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      if (!this._localStreams.includes(stream)) {\n        this._localStreams.push(stream);\n      }\n      // Try to emulate Chrome's behaviour of adding in audio-video order.\n      // Safari orders by track id.\n      stream.getAudioTracks().forEach(track => _addTrack.call(this, track,\n        stream));\n      stream.getVideoTracks().forEach(track => _addTrack.call(this, track,\n        stream));\n    };\n\n    window.RTCPeerConnection.prototype.addTrack =\n      function addTrack(track) {\n        const stream = arguments[1];\n        if (stream) {\n          if (!this._localStreams) {\n            this._localStreams = [stream];\n          } else if (!this._localStreams.includes(stream)) {\n            this._localStreams.push(stream);\n          }\n        }\n        return _addTrack.apply(this, arguments);\n      };\n  }\n  if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        const index = this._localStreams.indexOf(stream);\n        if (index === -1) {\n          return;\n        }\n        this._localStreams.splice(index, 1);\n        const tracks = stream.getTracks();\n        this.getSenders().forEach(sender => {\n          if (tracks.includes(sender.track)) {\n            this.removeTrack(sender);\n          }\n        });\n      };\n  }\n}\n\nfunction shimRemoteStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getRemoteStreams =\n      function getRemoteStreams() {\n        return this._remoteStreams ? this._remoteStreams : [];\n      };\n  }\n  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n      get() {\n        return this._onaddstream;\n      },\n      set(f) {\n        if (this._onaddstream) {\n          this.removeEventListener('addstream', this._onaddstream);\n          this.removeEventListener('track', this._onaddstreampoly);\n        }\n        this.addEventListener('addstream', this._onaddstream = f);\n        this.addEventListener('track', this._onaddstreampoly = (e) => {\n          e.streams.forEach(stream => {\n            if (!this._remoteStreams) {\n              this._remoteStreams = [];\n            }\n            if (this._remoteStreams.includes(stream)) {\n              return;\n            }\n            this._remoteStreams.push(stream);\n            const event = new Event('addstream');\n            event.stream = stream;\n            this.dispatchEvent(event);\n          });\n        });\n      }\n    });\n    const origSetRemoteDescription =\n      window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        const pc = this;\n        if (!this._onaddstreampoly) {\n          this.addEventListener('track', this._onaddstreampoly = function(e) {\n            e.streams.forEach(stream => {\n              if (!pc._remoteStreams) {\n                pc._remoteStreams = [];\n              }\n              if (pc._remoteStreams.indexOf(stream) >= 0) {\n                return;\n              }\n              pc._remoteStreams.push(stream);\n              const event = new Event('addstream');\n              event.stream = stream;\n              pc.dispatchEvent(event);\n            });\n          });\n        }\n        return origSetRemoteDescription.apply(pc, arguments);\n      };\n  }\n}\n\nfunction shimCallbacksAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  const prototype = window.RTCPeerConnection.prototype;\n  const origCreateOffer = prototype.createOffer;\n  const origCreateAnswer = prototype.createAnswer;\n  const setLocalDescription = prototype.setLocalDescription;\n  const setRemoteDescription = prototype.setRemoteDescription;\n  const addIceCandidate = prototype.addIceCandidate;\n\n  prototype.createOffer =\n    function createOffer(successCallback, failureCallback) {\n      const options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      const promise = origCreateOffer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n  prototype.createAnswer =\n    function createAnswer(successCallback, failureCallback) {\n      const options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      const promise = origCreateAnswer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n  let withCallback = function(description, successCallback, failureCallback) {\n    const promise = setLocalDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setLocalDescription = withCallback;\n\n  withCallback = function(description, successCallback, failureCallback) {\n    const promise = setRemoteDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setRemoteDescription = withCallback;\n\n  withCallback = function(candidate, successCallback, failureCallback) {\n    const promise = addIceCandidate.apply(this, [candidate]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.addIceCandidate = withCallback;\n}\n\nfunction shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    // shim not needed in Safari 12.1\n    const mediaDevices = navigator.mediaDevices;\n    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n    navigator.mediaDevices.getUserMedia = (constraints) => {\n      return _getUserMedia(shimConstraints(constraints));\n    };\n  }\n\n  if (!navigator.getUserMedia && navigator.mediaDevices &&\n    navigator.mediaDevices.getUserMedia) {\n    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {\n      navigator.mediaDevices.getUserMedia(constraints)\n      .then(cb, errcb);\n    }.bind(navigator);\n  }\n}\n\nfunction shimConstraints(constraints) {\n  if (constraints && constraints.video !== undefined) {\n    return Object.assign({},\n      constraints,\n      {video: _utils__WEBPACK_IMPORTED_MODULE_0__[\"compactObject\"](constraints.video)}\n    );\n  }\n\n  return constraints;\n}\n\nfunction shimRTCIceServerUrls(window) {\n  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n  const OrigPeerConnection = window.RTCPeerConnection;\n  window.RTCPeerConnection =\n    function RTCPeerConnection(pcConfig, pcConstraints) {\n      if (pcConfig && pcConfig.iceServers) {\n        const newIceServers = [];\n        for (let i = 0; i < pcConfig.iceServers.length; i++) {\n          let server = pcConfig.iceServers[i];\n          if (!server.hasOwnProperty('urls') &&\n              server.hasOwnProperty('url')) {\n            _utils__WEBPACK_IMPORTED_MODULE_0__[\"deprecated\"]('RTCIceServer.url', 'RTCIceServer.urls');\n            server = JSON.parse(JSON.stringify(server));\n            server.urls = server.url;\n            delete server.url;\n            newIceServers.push(server);\n          } else {\n            newIceServers.push(pcConfig.iceServers[i]);\n          }\n        }\n        pcConfig.iceServers = newIceServers;\n      }\n      return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n  // wrap static methods. Currently just generateCertificate.\n  if ('generateCertificate' in window.RTCPeerConnection) {\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n      get() {\n        return OrigPeerConnection.generateCertificate;\n      }\n    });\n  }\n}\n\nfunction shimTrackEventTransceiver(window) {\n  // Add event.transceiver member over deprecated event.receiver\n  if (typeof window === 'object' && window.RTCTrackEvent &&\n      'receiver' in window.RTCTrackEvent.prototype &&\n      !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {receiver: this.receiver};\n      }\n    });\n  }\n}\n\nfunction shimCreateOfferLegacy(window) {\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer =\n    function createOffer(offerOptions) {\n      if (offerOptions) {\n        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveAudio =\n            !!offerOptions.offerToReceiveAudio;\n        }\n        const audioTransceiver = this.getTransceivers().find(transceiver =>\n          transceiver.receiver.track.kind === 'audio');\n        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n          if (audioTransceiver.direction === 'sendrecv') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('sendonly');\n            } else {\n              audioTransceiver.direction = 'sendonly';\n            }\n          } else if (audioTransceiver.direction === 'recvonly') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('inactive');\n            } else {\n              audioTransceiver.direction = 'inactive';\n            }\n          }\n        } else if (offerOptions.offerToReceiveAudio === true &&\n            !audioTransceiver) {\n          this.addTransceiver('audio');\n        }\n\n        if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveVideo =\n            !!offerOptions.offerToReceiveVideo;\n        }\n        const videoTransceiver = this.getTransceivers().find(transceiver =>\n          transceiver.receiver.track.kind === 'video');\n        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n          if (videoTransceiver.direction === 'sendrecv') {\n            if (videoTransceiver.setDirection) {\n              videoTransceiver.setDirection('sendonly');\n            } else {\n              videoTransceiver.direction = 'sendonly';\n            }\n          } else if (videoTransceiver.direction === 'recvonly') {\n            if (videoTransceiver.setDirection) {\n              videoTransceiver.setDirection('inactive');\n            } else {\n              videoTransceiver.direction = 'inactive';\n            }\n          }\n        } else if (offerOptions.offerToReceiveVideo === true &&\n            !videoTransceiver) {\n          this.addTransceiver('video');\n        }\n      }\n      return origCreateOffer.apply(this, arguments);\n    };\n}\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/safari/safari_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/utils.js ***!
  \*****************************************************/
/*! exports provided: extractVersion, wrapPeerConnectionEvent, disableLog, disableWarnings, log, deprecated, detectBrowser, compactObject, walkStats, filterStats */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extractVersion\", function() { return extractVersion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wrapPeerConnectionEvent\", function() { return wrapPeerConnectionEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disableLog\", function() { return disableLog; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disableWarnings\", function() { return disableWarnings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"log\", function() { return log; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deprecated\", function() { return deprecated; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"detectBrowser\", function() { return detectBrowser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compactObject\", function() { return compactObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"walkStats\", function() { return walkStats; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filterStats\", function() { return filterStats; });\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nlet logDisabled_ = true;\nlet deprecationWarnings_ = true;\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\nfunction extractVersion(uastring, expr, pos) {\n  const match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n}\n\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  const nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    const wrappedCallback = (e) => {\n      const modifiedEvent = wrapper(e);\n      if (modifiedEvent) {\n        cb(modifiedEvent);\n      }\n    };\n    this._eventMap = this._eventMap || {};\n    this._eventMap[cb] = wrappedCallback;\n    return nativeAddEventListener.apply(this, [nativeEventName,\n      wrappedCallback]);\n  };\n\n  const nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap\n        || !this._eventMap[cb]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    const unwrappedCb = this._eventMap[cb];\n    delete this._eventMap[cb];\n    return nativeRemoveEventListener.apply(this, [nativeEventName,\n      unwrappedCb]);\n  };\n\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get() {\n      return this['_on' + eventNameToWrap];\n    },\n    set(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap] = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\n\nfunction disableLog(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool +\n        '. Please use a boolean.');\n  }\n  logDisabled_ = bool;\n  return (bool) ? 'adapter.js logging disabled' :\n      'adapter.js logging enabled';\n}\n\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */\nfunction disableWarnings(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool +\n        '. Please use a boolean.');\n  }\n  deprecationWarnings_ = !bool;\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n}\n\nfunction log() {\n  if (typeof window === 'object') {\n    if (logDisabled_) {\n      return;\n    }\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\n      console.log.apply(console, arguments);\n    }\n  }\n}\n\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */\nfunction deprecated(oldMethod, newMethod) {\n  if (!deprecationWarnings_) {\n    return;\n  }\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod +\n      ' instead.');\n}\n\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */\nfunction detectBrowser(window) {\n  const {navigator} = window;\n\n  // Returned result object.\n  const result = {browser: null, version: null};\n\n  // Fail early if it's not a browser\n  if (typeof window === 'undefined' || !window.navigator) {\n    result.browser = 'Not a browser.';\n    return result;\n  }\n\n  if (navigator.mozGetUserMedia) { // Firefox.\n    result.browser = 'firefox';\n    result.version = extractVersion(navigator.userAgent,\n        /Firefox\\/(\\d+)\\./, 1);\n  } else if (navigator.webkitGetUserMedia ||\n      (window.isSecureContext === false && window.webkitRTCPeerConnection &&\n       !window.RTCIceGatherer)) {\n    // Chrome, Chromium, Webview, Opera.\n    // Version matches Chrome/WebRTC version.\n    // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n    // more complicated fallback to webkitRTCPeerConnection.\n    result.browser = 'chrome';\n    result.version = extractVersion(navigator.userAgent,\n        /Chrom(e|ium)\\/(\\d+)\\./, 2);\n  } else if (navigator.mediaDevices &&\n      navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge.\n    result.browser = 'edge';\n    result.version = extractVersion(navigator.userAgent,\n        /Edge\\/(\\d+).(\\d+)$/, 2);\n  } else if (window.RTCPeerConnection &&\n      navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari.\n    result.browser = 'safari';\n    result.version = extractVersion(navigator.userAgent,\n        /AppleWebKit\\/(\\d+)\\./, 1);\n    result.supportsUnifiedPlan = window.RTCRtpTransceiver &&\n        'currentDirection' in window.RTCRtpTransceiver.prototype;\n  } else { // Default fallthrough: not supported.\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n\n  return result;\n}\n\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */\nfunction isObject(val) {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */\nfunction compactObject(data) {\n  if (!isObject(data)) {\n    return data;\n  }\n\n  return Object.keys(data).reduce(function(accumulator, key) {\n    const isObj = isObject(data[key]);\n    const value = isObj ? compactObject(data[key]) : data[key];\n    const isEmptyObject = isObj && !Object.keys(value).length;\n    if (value === undefined || isEmptyObject) {\n      return accumulator;\n    }\n    return Object.assign(accumulator, {[key]: value});\n  }, {});\n}\n\n/* iterates the stats graph recursively. */\nfunction walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(name => {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(id => {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n\n/* filter getStats for a sender/receiver track. */\nfunction filterStats(result, track, outbound) {\n  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  const filteredResult = new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  const trackStats = [];\n  result.forEach(value => {\n    if (value.type === 'track' &&\n        value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(trackStat => {\n    result.forEach(stats => {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/utils.js?");

/***/ }),

/***/ "./src/FlowrouteClient.js":
/*!********************************!*\
  !*** ./src/FlowrouteClient.js ***!
  \********************************/
/*! exports provided: FR_POINTS_OF_PRESENCE_DOMAINS, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FR_POINTS_OF_PRESENCE_DOMAINS\", function() { return FR_POINTS_OF_PRESENCE_DOMAINS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return FlowrouteClient; });\n/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webrtc-adapter */ \"./node_modules/webrtc-adapter/src/js/adapter_core.js\");\n/* harmony import */ var lodash_first__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.first */ \"./node_modules/lodash.first/index.js\");\n/* harmony import */ var lodash_first__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_first__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var jssip_lib_JsSIP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jssip/lib/JsSIP */ \"./node_modules/jssip/lib/JsSIP.js\");\n/* harmony import */ var jssip_lib_JsSIP__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jssip_lib_JsSIP__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _QualityOfService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./QualityOfService */ \"./src/QualityOfService.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar FR_POINTS_OF_PRESENCE_DOMAINS = {\n  'us-east-nj': ['staging-ep-us-west-or-01.fl.gg', 'preprod-ep-us-east-nj-01.fl.gg'],\n  'us-west-or': ['wr-us-west-or-01.webrtc.flowroute.com', 'wr-us-east-va-01.webrtc.flowroute.com'],\n  'us-east-va': ['wr-us-east-va-01.webrtc.flowroute.com', 'wr-us-west-or-01.webrtc.flowroute.com']\n};\n/**\n * Flowroute SIP over WebSocket and WebRTC JavaScript client.\n *\n * This class is a facade for WebRTC, DOM and JsSIP APIs,\n * so it'll return many of its types and dispatch many of\n * its events, with some changes to ease Flowroute apps work.\n *\n * @see https://jssip.net/documentation/3.3.x/api/\n */\n\nvar FlowrouteClient =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Init a JsSIP user agent.\n   *\n   * @param {object}   params\n   * @param {string}   params.pointOfPresence one of `FR_POINTS_OF_PRESENCE_DOMAINS` keys\n   * @param {string}   params.callerId caller ID for building user agent URI\n   * @param {string}   params.displayName to be used on calls params\n   * @param {string}   params.password to be used on calls params\n   * @param {boolean}  params.debug will output to stdout JsSIP debugging logs\n   * @param {function} params.onUserAgentAction general callback for UA events and its payloads\n   * @param {function} params.intervalOfQualityReport in milliseconds\n   */\n  function FlowrouteClient() {\n    var _this = this;\n\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, FlowrouteClient);\n\n    this.params = _objectSpread({\n      pointOfPresence: 'us-west-or',\n      callerId: 'anonymous',\n      displayName: 'Flowroute Client Demo',\n      password: 'nopassword',\n      extraHeaders: [],\n      debug: false,\n      intervalOfQualityReport: undefined,\n      onUserAgentAction: function onUserAgentAction() {}\n    }, params);\n    var urls = FR_POINTS_OF_PRESENCE_DOMAINS[this.params.pointOfPresence];\n    var sockets = [{\n      socket: new jssip_lib_JsSIP__WEBPACK_IMPORTED_MODULE_2__[\"WebSocketInterface\"](\"wss://\".concat(urls[0], \":4443\")),\n      weight: 10\n    }, {\n      socket: new jssip_lib_JsSIP__WEBPACK_IMPORTED_MODULE_2__[\"WebSocketInterface\"](\"wss://\".concat(urls[1], \":4443\")),\n      weight: 10\n    }];\n    this.micMuted = false;\n    this.qualityOfServiceEmitter = null;\n    this.outputVolume = 1;\n    this.isRegistered = false;\n\n    this.onCallAction = function () {};\n\n    this.onUserAgentAction = this.params.onUserAgentAction;\n    this.sipUserAgent = new jssip_lib_JsSIP__WEBPACK_IMPORTED_MODULE_2__[\"UA\"]({\n      sockets: sockets,\n      uri: \"sip:\".concat(this.params.callerId, \"@wss.flowroute.com\"),\n      password: this.params.password,\n      display_name: this.params.displayName\n    });\n    this.sipUserAgent.on('newRTCSession', this.handleNewRTCSession.bind(this));\n    this.sipUserAgent.on('registered', function (payload) {\n      _this.isRegistered = true;\n\n      _this.onUserAgentAction({\n        type: 'registered',\n        payload: payload\n      });\n    });\n    var defaultAgentEventsToHandle = ['connecting', 'connected', 'disconnected', 'unregistered', 'registrationFailed', 'registrationExpiring', 'newMessage', 'sipEvent'];\n    defaultAgentEventsToHandle.forEach(function (eventType) {\n      _this.sipUserAgent.on(eventType, function (payload) {\n        _this.onUserAgentAction({\n          type: eventType,\n          payload: payload\n        });\n      });\n    });\n  }\n  /**\n   * Connect to the signaling server, registering user agent.\n   */\n\n\n  _createClass(FlowrouteClient, [{\n    key: \"start\",\n    value: function start() {\n      if (this.params.debug) {\n        jssip_lib_JsSIP__WEBPACK_IMPORTED_MODULE_2__[\"debug\"].enable('JsSIP:*');\n      } else {\n        jssip_lib_JsSIP__WEBPACK_IMPORTED_MODULE_2__[\"debug\"].disable('JsSIP:*');\n      }\n\n      this.sipUserAgent.start();\n    }\n    /**\n     * Disconnect from signaling server.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.sipUserAgent.stop();\n    }\n    /**\n     * Set to what number this client will call.\n     * (You may pass this by `call` method args too.)\n     *\n     * @param {string} did\n     */\n\n  }, {\n    key: \"setDID\",\n    value: function setDID(did) {\n      if (typeof did !== 'string') {\n        throw new Error('Expected DID to be a string');\n      } else if (did.length !== 11) {\n        throw new Error('Currently only DIDs with 11 length are supported');\n      }\n\n      this.params = _objectSpread({}, this.params, {\n        did: did\n      });\n    }\n    /**\n     * Make a call.\n     * Also initialize any necessary DOM node for audio output.\n     * Created call will be available by `getActiveCall` getter method.\n     *\n     * @param {object}        options\n     * @param {string}        options.to number destiny\n     * @param {function}      options.onCallAction callback for call events and its payloads\n     * @param {object|string} options.audioConstraints callback for call events and its payloads\n     */\n\n  }, {\n    key: \"call\",\n    value: function call() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.isRegistered) {\n        throw new Error('User agent not registered yet');\n      }\n\n      if (this.activeCall) {\n        throw new Error('Already has active call');\n      } else {\n        this.activeCall = {};\n      }\n\n      var to = options.to,\n          _options$onCallAction = options.onCallAction,\n          onCallAction = _options$onCallAction === void 0 ? function () {} : _options$onCallAction;\n      var did = to || this.params.did;\n\n      if (did) {\n        this.setDID(did);\n      } else {\n        throw new Error('No DID provided');\n      }\n\n      if (!this.audioPlayerElement) {\n        this.setAudioElement();\n      }\n\n      this.onCallAction = onCallAction;\n      this.sipUserAgent.call(\"sip:\".concat(did, \"@sip.flowroute.com\"), {\n        mediaConstraints: {\n          audio: options.audioConstraints || true,\n          video: false\n        },\n        extraHeaders: this.params.extraHeaders,\n        RTCConstraints: {\n          optional: [{\n            DtlsSrtpKeyAgreement: 'true'\n          }]\n        },\n        sessionTimersExpires: 600\n      });\n    }\n    /**\n     * Getter of active call, i.e., a proxy for current RTC JsSIP session.\n     *\n     * If a call attempt was made but no \"newRTCSession\" user agent event\n     * was dispatched, then this should be `{}`, which is still a truthy JS object\n     * but with no available RTC methods to proxy. And while no call is made or the\n     * previous one was already hung up or failed, this should be the falsy `null`.\n     *\n     * When desired to hangup the session call, use `hangup` client method\n     * instead of directly terminating this returned session.\n     *\n     * @return {RTCSession|object}\n     */\n\n  }, {\n    key: \"getActiveCall\",\n    value: function getActiveCall() {\n      return this.activeCall;\n    }\n    /**\n     * Hangup current active call and unassign it.\n     */\n\n  }, {\n    key: \"hangup\",\n    value: function hangup() {\n      if (!this.activeCall) {\n        throw new Error('There is no active call to hangup');\n      }\n\n      this.activeCall.terminate();\n      this.activeCall = null;\n    }\n    /**\n     * Set audio player volume.\n     *\n     * @param {number|string} value between 0 and 100\n     */\n\n  }, {\n    key: \"setOutputVolume\",\n    value: function setOutputVolume(value) {\n      var volume = parseInt(value, 10) / 100;\n\n      if (volume < 0) {\n        this.outputVolume = 0;\n      } else if (volume > 1) {\n        this.outputVolume = 1;\n      } else {\n        this.outputVolume = volume;\n      }\n\n      if (this.audioPlayerElement) {\n        this.audioPlayerElement.volume = this.outputVolume;\n      }\n    }\n    /**\n     * Set microphone mute.\n     *\n     * @param {boolean} user microphone is muted\n     */\n\n  }, {\n    key: \"setMicMuted\",\n    value: function setMicMuted(value) {\n      if (value) {\n        this.micMuted = true;\n        if (this.activeCall) this.activeCall.mute();\n      } else {\n        this.micMuted = false;\n        if (this.activeCall) this.activeCall.unmute();\n      }\n    }\n    /**\n     * Get audio player volume.\n     *\n     * @return {number} between 0 and 100\n     */\n\n  }, {\n    key: \"getOutputVolume\",\n    value: function getOutputVolume() {\n      return this.outputVolume * 100;\n    }\n    /**\n     * Add a P-header to client calls.\n     *\n     * @param {string} name\n     * @param {string} value\n     */\n\n  }, {\n    key: \"pushExtraPrivateCallHeader\",\n    value: function pushExtraPrivateCallHeader(name, value) {\n      if (!name || !value) {\n        throw new Error('Provide name and value for adding P-header');\n      }\n\n      this.params.extraHeaders.push(\"P-\".concat(name, \": \").concat(value));\n    }\n    /**\n     * Get a reference of P-headers passed by `pushExtraPrivateCallHeader` method.\n     *\n     * @return {array}\n     */\n\n  }, {\n    key: \"getExtraCallHeaders\",\n    value: function getExtraCallHeaders() {\n      return this.params.extraHeaders;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"setAudioElement\",\n    value: function setAudioElement(domNode) {\n      if (domNode === undefined) {\n        var created = document.createElement('audio');\n        this.audioPlayerElement = created;\n      } else if (typeof domNode === 'string') {\n        var found = document.querySelector(domNode);\n\n        if (!found || found.tagName.toLowerCase() !== 'audio') {\n          throw new Error('Invalid DOM selector provided for audio element');\n        }\n\n        this.audioPlayerElement = found;\n      } else {\n        this.audioPlayerElement = domNode;\n      }\n\n      this.audioPlayerElement.defaultMuted = false;\n      this.audioPlayerElement.autoplay = true;\n      this.audioPlayerElement.controls = true;\n      this.audioPlayerElement.volume = this.outputVolume;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"handleNewRTCSession\",\n    value: function handleNewRTCSession(rtcPayload) {\n      var _this2 = this;\n\n      var session = rtcPayload.session,\n          request = rtcPayload.request;\n      this.activeCall = session;\n      var defaultCallEventsToHandle = ['peerconnection', 'connecting', 'sending', 'progress', 'accepted', 'newDTMF', 'newInfo', 'hold', 'unhold', 'muted', 'unmuted', 'reinvite', 'update', 'refer', 'replaces', 'sdp', 'icecandidate', 'getusermediafailed'];\n      defaultCallEventsToHandle.forEach(function (eventType) {\n        session.on(eventType, function (payload) {\n          _this2.onCallAction({\n            type: eventType,\n            payload: payload\n          });\n        });\n      });\n      session.on('confirmed', function (payload) {\n        _this2.connectAudio(session);\n\n        _this2.onCallAction({\n          type: 'confirmed',\n          payload: payload\n        });\n      });\n      session.on('ended', function (payload) {\n        _this2.disconnectAudio();\n\n        _this2.activeCall = null;\n\n        _this2.onCallAction({\n          type: 'ended',\n          payload: payload\n        });\n      });\n      session.on('failed', function (payload) {\n        _this2.disconnectAudio();\n\n        _this2.activeCall = null;\n\n        _this2.onCallAction({\n          type: 'failed',\n          payload: payload\n        });\n      });\n      this.qualityOfServiceEmitter = new _QualityOfService__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.sipUserAgent, session.connection, request.call_id, this.params.did, this.params.intervalOfQualityReport);\n      this.onUserAgentAction({\n        type: 'newRTCSession',\n        payload: rtcPayload\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"connectAudio\",\n    value: function connectAudio(session) {\n      if (this.audioPlayerElement) {\n        this.disconnectAudio();\n      } else {\n        throw new Error('Tried to connect audio but no player element provided');\n      }\n\n      var remoteStreams = session.connection.getRemoteStreams();\n      this.audioPlayerElement.srcObject = lodash_first__WEBPACK_IMPORTED_MODULE_1___default()(remoteStreams);\n      this.qualityOfServiceEmitter.start();\n      this.setMicMuted(this.micMuted);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"disconnectAudio\",\n    value: function disconnectAudio() {\n      if (!this.audioPlayerElement || !this.audioPlayerElement.srcObject) {\n        return;\n      }\n\n      this.audioPlayerElement.srcObject.getTracks().forEach(function (track) {\n        return track.stop();\n      });\n      this.audioPlayerElement.srcObject = null;\n      this.qualityOfServiceEmitter.stop();\n    }\n  }]);\n\n  return FlowrouteClient;\n}();\n\n\nwindow.FlowrouteClient = FlowrouteClient;\n\n//# sourceURL=webpack:///./src/FlowrouteClient.js?");

/***/ }),

/***/ "./src/QualityOfService.js":
/*!*********************************!*\
  !*** ./src/QualityOfService.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return QualityOfService; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Proxy and emitter of RTC connection and media quality.\n */\nvar QualityOfService =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Client for gathering RTC stats and sending as SIP message.\n   *\n   * @param {UA} sipUserAgent\n   * @param {RTCPeerConnection} realtimeSessionConnection\n   * @param {string} callId\n   * @param {sting} did\n   * @param {number} interval\n   */\n  function QualityOfService(sipUserAgent, realtimeSessionConnection, callId, did, interval) {\n    _classCallCheck(this, QualityOfService);\n\n    this.sipUserAgent = sipUserAgent;\n    this.realtimeSessionConnection = realtimeSessionConnection;\n    this.callId = callId;\n    this.did = did;\n    this.interval = interval && interval > 1000 && interval < 60000 ? interval : 5000;\n    this.realtimeProtocolReceiverData = null;\n    this.realtimeProtocolTransmitterData = null;\n    this.mediaReceiverData = null;\n    this.mediaTransmitterData = null;\n    this.isActive = false;\n  }\n  /**\n   * Start gathering RTC connection stats and send them on each `interval` of milliseconds.\n   */\n\n\n  _createClass(QualityOfService, [{\n    key: \"start\",\n    value: function start() {\n      if (this.isActive) {\n        return;\n      }\n\n      this.isActive = true;\n      this.keepGatheringStats();\n    }\n    /**\n     * Stop gathering RTC connection stats, nor send them.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.isActive = false;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"addStat\",\n    value: function addStat(data) {\n      var id = data.id;\n\n      if (id) {\n        if (id.includes('inbound_rtp_audio') || id.includes('RTCInboundRTPAudioStream')) {\n          this.realtimeProtocolReceiverData = data;\n        } else if (id.includes('outbound_rtp_audio') || id.includes('RTCOutboundRTPAudioStream')) {\n          this.realtimeProtocolTransmitterData = data;\n        } else if (id.includes('RTCMediaStreamTrack_receiver')) {\n          this.mediaReceiverData = data;\n        } else if (id.includes('RTCMediaStreamTrack_sender')) {\n          this.mediaTransmitterData = data;\n        }\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"sendAddedStats\",\n    value: function sendAddedStats() {\n      if (!this.realtimeProtocolReceiverData || !this.realtimeProtocolTransmitterData) {\n        return;\n      }\n\n      var report = {\n        qos_data: {\n          rx: this.realtimeProtocolReceiverData,\n          tx: this.realtimeProtocolTransmitterData\n        }\n      };\n\n      if (this.mediaTransmitter) {\n        report.qos_data.tx_media = this.mediaTransmitter;\n      }\n\n      if (this.mediaReceiver) {\n        report.qos_data.rx_media = this.mediaReceiver;\n      }\n\n      var to = \"\".concat(this.did, \"@sip.flowroute.com\");\n      this.sipUserAgent.sendMessage(to, JSON.stringify(report, null, 2), {\n        extraHeaders: [\"P-QoS-Call-ID:\".concat(this.callId)]\n      });\n      this.realtimeProtocolReceiverData = null;\n      this.realtimeProtocolTransmitterData = null;\n      this.mediaReceiverData = null;\n      this.mediaTransmitterData = null;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"keepGatheringStats\",\n    value: function keepGatheringStats() {\n      var _this = this;\n\n      this.realtimeSessionConnection.getStats().then(function (rtcStatsReport) {\n        if (!_this.isActive) {\n          return;\n        }\n\n        rtcStatsReport.forEach(_this.addStat.bind(_this));\n\n        _this.sendAddedStats();\n\n        setTimeout(_this.keepGatheringStats.bind(_this), _this.interval);\n      });\n    }\n  }]);\n\n  return QualityOfService;\n}();\n\n\n\n//# sourceURL=webpack:///./src/QualityOfService.js?");

/***/ })

/******/ });